{
  "hash": "0f51ae636fa1da3098b2e5c231c82676",
  "result": {
    "markdown": "# 3b: Sampling the Imaginary\n\n\n::: {.cell}\n\n````{.cell-code}\n```{{r}}\n#| label: setup\n\nlibrary(tidyverse)\n```\n````\n\n```\n#> ── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n#> ✔ dplyr     1.1.2     ✔ readr     2.1.4\n#> ✔ forcats   1.0.0     ✔ stringr   1.5.0\n#> ✔ ggplot2   3.4.2     ✔ tibble    3.2.1\n#> ✔ lubridate 1.9.2     ✔ tidyr     1.3.0\n#> ✔ purrr     1.0.1     \n#> ── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n#> ✖ dplyr::filter() masks stats::filter()\n#> ✖ dplyr::lag()    masks stats::lag()\n#> ℹ Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors\n```\n\n````{.cell-code}\n```{{r}}\n#| label: setup\n\nlibrary(tidybayes)\n```\n````\n:::\n\n\n**Medical Test Scenario with Bayes theorem**\n\nIf you would like to know the probability someone is a vampire given\nthey test positive to the blood-based vampire test, you compute\n\n$$\nPr(vampire|positive) = \\frac{Pr(positive|vampire) \\times Pr(vampire)} {Pr(positive)}\n$$ This is Bayes theorem.\n\n\n::: {.cell}\n\n````{.cell-code}\n```{{r}}\n#| label: scenario-bayes-theorem-b\n\ntibble(pr_positive_vampire_b = .95,\n       pr_positive_mortal_b  = .01,\n       pr_vampire_b          = .001) %>% \n  mutate(pr_positive_b = pr_positive_vampire_b * pr_vampire_b + pr_positive_mortal_b * (1 - pr_vampire_b)) %>% \n  mutate(pr_vampire_positive_b = pr_positive_vampire_b * pr_vampire_b / pr_positive_b) %>% \n  glimpse()\n```\n````\n\n```\n#> Rows: 1\n#> Columns: 5\n#> $ pr_positive_vampire_b <dbl> 0.95\n#> $ pr_positive_mortal_b  <dbl> 0.01\n#> $ pr_vampire_b          <dbl> 0.001\n#> $ pr_positive_b         <dbl> 0.01094\n#> $ pr_vampire_positive_b <dbl> 0.08683729\n```\n:::\n\n\n**Medical test scenario with natural frequencies**\n\n\n::: {.cell}\n\n````{.cell-code}\n```{{r}}\n#| label: scenario-natural-frequencies\n\ntibble(pr_vampire_b2          = 100 / 100000,\n       pr_positive_vampire_b2 = 95 / 100,\n       pr_positive_mortal_b2  = 999 / 99900) %>% \n  mutate(pr_positive_b2 = 95 + 999) %>% \n  mutate(pr_vampire_positive_b2 = pr_positive_vampire_b2 * 100 / pr_positive_b2) %>% \n  glimpse()\n```\n````\n\n```\n#> Rows: 1\n#> Columns: 5\n#> $ pr_vampire_b2          <dbl> 0.001\n#> $ pr_positive_vampire_b2 <dbl> 0.95\n#> $ pr_positive_mortal_b2  <dbl> 0.01\n#> $ pr_positive_b2         <dbl> 1094\n#> $ pr_vampire_positive_b2 <dbl> 0.08683729\n```\n:::\n\n\n## 3.1b Sampling from Grid\n\n\n::: {.cell}\n\n````{.cell-code}\n```{{r}}\n#| label: sampling-grid-b\n\n# how many grid points would you like?\nn <- 1000\nn_success <- 6\nn_trials  <- 9\n\n(\n  d <-\n  tibble(p_grid_b = seq(from = 0, to = 1, length.out = n),\n         # note we're still using a flat uniform prior\n         prior  = 1) %>% \n  mutate(likelihood = dbinom(n_success, size = n_trials, prob = p_grid_b)) %>% \n  mutate(posterior_b = (likelihood * prior) / sum(likelihood * prior))\n)\n```\n````\n\n```\n#> # A tibble: 1,000 × 4\n#>    p_grid_b prior likelihood posterior_b\n#>       <dbl> <dbl>      <dbl>       <dbl>\n#>  1  0           1   0           0       \n#>  2  0.00100     1   8.43e-17    8.43e-19\n#>  3  0.00200     1   5.38e-15    5.38e-17\n#>  4  0.00300     1   6.11e-14    6.11e-16\n#>  5  0.00400     1   3.42e-13    3.42e-15\n#>  6  0.00501     1   1.30e-12    1.30e-14\n#>  7  0.00601     1   3.87e-12    3.88e-14\n#>  8  0.00701     1   9.73e-12    9.74e-14\n#>  9  0.00801     1   2.16e-11    2.16e-13\n#> 10  0.00901     1   4.37e-11    4.38e-13\n#> # ℹ 990 more rows\n```\n:::\n\n\nWe've renamed McElreath's `prob_p` and `prob_data` as `prior` and\n`likelihood`, respectively. Now we'll use the `dplyr::slice_sample()`\nfunction to sample rows from `d`, saving them as `samples_b`.\n\n\n::: {.cell}\n\n````{.cell-code}\n```{{r}}\n#| label: sample-grid-b2\n\n# how many samples would you like?\nn_samples <- 1e4\n\n# make it reproducible\nset.seed(3)\n\nsamples_b <-\n  d %>% \n  slice_sample(n = n_samples, weight_by = posterior_b, replace = T)\n\n# to see the difference between grid and samples \n# I will change all names for the samples_b data frame\nsamples_b <- samples_b |> \n    rename(p_grid_b_sample = p_grid_b,\n           prior_sample = prior,\n           posterior_b_sample = posterior_b,\n           likelihood_sample = likelihood)\n\nglimpse(samples_b)\n```\n````\n\n```\n#> Rows: 10,000\n#> Columns: 4\n#> $ p_grid_b_sample    <dbl> 0.5645646, 0.6516517, 0.5475475, 0.5905906, 0.59559…\n#> $ prior_sample       <dbl> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, …\n#> $ likelihood_sample  <dbl> 0.22455994, 0.27190272, 0.20966655, 0.24460869, 0.2…\n#> $ posterior_b_sample <dbl> 0.0022478473, 0.0027217490, 0.0020987643, 0.0024485…\n```\n:::\n\n\nWith the `str()` function you will get a result with shorter figures\nthat is better adapted to a small screen.\n\n\n::: {.cell}\n\n````{.cell-code}\n```{{r}}\n#| label: sample-grid-b2-str\n\nstr(samples_b)\n```\n````\n\n```\n#> tibble [10,000 × 4] (S3: tbl_df/tbl/data.frame)\n#>  $ p_grid_b_sample   : num [1:10000] 0.565 0.652 0.548 0.591 0.596 ...\n#>  $ prior_sample      : num [1:10000] 1 1 1 1 1 1 1 1 1 1 ...\n#>  $ likelihood_sample : num [1:10000] 0.225 0.272 0.21 0.245 0.248 ...\n#>  $ posterior_b_sample: num [1:10000] 0.00225 0.00272 0.0021 0.00245 0.00248 ...\n```\n:::\n\n\nNow we can plot the left panel of Figure 3.1 with `geom_point()`. But\nbefore we do, we'll need to add a variable numbering the samples.\n\n\n::: {.cell}\n\n````{.cell-code}\n```{{r}}\n#| label: plot-points\n\nsamples_b %>% \n  mutate(sample_number = 1:n()) %>% \n  \n  ggplot(aes(x = sample_number, y = p_grid_b_sample)) +\n  geom_point(alpha = 1/10) +\n  scale_y_continuous(\"proportion of water (p)\", limits = c(0, 1)) +\n  xlab(\"sample number\")\n```\n````\n\n::: {.cell-output-display}\n![](03b-sampling-the-imaginary_files/figure-html/plot-points-1.png){width=672}\n:::\n:::\n\n\nWe'll make the density in the right panel with `geom_density()`.\n\n\n::: {.cell}\n\n````{.cell-code}\n```{{r}}\n#| label: plot-density\n\nsamples_b %>% \n  ggplot(aes(x = p_grid_b_sample)) +\n  geom_density(fill = \"grey\") +\n  scale_x_continuous(\"proportion of water (p)\", limits = c(0, 1))\n```\n````\n\n::: {.cell-output-display}\n![](03b-sampling-the-imaginary_files/figure-html/plot-density-1.png){width=672}\n:::\n:::\n\n\nIf we keep increasing the number of samples we will get a better\napproximation to the ideal posterior distribution we have computed via\ngrid approximation.. Here's what it looks like with `1e6`.\n\n\n::: {.cell}\n\n````{.cell-code}\n```{{r}}\n#| label: plot-density2\n\nset.seed(3)\n\nd %>% \n  slice_sample(n = 1e6, weight_by = posterior_b, replace = T) %>% \n  ggplot(aes(x = p_grid_b)) +\n  geom_density(fill = \"grey\") +\n  scale_x_continuous(\"proportion of water (p)\", limits = c(0, 1))\n```\n````\n\n::: {.cell-output-display}\n![](03b-sampling-the-imaginary_files/figure-html/plot-density2-1.png){width=672}\n:::\n:::\n\n\n## 3.2b Sampling to Summarize\n\n### 3.2.1b Intervals of Defined Boundaries\n\n\n::: {.cell}\n\n````{.cell-code}\n```{{r}}\n#| label: grid-boundaries-b\n\n# add up posterior probability where p < 0.5\nd |> filter(p_grid_b < 0.5) |> \n    summarize(sum = sum(posterior_b))\n```\n````\n\n```\n#> # A tibble: 1 × 1\n#>     sum\n#>   <dbl>\n#> 1 0.172\n```\n:::\n\n\nIf what you want is a frequency based on filtering by `samples`, then\nyou might use `n()` within `summarise()`.\n\n\n::: {.cell}\n\n````{.cell-code}\n```{{r}}\n#| label: grid-boundaries-b2\n\n# add up all posterior probabilities of samples under .5\nsamples_b |> \n    filter(p_grid_b_sample < .5) |> \n    summarize(sum = n() / n_samples)\n```\n````\n\n```\n#> # A tibble: 1 × 1\n#>     sum\n#>   <dbl>\n#> 1 0.163\n```\n:::\n\n\nA more explicit approach for the same computation is to follow up\n`count()` with `mutate()`.\n\n\n::: {.cell}\n\n````{.cell-code}\n```{{r}}\n#| label: grid-boundaries-b3\n\nsamples_b |> \n    count(p_grid_b_sample < .5) |> \n    mutate(probability = n / sum(n))\n```\n````\n\n```\n#> # A tibble: 2 × 3\n#>   `p_grid_b_sample < 0.5`     n probability\n#>   <lgl>                   <int>       <dbl>\n#> 1 FALSE                    8371       0.837\n#> 2 TRUE                     1629       0.163\n```\n:::\n\n\nAn even trickier approach for the same is to insert the logical\nstatement `p_grid < .5` within the `mean()` function.\n\n\n::: {.cell}\n\n````{.cell-code}\n```{{r}}\n#| label: grid-boundaries-b4\n\nsamples_b |> \n    summarize(sum = mean(p_grid_b_sample < .5))\n```\n````\n\n```\n#> # A tibble: 1 × 1\n#>     sum\n#>   <dbl>\n#> 1 0.163\n```\n:::\n\n\nTo determine the posterior probability between 0.5 and 0.75, you can use\n`&` within `filter()`.\n\n\n::: {.cell}\n\n````{.cell-code}\n```{{r}}\n#| label: grid-boundaries-b5\n\nsamples_b |> \n    filter(p_grid_b_sample > .5 & p_grid_b_sample < .75) |> \n    summarize(sum = n() / n_samples)\n```\n````\n\n```\n#> # A tibble: 1 × 1\n#>     sum\n#>   <dbl>\n#> 1 0.606\n```\n:::\n\n::: {.cell}\n\n````{.cell-code}\n```{{r}}\n#| label: figure-3-2-upper-part\n\n# upper left panel\np1 <-\n  d %>% \n  ggplot(aes(x = p_grid_b, y = posterior_b)) +\n  geom_line() +\n  geom_area(data = d %>% filter(p_grid_b < .5), fill = \"blue\") +\n  labs(x = \"proportion of water (p)\",\n       y = \"density\")\n\n# upper right panel\np2 <- \n  d %>% \n  ggplot(aes(x = p_grid_b, y = posterior_b)) +\n  geom_line() +\n  geom_area(data = d %>% filter(p_grid_b > .5 & p_grid_b < .75), fill = \"blue\") +\n  labs(x = \"proportion of water (p)\",\n       y = \"density\")\n\nlibrary(patchwork)\np1 + p2\n```\n````\n\n::: {.cell-output-display}\n![](03b-sampling-the-imaginary_files/figure-html/figure-3-2-upper-part-1.png){width=672}\n:::\n:::\n\n\n### 3.2.2b Interval of Defined Mass\n\nSince we saved our `p_grid_b_sample` samples within the well-named\n`samples` tibble, we'll have to index with `$` within `quantile`.\n\n\n::: {.cell}\n\n````{.cell-code}\n```{{r}}\n#| label: sample-quantile-b\n\n(q80 <- quantile(samples_b$p_grid_b_sample, probs = .8))\n```\n````\n\n```\n#>       80% \n#> 0.7627628\n```\n:::\n\n\nFor an alternative approach, we could `select()` the `samples` vector,\nextract it from the tibble with `pull()`, and then pump it into\n`quantile()`.\n\n> `pull()` is similar to `$`. It's mostly useful because it looks a\n> little nicer in pipes, it also works with remote data frames, and it\n> can optionally name the output.\n\n\n::: {.cell}\n\n````{.cell-code}\n```{{r}}\n#| label: sample-quantile-b2\n\nsamples_b |> \n    pull(p_grid_b_sample) |> \n    quantile(probs = .8)\n    \n```\n````\n\n```\n#>       80% \n#> 0.7627628\n```\n:::\n\n\nWe might also use `quantile()` within `summarise()`.\n\n\n::: {.cell}\n\n````{.cell-code}\n```{{r}}\n#| label: sample-quantile-b3\n\nsamples_b |> \n    summarize(q80_2 = quantile(p_grid_b_sample, probs = .8))\n```\n````\n\n```\n#> # A tibble: 1 × 1\n#>   q80_2\n#>   <dbl>\n#> 1 0.763\n```\n:::\n\n::: {.cell}\n\n````{.cell-code}\n```{{r}}\n#| label: sample-quantile-b4\n\nsamples_b |> \n    summarize(q10 = quantile(p_grid_b_sample, probs = .1),\n               q90 = quantile(p_grid_b_sample, probs = .9))\n    \n```\n````\n\n```\n#> # A tibble: 1 × 2\n#>     q10   q90\n#>   <dbl> <dbl>\n#> 1 0.451 0.815\n```\n:::\n\n\nReturning not a data frame but just a vector\n\n\n::: {.cell}\n\n````{.cell-code}\n```{{r}}\n#| label: sample-quantile-b5\n\n(q10_q90 = quantile(samples_b$p_grid_b_sample, probs = c(.1, .9)))\n```\n````\n\n```\n#>       10%       90% \n#> 0.4514515 0.8148148\n```\n:::\n\n::: {.cell}\n\n````{.cell-code}\n```{{r}}\n#| label: sample-quantile-b6\n\nsamples_b |> \n    summarize(q10_90 = quantile(p_grid_b_sample, probs = c(.1, .9)))\n```\n````\n\n```\n#> Warning: Returning more (or less) than 1 row per `summarise()` group was deprecated in\n#> dplyr 1.1.0.\n#> ℹ Please use `reframe()` instead.\n#> ℹ When switching from `summarise()` to `reframe()`, remember that `reframe()`\n#>   always returns an ungrouped data frame and adjust accordingly.\n#> # A tibble: 2 × 1\n#>   q10_90\n#>    <dbl>\n#> 1  0.451\n#> 2  0.815\n```\n:::\n\n\n> ```         \n> Warning: Returning more (or less) than 1 row per `summarise()` group was deprecated in dplyr 1.1.0.\n> Please use `reframe()` instead.\n> When switching from `summarise()` to `reframe()`, remember that `reframe()` always returns an ungrouped data frame and adjust accordingly.\n> ```\n\n\n::: {.cell}\n\n````{.cell-code}\n```{{r}}\n#| label: sample-quantile-b7\n\nsamples_b |> \n    reframe(q10_90 = quantile(p_grid_b_sample, probs = c(.1, .9)))\n```\n````\n\n```\n#> # A tibble: 2 × 1\n#>   q10_90\n#>    <dbl>\n#> 1  0.451\n#> 2  0.815\n```\n:::\n\n\nNow we have our cutoff values saved as `q80`, respectively `q10` and\n`q90`, we're ready to make the bottom panels of Figure 3.2.\n\n\n::: {.cell}\n\n````{.cell-code}\n```{{r}}\n#| label: figure-3-2-lower-part\n\np1 <-\n  d %>% \n  ggplot(aes(x = p_grid_b, y = posterior_b)) +\n  geom_line() +\n  geom_area(data = d %>% filter(p_grid_b < q80), fill = \"blue\") +\n  annotate(geom = \"text\",\n           x = .25, y = .0025,\n           label = \"lower 80%\") +\n  labs(x = \"proportion of water (p)\",\n       y = \"density\")\n\n# upper right panel\np2 <- \n  d %>% \n  ggplot(aes(x = p_grid_b, y = posterior_b)) +\n  geom_line() +\n  geom_area(data = d %>% filter(p_grid_b > q10_q90[[1]] & p_grid_b < q10_q90[[2]]), fill = \"blue\") +\n  annotate(geom = \"text\",\n           x = .25, y = .0025,\n           label = \"middle 80%\") +\n  labs(x = \"proportion of water (p)\",\n       y = \"density\")\n\nlibrary(patchwork)\np1 + p2\n```\n````\n\n::: {.cell-output-display}\n![](03b-sampling-the-imaginary_files/figure-html/figure-3-2-lower-part-1.png){width=672}\n:::\n:::\n\n\n**Percentile Intervals** (PI) do a good job of communicating the shape\nof a distribution, *as long as the distribution isn't too asymmetrical*.\nBut in terms of describing the shape of the posterior\ndistribution---which is really all these intervals are asked to do---the\npercentile interval can be misleading.\n\nThe following skewed distribution demonstrates the misleading character\nof PIs:\n\nWe've already defined `p_grid_b` and `prior` within `d`, above. Here\nwe'll reuse them and create a new tibble by updating all the columns\nwith the skewed parameters.\n\n\n::: {.cell}\n\n````{.cell-code}\n```{{r}}\n#| label: pi-skewed-b\n\n# here we update the `dbinom()` parameters\nn_success_skewed <- 3\nn_trials_skewed  <- 3\n\n\n# update `d` to d_skewed\nd_skewed <-\n  d %>% \n  mutate(likelihood_b_skewed = dbinom(n_success_skewed, size = n_trials_skewed, prob = p_grid_b)) %>% \n  mutate(posterior_b_skewed  = (likelihood_b_skewed * prior) / sum(likelihood_b_skewed * prior))\n\n# make the next part reproducible\nset.seed(3)\n\n# here's our new samples tibble\n(\n    d_skewed <- \n        d_skewed %>% \n        slice_sample(n = 9000, weight_by = posterior_b_skewed, replace = T) |> \n        rename(p_grid_b_skewed = p_grid_b)\n)\n```\n````\n\n```\n#> # A tibble: 9,000 × 6\n#>    p_grid_b_skewed prior likelihood posterior_b likelihood_b_skewed\n#>              <dbl> <dbl>      <dbl>       <dbl>               <dbl>\n#>  1           0.717     1  0.259     0.00259                  0.368 \n#>  2           0.652     1  0.272     0.00272                  0.277 \n#>  3           0.548     1  0.210     0.00210                  0.164 \n#>  4           1         1  0         0                        1     \n#>  5           0.991     1  0.0000582 0.000000582              0.973 \n#>  6           0.788     1  0.192     0.00192                  0.489 \n#>  7           0.940     1  0.0125    0.000126                 0.830 \n#>  8           0.817     1  0.153     0.00154                  0.545 \n#>  9           0.955     1  0.00582   0.0000583                0.871 \n#> 10           0.449     1  0.116     0.00116                  0.0908\n#> # ℹ 8,990 more rows\n#> # ℹ 1 more variable: posterior_b_skewed <dbl>\n```\n:::\n\n\nv\n\n\n::: {.cell}\n\n````{.cell-code}\n```{{r}}\n#| label: hdi-normal\n\nlibrary(tidybayes)\nmode_hdi(samples_b$p_grid_b_sample, .width = .5)\nqi(samples_b$p_grid_b_sample, .width = .5)\nhdi(samples_b$p_grid_b_sample, .width = .5)\n\n```\n````\n\n```\n#>           y      ymin      ymax .width .point .interval\n#> 1 0.6508383 0.5685686 0.7597598    0.5   mode       hdi\n#>           [,1]      [,2]\n#> [1,] 0.5475475 0.7427427\n#>           [,1]      [,2]\n#> [1,] 0.5685686 0.7597598\n```\n:::\n\n::: {.cell}\n\n````{.cell-code}\n```{{r}}\n#| label: hdi-skewed\n\n# # can't reproduce\n# # Error in quantile.default(dist_y, probs = 1 - .width) :\n# # missing values and NaN's not allowed if 'na.rm' is FALSE\n# # it works with n = 9400 but not with n >= 9500.\n\nlibrary(tidybayes) \nmode_hdi(d_skewed$p_grid_b_skewed, .width = .5)\nqi(d_skewed$p_grid_b_skewed, .width = .5)\n# mode_hdi and hdi is not correct\n# hdi results in two lines instead as one line\n# hdi first value is far too low\nhdi(d_skewed$p_grid_b_skewed, .width = .5)\nrethinking::HPDI(d_skewed$p_grid_b_skewed, prob = .5)\n```\n````\n\n```\n#>   y      ymin      ymax .width .point .interval\n#> 1 1 0.6451532 0.6495047    0.5   mode       hdi\n#> 2 1 0.6830185 1.0000000    0.5   mode       hdi\n#>           [,1]      [,2]\n#> [1,] 0.7077077 0.9349349\n#>           [,1]      [,2]\n#> [1,] 0.6451532 0.6495047\n#> [2,] 0.6830185 1.0000000\n#>      |0.5      0.5| \n#> 0.8428428 1.0000000\n```\n:::\n\n::: {.cell}\n\n````{.cell-code}\n```{{r}}\n#| label: figure-3-3\n\n# left panel\np1 <-\n  d_skewed %>% \n  ggplot(aes(x = p_grid_b_skewed, y = posterior_b_skewed)) +\n  # check out our sweet `qi()` indexing\n  geom_area(data = d_skewed %>% \n              filter(p_grid_b_skewed > tidybayes::qi(d_skewed$p_grid_b_skewed, .width = .5)[1] & \n                       p_grid_b_skewed < tidybayes::qi(d_skewed$p_grid_b_skewed, .width = .5)[2]),\n            fill = \"blue\") +\n  geom_line() +\n  labs(subtitle = \"50% Percentile Interval\",\n       x = \"proportion of water (p)\",\n       y = \"density\")\np1\n\n# right panel\np2 <-\n  d_skewed %>% \n  ggplot(aes(x = p_grid_b_skewed, y = posterior_b_skewed)) +\n  geom_area(data = d_skewed %>% \n              filter(p_grid_b_skewed > rethinking::HPDI(d_skewed$p_grid_b_skewed, prob = .5)[1] & \n                       p_grid_b_skewed < rethinking::HPDI(d_skewed$p_grid_b_skewed, prob = .5)[2]),\n            fill = \"blue\") +\n  geom_line() +\n  labs(subtitle = \"50% HPDI\",\n       x = \"proportion of water (p)\",\n       y = \"density\")\np2\n\n# combine!\np1 | p2\n```\n````\n\n::: {.cell-output-display}\n![](03b-sampling-the-imaginary_files/figure-html/figure-3-3-1.png){width=672}\n:::\n\n::: {.cell-output-display}\n![](03b-sampling-the-imaginary_files/figure-html/figure-3-3-2.png){width=672}\n:::\n\n::: {.cell-output-display}\n![](03b-sampling-the-imaginary_files/figure-html/figure-3-3-3.png){width=672}\n:::\n:::\n\n\nBecause of my problems with the calculation of the HPDI I am going to\nskip the rest of this part of the chapter. This is not very problematic\nfor two reasons:\n\n1.  PI and HPDI are only very different if the distribution is very\n    skewed.\n2.  Kurz will primarily stick to the PI-based intervals.\n\n### 3.2.3b Point Estimates\n\n\n::: {.cell}\n\n````{.cell-code}\n```{{r}}\n#| label: update-d-tbl\n\n\n# here we update the `dbinom()` parameters\nn_success <- 3\nn_trials  <- 3\nn_samples <- 1e4\n\n# update `d`\nd_update <-\n  d %>% \n  mutate(likelihood = dbinom(n_success, size = n_trials, prob = p_grid_b)) %>% \n  mutate(posterior_b  = (likelihood * prior) / sum(likelihood * prior))\n\n# make the next part reproducible\nset.seed(3)\n\n# here's our new samples tibble\n(\n  samples_update <-\n    d_update %>% \n    slice_sample(n = n_samples, weight_by = posterior_b, replace = T)\n)\n```\n````\n\n```\n#> # A tibble: 10,000 × 4\n#>    p_grid_b prior likelihood posterior_b\n#>       <dbl> <dbl>      <dbl>       <dbl>\n#>  1    0.717     1     0.368     0.00147 \n#>  2    0.652     1     0.277     0.00111 \n#>  3    0.548     1     0.164     0.000656\n#>  4    1         1     1         0.00400 \n#>  5    0.991     1     0.973     0.00389 \n#>  6    0.788     1     0.489     0.00195 \n#>  7    0.940     1     0.830     0.00332 \n#>  8    0.817     1     0.545     0.00218 \n#>  9    0.955     1     0.871     0.00348 \n#> 10    0.449     1     0.0908    0.000363\n#> # ℹ 9,990 more rows\n```\n:::\n\n\n> We've been calling point estimates measures of central tendency. If we\n> `arrange()` our `d` tibble in descending order by `posterior`, we'll\n> see the corresponding `p_grid` value for its MAP estimate.\n\n\n::: {.cell}\n\n````{.cell-code}\n```{{r}}\n#| label: map-estimate-b1\nd_update %>% \n  arrange(desc(posterior_b))\n```\n````\n\n```\n#> # A tibble: 1,000 × 4\n#>    p_grid_b prior likelihood posterior_b\n#>       <dbl> <dbl>      <dbl>       <dbl>\n#>  1    1         1      1         0.00400\n#>  2    0.999     1      0.997     0.00398\n#>  3    0.998     1      0.994     0.00397\n#>  4    0.997     1      0.991     0.00396\n#>  5    0.996     1      0.988     0.00395\n#>  6    0.995     1      0.985     0.00394\n#>  7    0.994     1      0.982     0.00392\n#>  8    0.993     1      0.979     0.00391\n#>  9    0.992     1      0.976     0.00390\n#> 10    0.991     1      0.973     0.00389\n#> # ℹ 990 more rows\n```\n:::\n\n::: {.cell}\n\n````{.cell-code}\n```{{r}}\n#| label: map-estimate-b2\nd_update |>  \n  arrange(desc(posterior_b)) |> \n    slice(1)\n```\n````\n\n```\n#> # A tibble: 1 × 4\n#>   p_grid_b prior likelihood posterior_b\n#>      <dbl> <dbl>      <dbl>       <dbl>\n#> 1        1     1          1     0.00400\n```\n:::\n\n::: {.cell}\n\n````{.cell-code}\n```{{r}}\n#| label: hdi-not-working\n#| eval: false\n\n# hdi-from-tidybases not working\n# it will generate the following error message:\n# Error in quantile.default(dist_y, probs = 1 - .width) :\n# missing values and NaN's not allowed if 'na.rm' is FALSE\nsamples_update %>% mode_hdi(p_grid_b)\n```\n````\n:::\n\n::: {.cell}\n\n````{.cell-code}\n```{{r}}\n#| label: mode-mean-median\n\n# using tidybayes (but not documented!)\ntidybayes::Mode(samples_update$p_grid_b)\n\nsamples_update %>% \n  summarise(mode   = Mode(samples_update$p_grid_b),\n            mean  = mean(p_grid_b),\n            median = median(p_grid_b))\n```\n````\n\n```\n#> [1] 0.9995616\n#> # A tibble: 1 × 3\n#>    mode  mean median\n#>   <dbl> <dbl>  <dbl>\n#> 1  1.00 0.803  0.843\n```\n:::\n",
    "supporting": [
      "03b-sampling-the-imaginary_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}