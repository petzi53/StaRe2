{
  "hash": "4d084833ed25cb517303f665eebdad18",
  "result": {
    "markdown": "---\nformat: html\nexecute: \n  cache: true\n---\n\n\n# Sampling the Imaginary {#sec-chap03}\n\n\n::: my-objectives\n::: my-objectives-header\nLearning Objectives:\n:::\n\n::: my-objectives-container\nThis chapter teaches the basic skills for working with samples from the\nposterior distribution. We'll begin to use samples to summarize and\nsimulate model output. The skills learned here will apply to every\nproblem in the remainder of the book, even though the details of the\nmodels and how the samples are produced will vary.\n\nThe chapter exploits the fact that people are better in counts than in\nprobabilities. We will take the probability distributions from the\nprevious chapter and sampling from them to produce counts.\n:::\n:::\n\n## Vampire Example {.unnumbered}\n\n### ORIGINAL {.unnumbered}\n\n::: my-definition\n::: my-definition-header\n::: {#def-chap-03-1}\n: Probability Notation\n:::\n:::\n\n::: my-definition-container\nAs a repetition and to get a better understanding of the following\nformulae in this section I read a very [basic introduction into\nprobability\nnotation]((https://www.mathsisfun.com/data/probability-events-conditional.html))\n\n$P(A)$ means \"**Probability Of Event A**\".\n\n::: my-example\n::: my-example-header\nProbability of an Event\n:::\n\n::: my-example-container\nWhat is the probability of $2$ after throwing a dice?\n$$P(A) = \\frac{1}{6}$$\n:::\n:::\n\n$P(B \\mid A)$ means \"**Probability of Event B given A**\".\n\nThis is a conditional probability. After event $A$ has happened, what is\nthe probability of $B$? If the events are independent from each other\nthan the changes do not influence each other.\n\n::: my-example\n::: my-example-header\nIndependent Conditional Events\n:::\n\n::: my-example-container\nThe probability to throw $2$ in a second dice throw are still\n$P(B \\mid A) = \\frac{1}{6}$. If the events are dependent of each other\nthen \"Probability of event A and event B equals the probability of event\nA times the probability of event B given event A.\"\n\n$$\nP(A \\space and\\space B) = P(A) \\times P(B \\mid A)\n$$\n:::\n:::\n\n::: my-example\n::: my-example-header\nDependent Conditional Events\n:::\n\n::: my-example-container\nTypical example is removing marble from a bag without replacement. Let's\ntake a red marble from a bag of $5$ red and $5$ blue marbles without\nreplacement. Here the probability of a red marble (in the second draw)\ngiven the probability of a red marble (in the first draw) is\n\n$$\n\\frac{5}{10} \\times \\frac{4}{9} = \\frac{2}{9}\n$$\n:::\n:::\n:::\n:::\n\n#### a) Medical Test Scenario with Bayes theorem {.unnumbered}\n\n> \"suppose there is a blood test that correctly detects vampirism 95% of\n> the time. In more precise and mathematical notation,\n> $Pr(\\text{positive test result} \\mid vampire) = 0.95$. It's a very\n> accurate test, nearly always catching real vampires. It also make\n> mistakes, though, in the form of false positives. One percent of the\n> time, it incorrectly diagnoses normal people as vampires,\n> $Pr(\\text{positive test result}|mortal) = 0.01$. The final bit of\n> information we are told is that vampires are rather rare, being only\n> $0.1\\%$ of the population, implying $Pr(vampire) = 0.001$. Suppose now\n> that someone tests positive for vampirism. What's the probability that\n> he or she is a bloodsucking immortal?\" ([McElreath, 2020, p.\n> 49](zotero://select/groups/5243560/items/NFUEVASQ))\n> ([pdf](zotero://open-pdf/groups/5243560/items/CPFRPHX8?page=68&annotation=W9MU6VCZ))\n\n> \"The correct approach is just to use Bayes' theorem to invert the\n> probability, to compute $Pr(vampire|positive)$. The calculation can be\n> presented as:\n\n$$\n\\begin{align*}\nPr(vampire\\mid positive) = \\frac{Pr(positive\\mid vampire) Pr(vampire)}{Pr(positive)}\\\\\n\\text{where Pr(positive) is the average probability of a positive test result, that is,}\\\\ Pr(positive) = Pr(positive \\mid vampire) Pr(vampire) \\\\\n+ Pr(positive \\mid mortal) 1 − Pr(vampire)\n\\end{align*}\n$$ {#eq-vampire} \" ([McElreath, 2020, p.\n49](zotero://select/groups/5243560/items/NFUEVASQ))\n([pdf](zotero://open-pdf/groups/5243560/items/CPFRPHX8?page=68&annotation=X4KD33AT))\n\n::: my-r-code\n::: my-r-code-header\n::: {#cnj-vampire-bayes-a}\na: Performing vampire calculation with <a class='glossary' title='This is the theorem that gives Bayesian data analysis its name. But the theorem itself is a trivial implication of probability theory. The mathematical definition of the posterior distribution arises from Bayes’ Theorem. The key lesson is that the posterior is proportional to the product of the prior and the probability of the data. (Chap.2)'>Bayes’ theorem</a> in\nBase R\n:::\n:::\n\n::: my-r-code-container\n\n::: {.cell hash='03-sampling-the-imaginary_cache/html/vampire-bayes-a_e78cb07b12eb859739d60464ecdf29b9'}\n\n```{.r .cell-code}\n## R code 3.1a Vampire ##################\npr_positive_vampire_a <- 0.95\npr_positive_mortal_a <- 0.01\npr_vampire_a <- 0.001\npr_positive_a <- pr_positive_vampire_a * pr_vampire_a +\n  pr_positive_mortal_a * (1 - pr_vampire_a)\n\n( \n  pr_vampire_positive_a <- pr_positive_vampire_a * pr_vampire_a / pr_positive_a\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 0.08683729\n```\n\n\n:::\n:::\n\n:::\n:::\n\nThere is only an 0.0868373% chance that the suspect is\nactually a vampire.\n\n> \"Most people find this result counterintuitive. And it's a very\n> important result, because it mimics the structure of many realistic\n> testing contexts, such as HIV and DNA testing, criminal profiling, and\n> even statistical significance testing (see the Rethinking box at the\n> end of this section). Whenever the condition of interest is very rare,\n> having a test that finds all the true cases is still no guarantee that\n> a positive result carries much information at all. The reason is that\n> most positive results are false positives, even when all the true\n> positives are detected correctly\" ([McElreath, 2020, p.\n> 49](zotero://select/groups/5243560/items/NFUEVASQ))\n> ([pdf](zotero://open-pdf/groups/5243560/items/CPFRPHX8?page=68&annotation=CMMR49PQ))\n\n#### b) Medical test scenario with natural frequencies {.unnumbered}\n\n> \"There is a way to present the same problem that does make it more\n> intuitive\" ([McElreath, 2020, p.\n> 50](zotero://select/groups/5243560/items/NFUEVASQ))\n> ([pdf](zotero://open-pdf/groups/5243560/items/CPFRPHX8?page=69&annotation=2DWF7729))\n\n```         \n(1)  In a population of 100,000 people, 100 of them are vampires.\n(2)  Of the 100 who are vampires, 95 of them will test positive for vampirism.\n(3)  Of the 99,900 mortals, 999 of them will test positive for vampirism.\n```\n\nThere are 999 + 95 = 1094 people tested positive. But from these\npeople only 95 / (999 + 95) = 8.6837294 % are actually\nvampires.\n\nOr with a slightly different wording it is still easier to understand:\n\n1.  We can just count up the number of people who test positive:\n    $95 + 999 = 1094$.\n2.  Out of these $1094$ positive tests, $95$ of them are real vampires,\n    so that implies:\n\n$$\nPr(positive \\mid vampire) = \\frac{95}{1094}\n$$\n\n::: my-r-code\n::: my-r-code-header\n::: {#cnj-vampire-frequencies-a}\na: Performing vampire calculation with frequencies in Base R\n:::\n:::\n\n::: my-r-code-container\n\n::: {.cell hash='03-sampling-the-imaginary_cache/html/vampire-frequencies-a_077f85fa03a7b9232d043d649a18af36'}\n\n```{.r .cell-code}\npr_vampire_a2 <-  100 / 100000\npr_positive_vampire_a2 <-  95 / 100\npr_positive_mortal_a2  <-  999 / 99900\npr_positive_a2 <-  95 + 999\n\n(\n  pr_vampire_positive_a2 <-  \n    pr_positive_vampire_a2 * 100 / pr_positive_a2\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 0.08683729\n```\n\n\n:::\n:::\n\n:::\n:::\n\n> \"The second presentation of the problem, using counts rather than\n> probabilities, is often called the frequency format or natural\n> frequencies. Why a frequency format helps people intuit the correct\n> approach remains contentious. Some people think that human psychology\n> naturally works better when it receives information in the form a\n> person in a natural environment would receive it. In the real world,\n> we encounter counts only. No one has ever seen a probability, the\n> thinking goes. But everyone sees counts (\"frequencies\") in their daily\n> lives.\" ([McElreath, 2020, p.\n> 50](zotero://select/groups/5243560/items/NFUEVASQ))\n> ([pdf](zotero://open-pdf/groups/5243560/items/CPFRPHX8?page=69&annotation=G26ZTDUZ))\n\n> \"many scientists are uncomfortable with integral calculus, even though\n> they have strong and valid intuitions about how to summarize data.\n> Working with samples transforms a problem in calculus into a problem\n> in data summary, into a frequency format problem. An integral in a\n> typical Bayesian context is just the total probability in some\n> interval. That can be a challenging calculus problem. But once you\n> have samples from the probability distribution, it's just a matter of\n> counting values in the interval. An empirical attack on the posterior\n> allows the scientist to ask and answer more questions about the model,\n> without relying upon a captive mathematician. For this reason, it is\n> easier and more intuitive to work with samples from the posterior,\n> than to work with probabilities and integrals directly.\" ([McElreath,\n> 2020, p. 51](zotero://select/groups/5243560/items/NFUEVASQ))\n> ([pdf](zotero://open-pdf/groups/5243560/items/CPFRPHX8?page=70&annotation=M7I2DV3C))\n\n### TIDYVERSE {.unnumbered}\n\n#### a) Medical Test Scenario with Bayes theorem {.unnumbered}\n\n::: my-important\n::: my-important-header\nVectors in Base R are tibble columns in tidyverse\n:::\n\n::: my-important-container\nWhenever there is a calculation with vectors the pendant in tidyverse\nmode is to generate columns in a tibble with `tibble::tibble()` or if\nthere is already a data frame with `dplyr::mutate()` and to do the\nappropriate calculation with these columns.\n\nThe following @cnj-vampire-bayes-a transformed the Base R calculation\n@cnj-vampire-bayes-b into a computation using the tidyverse approach.\n:::\n:::\n\n::: my-r-code\n::: my-r-code-header\n::: {#cnj-vampire-bayes-b}\nb: Performing the calculation using Bayes' theorem with tidyverse\napproach in R\n:::\n:::\n\n::: my-r-code-container\n\n::: {.cell hash='03-sampling-the-imaginary_cache/html/vampire-bayes-b_38ad763c3220dc9abaea623ddf42c66c'}\n\n```{.r .cell-code}\n## R code 3.1b Vampire ##########\n\ntibble::tibble(pr_positive_vampire_b = .95,\n       pr_positive_mortal_b  = .01,\n       pr_vampire_b          = .001) |> \n  dplyr::mutate(pr_positive_b = pr_positive_vampire_b * pr_vampire_b\n         + pr_positive_mortal_b * (1 - pr_vampire_b)) |> \n  dplyr::mutate(pr_vampire_positive_b = \n           pr_positive_vampire_b * pr_vampire_b / pr_positive_b) |> \n  dplyr::glimpse()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> Rows: 1\n#> Columns: 5\n#> $ pr_positive_vampire_b <dbl> 0.95\n#> $ pr_positive_mortal_b  <dbl> 0.01\n#> $ pr_vampire_b          <dbl> 0.001\n#> $ pr_positive_b         <dbl> 0.01094\n#> $ pr_vampire_positive_b <dbl> 0.08683729\n```\n\n\n:::\n:::\n\n:::\n:::\n\n#### b) Medical test scenario with natural frequencies {.unnumbered}\n\n::: my-r-code\n::: my-r-code-header\n::: {#cnj-vampire-frequencies-b}\nb: Performing the calculation using frequencies with tidyverse approach\nin R\n:::\n:::\n\n::: my-r-code-container\n\n::: {.cell hash='03-sampling-the-imaginary_cache/html/vampire-frequencies-b_3af6a8ccab79d23238af0d9fbba9b902'}\n\n```{.r .cell-code}\ntibble::tibble(pr_vampire_b2          = 100 / 100000,\n       pr_positive_vampire_b2 = 95 / 100,\n       pr_positive_mortal_b2  = 999 / 99900)  |>  \n  dplyr::mutate(pr_positive_b2 = 95 + 999) |> \n  dplyr::mutate(pr_vampire_positive_b2 = \n                  pr_positive_vampire_b2 * 100 / pr_positive_b2) |> \n  dplyr::glimpse()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> Rows: 1\n#> Columns: 5\n#> $ pr_vampire_b2          <dbl> 0.001\n#> $ pr_positive_vampire_b2 <dbl> 0.95\n#> $ pr_positive_mortal_b2  <dbl> 0.01\n#> $ pr_positive_b2         <dbl> 1094\n#> $ pr_vampire_positive_b2 <dbl> 0.08683729\n```\n\n\n:::\n:::\n\n:::\n:::\n\n## Sampling from a grid-approximate posterior {#sec-chap03-sampling-grid}\n\n### ORIGINAL\n\nBefore we are going to draw samples from the posterior distribution we\nneed to compute the distribution similar as we had done in the globe\ntossing example.\n\n> \"Here's a reminder for how to compute the posterior for the globe\n> tossing model, using grid approximation. Remember, the posterior here\n> means the probability of p conditional on the data.\" ([McElreath,\n> 2020, p. 52](zotero://select/groups/5243560/items/NFUEVASQ))\n> ([pdf](zotero://open-pdf/groups/5243560/items/CPFRPHX8?page=71&annotation=KKQLR3FL))\n\n::: my-r-code\n::: my-r-code-header\n::: {#cnj-grid-globe-tossing-a}\na: Generate the posterior distribution for the globe-tossing example\n(Original)\n:::\n:::\n\n::: my-r-code-container\n\n::: {.cell hash='03-sampling-the-imaginary_cache/html/grid-globe-tossing-a_8d5503f9b16f241aa18f6304644fac9e'}\n\n```{.r .cell-code}\n### R code 3.2a Grid Globe ##########################\n# change prob_b to prior\n# change prob_data to likelihood\n# added variables: n_grid_a, n_success_a, n_trials_a\n\nn_grid_a <- 1000L # number of grid points\nn_success_a <- 6L # observed water\nn_trials_a <-  9L # number of trials\n\n\np_grid_a <- seq(from = 0, to = 1, length.out = n_grid_a)\nprior_a <- rep(1, n_grid_a) # = prior, = uniform distribution, 1000 times 1\nlikelihood_a <- \n  dbinom(n_success_a, size = n_trials_a, prob = p_grid_a) # = likelihood\nposterior_a <- likelihood_a * prior_a\nposterior_a <- posterior_a / sum(posterior_a)\n```\n:::\n\n:::\n:::\n\n> \"Now we wish to draw 10,000 samples from this posterior. Imagine the\n> posterior is a bucket full of parameter values, numbers such as\n> $0.1, 0.7, 0.5, 1,$ etc. Within the bucket, each value exists in\n> proportion to its posterior probability, such that values near the\n> peak are much more common than those in the tails. We're going to\n> scoop out 10,000 values from the bucket. Provided the bucket is well\n> mixed, the resulting samples will have the same proportions as the\n> exact posterior density. Therefore the individual values of $p$ will\n> appear in our samples in proportion to the posterior plausibility of\n> each value.\" ([McElreath, 2020, p.\n> 52](zotero://select/groups/5243560/items/NFUEVASQ))\n> ([pdf](zotero://open-pdf/groups/5243560/items/CPFRPHX8?page=71&annotation=GS5GCASA))\n\n::: my-r-code\n::: my-r-code-header\n::: {#cnj-chap03-sample-posterior-globe-tossing}\na: Draw 1000 samples from the posterior distribution (Original)\n:::\n:::\n\n::: my-r-code-container\n\n::: {.cell hash='03-sampling-the-imaginary_cache/html/sample-globe-tossing-a_64e758147cfeecb38abd575bc4e591dc'}\n\n```{.r .cell-code}\nn_samples_a <- 1e4\n\nbase::set.seed(3) # for reproducibility\n\n## R code 3.3a Sample Globe ##########################################\nsamples_a <- sample(p_grid_a, \n                    prob = posterior_a, # from previous code chunk\n                    size = n_samples_a, replace = TRUE)\n```\n:::\n\n:::\n:::\n\nThe probability of each value is given by `posterior_a`, which we\ncomputed with @cnj-grid-globe-tossing-a.\n\n::: my-note\n::: my-note-header\n::: {#cor-excursion-a}\n: Details for a better understanding and comparison with the tidyverse\nversion\n:::\n:::\n\n::: my-note-container\nTo compare with the tidyverse version, I collected the three vectors\nwith `base::cbind()` into a matrix and displayed the first six lines\nwith `utils::head()`. Additionally I also displayed the first 10 values\nof `samples_a` vector.\n\n::: my-r-code\n::: my-r-code-header\n::: {#cnj-excursion-a}\na: Excursion for better comparison (Base R)\n:::\n:::\n\n::: my-r-code-container\n\n::: {.cell hash='03-sampling-the-imaginary_cache/html/excursion_a_6bcbd9775ad385a9b88bc2762c3ca8f0'}\n\n```{.r .cell-code}\n# display grid results to compare with variant b\nd_a <- cbind(p_grid_a, prior_a, likelihood_a, posterior_a) \nhead(d_a, 10)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>          p_grid_a prior_a likelihood_a  posterior_a\n#>  [1,] 0.000000000       1 0.000000e+00 0.000000e+00\n#>  [2,] 0.001001001       1 8.425225e-17 8.433659e-19\n#>  [3,] 0.002002002       1 5.375951e-15 5.381333e-17\n#>  [4,] 0.003003003       1 6.105137e-14 6.111249e-16\n#>  [5,] 0.004004004       1 3.419945e-13 3.423368e-15\n#>  [6,] 0.005005005       1 1.300676e-12 1.301978e-14\n#>  [7,] 0.006006006       1 3.872087e-12 3.875963e-14\n#>  [8,] 0.007007007       1 9.734489e-12 9.744233e-14\n#>  [9,] 0.008008008       1 2.162473e-11 2.164638e-13\n#> [10,] 0.009009009       1 4.370695e-11 4.375070e-13\n```\n\n\n:::\n\n```{.r .cell-code}\n# display sample results to compare with variant b\nhead(samples_a, 10)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>  [1] 0.5645646 0.6516517 0.5475475 0.5905906 0.5955956 0.7877878 0.7267267\n#>  [8] 0.4914915 0.7507508 0.4494494\n```\n\n\n:::\n:::\n\n:::\n:::\n:::\n:::\n\n::: my-r-code\n::: my-r-code-header\n::: {#cnj-globe-glossing-scatterplot-a}\na: Scatterplot of the drawn samples (Base R)\n:::\n:::\n\n::: my-r-code-container\n\n::: {.cell hash='03-sampling-the-imaginary_cache/html/fig-globe-tossing-scatterplot-a_ef2e6612a39527c5676d3efd727180de'}\n\n```{.r .cell-code}\n## R code 3.4a Globe Scatterplot #############\nplot(samples_a)\n```\n\n::: {.cell-output-display}\n![Scatterplot of the drawn samples (Base R)](03-sampling-the-imaginary_files/figure-html/fig-globe-tossing-scatterplot-a-1.png){#fig-globe-tossing-scatterplot-a width=672}\n:::\n:::\n\n:::\n:::\n\n> In fig-globe-glossing-plot-a \"it's as if you are flying over the\n> posterior distribution, looking down on it. There are many more\n> samples from the dense region near 0.6 and very few samples below\n> 0.25. On the right, the plot shows the density estimate computed from\n> these samples.\" ([McElreath, 2020, p.\n> 53](zotero://select/groups/5243560/items/NFUEVASQ))\n> ([pdf](zotero://open-pdf/groups/5243560/items/CPFRPHX8?page=72&annotation=4WVLNZBT))\n\n::: my-r-code\n::: my-r-code-header\n::: {#cnj-globe-tossing-density-plot-a}\na: Density estimate of the drawn samples (Rethinking)\n:::\n:::\n\n::: my-r-code-container\n\n::: {.cell hash='03-sampling-the-imaginary_cache/html/fig-globe-tossing-density-plot-a_d3498b1f608a4f243f88f768ac48d285'}\n\n```{.r .cell-code}\n## R code 3.5a Globe Density plot #############\nrethinking::dens(samples_a)\n```\n\n::: {.cell-output-display}\n![Density estimate of the drawn samples (Rethinking)](03-sampling-the-imaginary_files/figure-html/fig-globe-tossing-density-plot-a-1.png){#fig-globe-tossing-density-plot-a width=672}\n:::\n:::\n\n:::\n:::\n\n### TIDYVERSE\n\n::: my-r-code\n::: my-r-code-header\n::: {#cnj-grid-globe-tossing-b}\nb: Generate the posterior distribution form the globe-tossing example\n(Tidyverse)\n:::\n:::\n\n::: my-r-code-container\n\n::: {.cell hash='03-sampling-the-imaginary_cache/html/grid-globe-tossing-b_39b7f1360506fc533b0fd3665c87d50b'}\n\n```{.r .cell-code}\n## R code 3.2b Grid Globe #####################\n\n# how many grid points would you like?\nn_grid_b <- 1000L\nn_success_b <- 6L\nn_trials_b  <- 9L\n\nd_b <-\n  tibble::tibble(p_grid_b = seq(from = 0, to = 1, length.out = n_grid_b),\n         prior_b  = 1) |>  # flat uniform prior, vector 1L recycling\n  dplyr::mutate(likelihood_b = \n                  stats::dbinom(n_success_b, size = n_trials_b, prob = p_grid_b)) |> \n  dplyr::mutate(posterior_b = \n                  (likelihood_b * prior_b) / sum(likelihood_b * prior_b))\n\nhead(d_b)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> # A tibble: 6 × 4\n#>   p_grid_b prior_b likelihood_b posterior_b\n#>      <dbl>   <dbl>        <dbl>       <dbl>\n#> 1  0             1     0           0       \n#> 2  0.00100       1     8.43e-17    8.43e-19\n#> 3  0.00200       1     5.38e-15    5.38e-17\n#> 4  0.00300       1     6.11e-14    6.11e-16\n#> 5  0.00400       1     3.42e-13    3.42e-15\n#> 6  0.00501       1     1.30e-12    1.30e-14\n```\n\n\n:::\n:::\n\n:::\n:::\n\n::: my-watch-out\n::: my-watch-out-header\nVariable names changed\n:::\n\n::: my-watch-out-container\nI have changed McElreath's variable name `prob_p` and `prob_data` as\n`prior_x` and `likelihood_x`, where `x` stands for `a` (Base R) or `b`\n(Tidyverse).\n\nTo see the difference between grid and samples I will add \"\\_sample\" to\nall the other variable names.\n:::\n:::\n\n::: my-r-code\n::: my-r-code-header\n::: {#cnj-sample-globe-tossing-b}\nb: Draw 1000 samples from the posterior distribution (Tidyverse)\n:::\n:::\n\n::: my-r-code-container\n\n::: {.cell hash='03-sampling-the-imaginary_cache/html/sample-globe-tossing-b_704e34271f9d9fb89611d35fde18215d'}\n\n```{.r .cell-code}\n## R code 3.3b Sample Globe #####################\n# how many samples would you like?\nn_samples_b <- 1e4\n\n# make it reproducible\nbase::set.seed(3)\n\ndf_samples_b <-\n  d_b |> \n    dplyr::slice_sample(n = n_samples_b, weight_by = posterior_b, replace = T)\n\ndf_samples_b <- df_samples_b |>\n    dplyr::rename(samples_b = p_grid_b,\n           likelihood_samples_b = likelihood_b,\n           prior_samples_b = prior_b,\n           posterior_samples_b = posterior_b)\nhead(df_samples_b)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> # A tibble: 6 × 4\n#>   samples_b prior_samples_b likelihood_samples_b posterior_samples_b\n#>       <dbl>           <dbl>                <dbl>               <dbl>\n#> 1     0.565               1                0.225             0.00225\n#> 2     0.652               1                0.272             0.00272\n#> 3     0.548               1                0.210             0.00210\n#> 4     0.591               1                0.245             0.00245\n#> 5     0.596               1                0.248             0.00248\n#> 6     0.788               1                0.192             0.00192\n```\n\n\n:::\n:::\n\n\n***\n\n`identical(samples_a, df_samples_b$samples_b)` = TRUE.\n\nThe column `samples_b` is identical with vector `samples_a`, because I\nhave used in both sampling processes `base::set.seed(3)`, so that I (and\nyou) could reproduce the data.\n\n:::\n:::\n\n\n\nThere are different possibilities to display data frames respectively\ntibbles:\n\n1.  You can use the internal print facility of tibbles. It shows only\n    the first ten rows and all columns that fit on the screen. You see\n    an example in @cnj-sample-globe-tossing-b.\n2.  With the `utils::str()` function you will get a result with shorter\n    figures that is better adapted to a small screen.\n3.  Another alternative is the tidyverse approach of `dplyr::glimpse()`.\n4.  With `skimr::skim()` you will get a compact summary of all data.\n\n::: my-r-code\n::: my-r-code-header\n::: {#cnj-excursion-b}\nb: Excursion: Printing varieties for better comparison (Tidyverse)\n:::\n:::\n\n::: my-r-code-container\n\n::: {.cell hash='03-sampling-the-imaginary_cache/html/excursion-b_c4556d558095a87c7961f0c2f4bfc8f3'}\n\n```{.r .cell-code}\nglue::glue('USING THE str() FUNCTION:')\nutils::str(df_samples_b)\nglue::glue('#####################################################\\n\\n')\nglue::glue('USING THE dplyr::glimpse() FUNCTION:')\ndplyr::glimpse(df_samples_b)\nglue::glue('#####################################################\\n\\n')\nglue::glue('USING THE skimr::skim() FUNCTION:')\nskimr::skim(df_samples_b)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> USING THE str() FUNCTION:\n#> tibble [10,000 × 4] (S3: tbl_df/tbl/data.frame)\n#>  $ samples_b           : num [1:10000] 0.565 0.652 0.548 0.591 0.596 ...\n#>  $ prior_samples_b     : num [1:10000] 1 1 1 1 1 1 1 1 1 1 ...\n#>  $ likelihood_samples_b: num [1:10000] 0.225 0.272 0.21 0.245 0.248 ...\n#>  $ posterior_samples_b : num [1:10000] 0.00225 0.00272 0.0021 0.00245 0.00248 ...\n#> #####################################################\n#> \n#> USING THE dplyr::glimpse() FUNCTION:\n#> Rows: 10,000\n#> Columns: 4\n#> $ samples_b            <dbl> 0.5645646, 0.6516517, 0.5475475, 0.5905906, 0.595…\n#> $ prior_samples_b      <dbl> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1…\n#> $ likelihood_samples_b <dbl> 0.22455994, 0.27190272, 0.20966655, 0.24460869, 0…\n#> $ posterior_samples_b  <dbl> 0.0022478473, 0.0027217490, 0.0020987643, 0.00244…\n#> #####################################################\n#> \n#> USING THE skimr::skim() FUNCTION:\n```\n\n\n:::\n\n::: {.cell-output-display}\n\nTable: Data summary\n\n|                         |             |\n|:------------------------|:------------|\n|Name                     |df_samples_b |\n|Number of rows           |10000        |\n|Number of columns        |4            |\n|_______________________  |             |\n|Column type frequency:   |             |\n|numeric                  |4            |\n|________________________ |             |\n|Group variables          |None         |\n\n\n**Variable type: numeric**\n\n|skim_variable        | n_missing| complete_rate| mean|   sd|   p0|  p25|  p50|  p75| p100|hist  |\n|:--------------------|---------:|-------------:|----:|----:|----:|----:|----:|----:|----:|:-----|\n|samples_b            |         0|             1| 0.64| 0.14| 0.15| 0.55| 0.65| 0.74| 0.97|▁▂▇▇▂ |\n|prior_samples_b      |         0|             1| 1.00| 0.00| 1.00| 1.00| 1.00| 1.00| 1.00|▁▁▇▁▁ |\n|likelihood_samples_b |         0|             1| 0.20| 0.07| 0.00| 0.16| 0.23| 0.26| 0.27|▁▁▂▃▇ |\n|posterior_samples_b  |         0|             1| 0.00| 0.00| 0.00| 0.00| 0.00| 0.00| 0.00|▁▁▂▃▇ |\n\n\n:::\n:::\n\n:::\n:::\n\nWe can plot the left panel of Figure 3.1 from the book with\n`ggplot2::geom_point()`. But before we do, we'll need to add a variable\nnumbering the samples. This is necessary as the x-parameter of the plot.\n\n::: my-r-code\n::: my-r-code-header\n::: {#cnj-globe-tossing-scatterplot-b}\nb: Scatterplot of the drawn samples (Tidyverse)\n:::\n:::\n\n::: my-r-code-container\n\n::: {.cell hash='03-sampling-the-imaginary_cache/html/fig-globe-tossing-scatterplot-b_d0d6f923a809b65a07aec13aa6709641'}\n\n```{.r .cell-code}\n## R code 3.4b Globe Scatterplot ########################\ndf_samples_b |> \n  dplyr::mutate(sample_number = 1:dplyr::n()) |> \n  \n  ggplot2::ggplot(ggplot2::aes(x = sample_number, y = samples_b)) +\n  ggplot2::geom_point(alpha = 1/10) +\n  ggplot2::scale_y_continuous(\"proportion of water (p)\", limits = c(0, 1)) +\n  ggplot2::xlab(\"sample number\") +\n  ggplot2::theme_bw()\n```\n\n::: {.cell-output-display}\n![Scatterplot of the drawn samples (Tidyverse)](03-sampling-the-imaginary_files/figure-html/fig-globe-tossing-scatterplot-b-1.png){#fig-globe-tossing-scatterplot-b width=672}\n:::\n:::\n\n:::\n:::\n\nIf you hover over this link from @fig-globe-tossing-scatterplot-a you\ncan compare the Base R version with the tidyverse result.\n\nInstead of the `rethinking::dens()` we'll plot the density in the right\npanel of the books Figure 3.1 with `ggplot2::geom_density()`.\n\n::: my-r-code\n::: my-r-code-header\n::: {#cnj-globe-tossing-densitiy-plot-b1}\nb: Density estimate of the drawn samples with 1e4 grid points\n(Tidyverse)\n:::\n:::\n\n::: my-r-code-container\n\n::: {.cell hash='03-sampling-the-imaginary_cache/html/fig-globe-tossing-density-plot-b1_4494bfccdfee58dfff83bc53c4e8a164'}\n\n```{.r .cell-code}\n## R code 3.5b(1) Globe Density ###########################\ndf_samples_b |> \n  ggplot2::ggplot(ggplot2::aes(x = samples_b)) +\n  ggplot2::geom_density(fill = \"grey\") +\n  ggplot2::scale_x_continuous(\"proportion of water (p)\", limits = c(0, 1)) +\n  ggplot2::theme_bw()\n```\n\n::: {.cell-output-display}\n![Density estimate of the drawn samples with 1e4 grid points (Tidyverse)](03-sampling-the-imaginary_files/figure-html/fig-globe-tossing-density-plot-b1-1.png){#fig-globe-tossing-density-plot-b1 width=672}\n:::\n:::\n\n:::\n:::\n\nCompare this somewhat smoother tidyverse plot with\n@fig-globe-tossing-density-plot-a.\n\n> \"You can see that the estimated density is very similar to ideal\n> posterior you computed via grid approximation. If you draw even more\n> samples, maybe 1e5 or 1e6, the density estimate will get more and more\n> similar to the ideal.\" ([McElreath, 2020, p.\n> 53](zotero://select/groups/5243560/items/NFUEVASQ))\n> ([pdf](zotero://open-pdf/groups/5243560/items/CPFRPHX8?page=72&annotation=EXBQWX2M))\n\nHere's what it looks like with `1e6`.\n\n::: my-r-code\n::: my-r-code-header\n::: {#cnj-ID-text}\nb: Density estimate of the drawn samples with 1e6 grid points\n(Tidyverse)\n:::\n:::\n\n::: my-r-code-container\n\n::: {.cell hash='03-sampling-the-imaginary_cache/html/fig-globe-tossing-density-plot-b2_5bf5f393a85eb07d7f72b5cc8526f944'}\n\n```{.r .cell-code}\nbase::set.seed(3)\n\n## R code 3.5b(2) Globe Density ###########################\nd_b |> \n  dplyr::slice_sample(n = 1e6, weight_by = posterior_b, replace = T) |>\n  \n  ggplot2::ggplot(ggplot2::aes(x = p_grid_b)) +\n  ggplot2::geom_density(fill = \"grey\") +\n  ggplot2::scale_x_continuous(\"proportion of water (p)\", limits = c(0, 1)) +\n  ggplot2::theme_bw()\n```\n\n::: {.cell-output-display}\n![Density estimate of the drawn samples with 1e6 grid points (Tidyverse)](03-sampling-the-imaginary_files/figure-html/fig-globe-tossing-density-plot-b2-1.png){#fig-globe-tossing-density-plot-b2 width=672}\n:::\n:::\n\n:::\n:::\n\n## Sampling to Summarize {#sec-chap03-sampling-to-summarize}\n\nAll we have done so far is crudely replicate the posterior density we\nhad already computed in the previous chapter. Now it is time to use\nthese samples to describe and understand the posterior.\n\nThe description to understand the posterior can be divided into three\ninquiries:\n\n1.  Questions about intervals of *defined boundaries*. See @sec-chap-03-defined-boundaries.\n2.  Questions about intervals of *defined probability mass*. See @sec-chap-03-probability-mass.\n3.  Questions about *point estimates*. See: @sec-chap-03-point-estimates.\n\n### Intervals of Defined Boundaries {#sec-chap-03-defined-boundaries}\n\n#### ORIGINAL\n\n##### Grid-approximate Posterior\n\nFor instance: What is the probability that the proportion of water is\nless than 0.5?\n\n> \"Using the grid-approximate posterior, you can just add up all of the\n> probabilities, where the corresponding parameter value is less than\n> 0.5:\" ([McElreath, 2020, p.\n> 53](zotero://select/groups/5243560/items/NFUEVASQ))\n> ([pdf](zotero://open-pdf/groups/5243560/items/CPFRPHX8?page=72&annotation=Z7XSZ6WT))\n\n::: my-r-code\n::: my-r-code-header\n::: {#cnj-grid-posterior-a}\na: Define boundaries using the grid-approximate posterior (Base R)\n:::\n:::\n\n::: my-r-code-container\n\n::: {.cell hash='03-sampling-the-imaginary_cache/html/grid-posterior-a_2235e2be878cff741f4df70708ad100c'}\n\n```{.r .cell-code}\n## R code 3.6a Grid Posterior Boundary ##############################\n# add up posterior probability where p < 0.5\nsum(posterior_a[p_grid_a < 0.5])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 0.1718746\n```\n\n\n:::\n:::\n\n:::\n:::\n\nAbout 17% of the posterior probability is below 0.5.\n\n##### Samples from the Posterior {#sec-chap03-samples-from-posterior}\n\nBut this easy calculation based on grid approximation is often not\npractical when there are more parameters. In this case you can draw\nsamples from the posterior. But this approach requires a different\ncalculation:\n\n> \"This approach does generalize to complex models with many parameters,\n> and so you can use it everywhere. All you have to do is similarly add\n> up all of the samples below 0.5, but also // divide the resulting\n> count by the total number of samples. In other words, find the\n> frequency of parameter values below 0.5\" (McElreath, 2020, p. 53/54)\"\n> ([McElreath, 2020, p.\n> 53](zotero://select/groups/5243560/items/NFUEVASQ))\n> ([pdf](zotero://open-pdf/groups/5243560/items/CPFRPHX8?page=72&annotation=SMQ6B78K))\n\n::: my-r-code\n::: my-r-code-header\n::: {#cnj-sample-boundary-a}\na: Compute posterior probability below 0.5 using the sampling approach\n(Base R)\n:::\n:::\n\n::: my-r-code-container\n\n::: {.cell hash='03-sampling-the-imaginary_cache/html/sample-boundary-a_ac5e358f12ca53c7b0c76fcded2b5129'}\n\n```{.r .cell-code}\n## R code 3.7a Sample Boundary #############################\n(p_boundary_a <- sum(samples_a < 0.5) / 1e4)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 0.1629\n```\n\n\n:::\n:::\n\n:::\n:::\n\n::: my-watch-out\n::: my-watch-out-header\nDifferent values with samples from the posterior\n:::\n\n::: my-watch-out-container\nIn comparison with the value of the posterior probability below 0.5 in\nthe book of 0.1726 the result in 0.1629 from\n@cnj-sample-boundary-a is quite different.\n\nThe reason for the difference is that you can't get the same values in a\nsampling processes. This is the nature of randomness. And McElreath did\nnot include the `base::set.seed()` function for (exact) reproducibility.\n:::\n:::\n\nUsing the same approach, you can ask how much posterior probability lies\nbetween 0.5 and 0.75:\n\n::: my-r-code\n::: my-r-code-header\n::: {#cnj-sample-interval-a}\na: Compute posterior probability between 0.5 and 0.75 using the sampling\napproach (Base R)\n:::\n:::\n\n::: my-r-code-container\n\n::: {.cell hash='03-sampling-the-imaginary_cache/html/sample-interval-a_68054e287a571bbc5efb53baf15a9dd3'}\n\n```{.r .cell-code}\n## R code 3.8a Sample Interval #############################\n(p_boundary_a8 <- sum(samples_a > 0.5 & samples_a < 0.75) / 1e4)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 0.6061\n```\n\n\n:::\n:::\n\n:::\n:::\n\n#### TIDYVERSE\n\n##### Grid-approximate Posterior\n\n> To get the proportion of water less than some value of `p_grid_b`\n> within the {**tidyverse}**, you might first `filter()` by that value\n> and then take the `sum()` within `summarise()`.\n> ([Kurz](https://bookdown.org/content/4857/sampling-the-imaginary.html#intervals-of-defined-boundaries.))\n\n::: my-r-code\n::: my-r-code-header\n::: {#cnj-grid-boundary-b}\nb: Compute posterior probability below 0.5 using the grid approach\n(Tidyverse)\n:::\n:::\n\n::: my-r-code-container\n\n::: {.cell hash='03-sampling-the-imaginary_cache/html/grid-boundary-b_cf905dee69da77b4bd5d5f1648a75a72'}\n\n```{.r .cell-code}\n## R code 3.6b Grid Boundary ######################\n# add up posterior probability where p < 0.5\nd_b |> dplyr::filter(p_grid_b < 0.5) |> \n    dplyr::summarize(sum = base::sum(posterior_b))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> # A tibble: 1 × 1\n#>     sum\n#>   <dbl>\n#> 1 0.172\n```\n\n\n:::\n:::\n\n:::\n:::\n\n##### Samples from the Posterior\n\nKurz offers several methods to calculate the posterior probability below\n0.5:\n\n1.  **Method**: `filter()` & `n()` within `summarize()`\n2.  **Method**: `count()` followed by `mutate()`\n3.  **Method**: Logical condition within `mean()`\n\n::: my-r-code\n::: my-r-code-header\n::: {#cnj-sample-boundary}\nb: Compute posterior probability below 0.5 using the sampling approach\nwith different methods (Tidyverse)\n:::\n:::\n\n::: my-r-code-container\n\n::: {.cell hash='03-sampling-the-imaginary_cache/html/sample-boundary-b_80f4fe6a73350bb98988edcee0cf6262'}\n\n```{.r .cell-code}\n# add up all posterior probabilities of samples under .5\n## R code 3.7b Sample Boundary #########################\n\n###### Method (1) #######\nmethod_1 <- \n  df_samples_b |> \n      dplyr::filter(samples_b < .5) |> \n      dplyr::summarize(sum = dplyr::n() / n_samples_b)\n\nglue::glue('Method 1:\\n')\nmethod_1\nglue::glue('##################################################\\n\\n')\n\n###### Method (2) #######\nmethod_2 <- \n  df_samples_b |> \n    dplyr::count(samples_b < .5) |> \n    dplyr::mutate(probability = n_samples_b / base::sum(n_samples_b))\n\nglue::glue('Method 2:\\n')\nmethod_2\nglue::glue('##################################################\\n\\n')\n\n###### Method (3) #######\nmethod_3 <- \n  df_samples_b |> \n      dplyr::summarize(sum = mean(samples_b < .5))\n\nglue::glue('Method 3:\\n')\nmethod_3\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> Method 1:\n#> # A tibble: 1 × 1\n#>     sum\n#>   <dbl>\n#> 1 0.163\n#> ##################################################\n#> \n#> Method 2:\n#> # A tibble: 2 × 3\n#>   `samples_b < 0.5`     n probability\n#>   <lgl>             <int>       <dbl>\n#> 1 FALSE              8371           1\n#> 2 TRUE               1629           1\n#> ##################################################\n#> \n#> Method 3:\n#> # A tibble: 1 × 1\n#>     sum\n#>   <dbl>\n#> 1 0.163\n```\n\n\n:::\n:::\n\n:::\n:::\n\nTo determine the posterior probability between 0.5 and 0.75, you can use\n`&` within `filter()`. Just multiply that result by 100 to get the value\nin percent.\n\n::: my-r-code\n::: my-r-code-header\n::: {#cnj-sample-interval-b}\nb: Compute posterior probability between 0.5 and 0.75 using the sampling\napproach (Tidyverse)\n:::\n:::\n\n::: my-r-code-container\n\n::: {.cell hash='03-sampling-the-imaginary_cache/html/sample-interval-b_0e773a5896b0c5798679813e8b94b37c'}\n\n```{.r .cell-code}\n## R code 3.8b Sample Interval ##############\ndf_samples_b |> \n    dplyr::filter(samples_b > .5 & samples_b < .75) |> \n    dplyr::summarize(sum = dplyr::n() / n_samples_b)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> # A tibble: 1 × 1\n#>     sum\n#>   <dbl>\n#> 1 0.606\n```\n\n\n:::\n:::\n\n:::\n:::\n\nAnd, of course, you can do this calculation with the other methods as\nwell.\n\nTo produce the top part of Figure 3.2 of the book we apply following\ncode lines:\n\n::: my-r-code\n::: my-r-code-header\n::: {#cnj-fig-upper-part-3-2}\nb: Posterior distribution produced with {**tidyverse**} approach\n:::\n:::\n\n::: my-r-code-container\n\n::: {.cell hash='03-sampling-the-imaginary_cache/html/fig-upper-part-3.2-b_c5a169d8b5cdb4fbf12db53b72f8e094'}\n\n```{.r .cell-code}\n## R Code Fig 3.2 Upper Part #############\n# upper left panel\np1 <-\n  df_samples_b  |>  \n  ggplot2::ggplot(ggplot2::aes(x = samples_b, y = posterior_samples_b)) +\n  ggplot2::geom_line() +\n  ggplot2::geom_area(data = df_samples_b  |>  \n         dplyr::filter(samples_b < .5), fill = \"deepskyblue\") +\n  ggplot2::labs(x = \"proportion of water (p)\", y = \"density\")  +\n  ggplot2::theme_bw()\n\n# upper right panel\np2 <- \n  df_samples_b  |>  \n  ggplot2::ggplot(ggplot2::aes(x = samples_b, y = posterior_samples_b)) +\n  ggplot2::geom_line() +\n  ggplot2::geom_area(data = df_samples_b  |>  \n         dplyr::filter(samples_b > .5 & samples_b < .75), fill = \"deepskyblue\") +\n  ggplot2::labs(x = \"proportion of water (p)\", y = \"density\") +\n  ggplot2::theme_bw()\n\nlibrary(patchwork)\np1 + p2\n```\n\n::: {.cell-output-display}\n![Upper part of SR2 Figure 3.2: Intervals of defined boundaries produced with {**tidyverse**} tools: Left: The blue area is the posterior probability below a parameter value of 0.5. Right: The posterior probability between 0.5 and 0.75.](03-sampling-the-imaginary_files/figure-html/fig-upper-part-3.2-b-1.png){#fig-upper-part-3.2-b width=672}\n:::\n:::\n\n:::\n:::\n\n### Intervals of Defined Probability Mass {#sec-chap-03-probability-mass}\n\n#### ORIGINAL\n\n##### Quantiles\n\n::: my-definition\n::: my-definition-header\n::: {#def-probability-mass-intervals}\n: Several Terms for Intervals of Defined Probability Mass\n:::\n:::\n\n::: my-definition-container\n-   <a class='glossary' title='A range of values, calculated from the sample observations, that is believed, with a particular probability, to contain the true parameter value. (Cambridge Dictionary of Statistics, 4th ed., p.98)'>Confidence Interval</a>: Term chiefly used in\n    frequentist statistics.\n-   <a class='glossary' title='Two parameter values that contain between them a specified amount of posterior probability, a probability mass, is usually known as confidence interval in FREQUENTIST STATISTICS and credible interval in BAYESIAN STATISTICS.'>Credible Interval</a>: Term predominantly used in Bayesian\n    statistics.\n-   <a class='glossary' title='Two parameter values that contain between them a specified amount of posterior probability, a probability mass, is usually known as confidence interval that may instead be called a credible interval. We’re going to call it a compatibility interval instead, in order to avoid the unwarranted implications of “confidence”” and “credibility.” What the interval indicates is a range of parameter values compatible with the model and data. The model and data themselves may not inspire confidence, in which case the interval will not either. (Chap.3)'>Compatibility Interval</a>: Term preferably used by\n    Richard McElreath.\n\nThe abbreviation for all three versions of probability mass intervals is\n\"CI\".\n\nMcElreath tries to avoid the semantic of \"confidence\" or \"credibility\"\nbecause\n\n> \"What the interval indicates is a range of parameter values compatible\n> with the model and data. The model and data themselves may not inspire\n> confidence, in which case the interval will not either.\" ([McElreath,\n> 2020, p. 54](zotero://select/groups/5243560/items/NFUEVASQ))\n> ([pdf](zotero://open-pdf/groups/5243560/items/CPFRPHX8?page=73&annotation=BHMW5CJ4))\n:::\n:::\n\nThe values of these intervals can be found easier by using samples\nfrom the posterior than by using a grid approximation.\n\n> \"Suppose for example you want to know the boundaries of the lower\n> $80\\%$ posterior probability. You know this interval starts at\n> $p = 0$. To find out where it stops, think of the samples as data and\n> ask where the $80th$ percentile lies:\" ([McElreath, 2020, p.\n> 54](zotero://select/groups/5243560/items/NFUEVASQ))\n> ([pdf](zotero://open-pdf/groups/5243560/items/CPFRPHX8?page=73&annotation=3SA8YJWX))\n\n::: my-r-code\n::: my-r-code-header\n::: {#cnj-quantiles-a}\na: Compute posterior probability intervals lower $80\\%$ and from 10th to\n90th percentile\n:::\n:::\n\n::: my-r-code-container\n\n::: {.cell hash='03-sampling-the-imaginary_cache/html/quantiles-a_9e784ce0c867f8fccc0f74018b761567'}\n\n```{.r .cell-code}\n## R code 3.9a Quantile 0.8 #######################\nq8 <- quantile(samples_a, 0.8)\n\n## R code 3.10a PI = Quantile 0.1-0.9 ###################\nq1_9 <- quantile(samples_a, c(0.1, 0.9))\n```\n:::\n\n\n-   Lower $80\\%$ = 0.7627628\n-   Between $10\\%$ = 0.4514515 and $90\\%$ = 0.8148148\n:::\n:::\n\n##### Percentile Interval (PI)\n\nThe second calculation returns the middle 80% of the distribution\n\n> \"Intervals of this sort, which assign equal probability mass to each\n> tail, are very common in the scientific literature. We'll call them\n> <a class='glossary' title='The set of divisions that produce exactly 100 equal parts in a series of continuous values, such as blood pressure, weight, height, etc. Thus a person with blood pressure above the 80th percentile has a greater blood pressure value than over 80% of the other recorded values.” (CDS, p.323)'>percentile intervals</a> (PI). These\n> intervals do a good job of communicating the shape of a distribution,\n> as long as the distribution isn't too asymmetrical. But in terms of\n> supporting inferences about which parameters are consistent with the\n> data, they are not perfect.\" ([McElreath, 2020, p.\n> 55](zotero://select/groups/5243560/items/NFUEVASQ))\n> ([pdf](zotero://open-pdf/groups/5243560/items/CPFRPHX8?page=74&annotation=5GPNVTUH))\n\nBut they do not work well with highly skewed data. See\n@fig-skewed-dist-a where the posterior is consistent with observing\nthree waters in three tosses and a uniform (flat) prior.\n\n::: my-r-code\n::: my-r-code-header\n::: {#cnj-fig-skewed-dist-a}\na: Skewed posterior distribution observing three waters in three tosses\nand a uniform (flat) prior (Base R)\n:::\n:::\n\n::: my-r-code-container\n\n::: {.cell hash='03-sampling-the-imaginary_cache/html/fig-skewed-dist-a_fc0ad86c429badbace91c39191cfd874'}\n\n```{.r .cell-code}\n## R code 3.11a Skewed data #####################\np_grid_skewed_a <- seq(from = 0, to = 1, length.out = 1000)\nprior_skewed_a <- rep(1, 1000)\nlikelihood_skewed_a <- dbinom(3, size = 3, prob = p_grid_skewed_a)\nposterior_skewed_a <- likelihood_skewed_a * prior_skewed_a\nposterior_skewed_a <- posterior_skewed_a / sum(posterior_skewed_a)\n\nbase::set.seed(3) # added to make sampling distribution reproducible (pb)\nsamples_skewed_a <- sample(p_grid_skewed_a, \n             size = 1e4, replace = TRUE, prob = posterior_skewed_a)\n\n# added to show the skewed posterior distribution (pb)\nrethinking::dens(samples_skewed_a)\n```\n\n::: {.cell-output-display}\n![Skewed posterior distribution observing three waters in three tosses and a uniform (flat) prior. It is highly skewed, having its maximum value at the boundary where p equals 1.](03-sampling-the-imaginary_files/figure-html/fig-skewed-dist-a-1.png){#fig-skewed-dist-a width=672}\n:::\n:::\n\n:::\n:::\n\n> \"\\[The <a class='glossary' title='The set of divisions that produce exactly 100 equal parts in a series of continuous values, such as blood pressure, weight, height, etc. Thus a person with blood pressure above the 80th percentile has a greater blood pressure value than over 80% of the other recorded values.” (CDS, p.323)'>percentile interval</a>\\] assigns 25%\n> of the probability mass above and below the interval. So it provides\n> the central 50% probability. But in this example, it ends up excluding\n> the most probable parameter values, near p = 1. So in terms of\n> describing the shape of the posterior distribution---which is really\n> all these intervals are asked to do---the percentile interval can be\n> misleading.\" ([McElreath, 2020, p.\n> 56](zotero://select/groups/5243560/items/NFUEVASQ))\n> ([pdf](zotero://open-pdf/groups/5243560/items/CPFRPHX8?page=75&annotation=96JZPRGW))\n\n`rethinking::PI()` is just a shorthand for the base R\n`stats::quantile()` function.\n\n::: my-r-code\n::: my-r-code-header\n::: {#cnj-pi-a1}\na: Computing the Percentile Interval (PI)\n:::\n:::\n\n::: my-r-code-container\n\n::: {.cell hash='03-sampling-the-imaginary_cache/html/pi-a1_9f9a0ac9e55c376e74ba91061a626ac0'}\n\n```{.r .cell-code}\n## R code 3.12a(1) PI ############################\nrethinking::PI(samples_skewed_a, prob = 0.5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>       25%       75% \n#> 0.7087087 0.9349349\n```\n\n\n:::\n:::\n\n:::\n:::\n\n::: my-procedure\n::: my-procedure-header\n::: {#prp-pi-a1}\n: Probability mass (PI) `prob = 0.6` equals the interval between\n$20-80\\%$\n:::\n:::\n\n::: my-procedure-container\n`rethinking::PI()` is just a shorthand for the base R\n`stats::quantile()` function. Instead of providing the interval\nexplicitly (for instance $20-80\\%$) we just say that we want the central\n$60\\%$ = PI of `prob = 0.6`.\n\n`rethinking::PI()` simplifies the following three steps:\n\n1.  We divide always the percentage assigned to the `prob` value by 2:\n    60% / 2 = 30\\%$\n2.  We subtract, respectively add this value to 50: 50% - 30% = 20% and\n    50% + 30% = 80%\n3.  The result is the probability mass between 20-80%.\n:::\n:::\n\n::: my-r-code\n::: my-r-code-header\n::: {#cnj-pi-a2}\na: Compute PI between $20-80\\%$ (Rethinking and Base R)\n:::\n:::\n\n::: my-r-code-container\n\n::: {.cell hash='03-sampling-the-imaginary_cache/html/pi-a2_a059f98a558eef9e646ea6b5e3c57705'}\n\n```{.r .cell-code}\n## R code 3.12a(2) PI ############################\n\nglue::glue('Central Propbability Mass calculated with rethinking::PI()\\n')\nrethinking::PI(samples_skewed_a, prob = 0.6)\nglue::glue('########################################################\\n\\n')\nglue::glue('Central Propbability Mass calculated with stats::quantile()\\n')\nquantile(samples_skewed_a, prob = c(.20, .80))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> Central Propbability Mass calculated with rethinking::PI()\n#>       20%       80% \n#> 0.6706707 0.9481481 \n#> ########################################################\n#> \n#> Central Propbability Mass calculated with stats::quantile()\n#>       20%       80% \n#> 0.6706707 0.9481481\n```\n\n\n:::\n:::\n\n:::\n:::\n\n##### Highest Posterior Density Interval (HPDI)\n\nTo include the most probable parameter value, the modus or\n<a class='glossary' title='In Bayesian statistics a Maximum A Posteriori probability or MAP is essentially the mode of posterior distribution. (CDS, p.272)'>MAP</a> we should calculate the <a class='glossary' title='Highest Posterior Density Interval (HPDI) is the Highest Density Interval (HDI) or Highest Density Region (HDR) of all possible regions of probability coverage, the HDR has the smallest region possible in the sample space. For a unimodal distribution it will include the mode (the maximum a posteriori, or MAP). (Cross Validated).'>HPDI</a>:\n\n> \"The HPDI is the narrowest interval containing the specified\n> probability mass. If you think about it, there must be an infinite\n> number of posterior intervals // with the same mass. But if you want\n> an interval that best represents the parameter values most consistent\n> with the data, then you want the densest of these intervals. That's\n> what the HPDI is.\" (McElreath, 2020, p. 56/57)\n\n::: my-r-code\n::: my-r-code-header\n::: {#cnj-hpdi-a}\na: Compute Highest Posterior Density Interval (HPDI) (Rethinking / Base\nR)\n:::\n:::\n\n::: my-r-code-container\n\n::: {.cell hash='03-sampling-the-imaginary_cache/html/rethinking-HPDI-a_1157a07b6ed1e72fc5a91e8f1ab1c825'}\n\n```{.r .cell-code}\n## R code 3.13a HPDI ###############################\nrethinking::HPDI(samples_skewed_a, prob = 0.5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>      |0.5      0.5| \n#> 0.8418418 0.9989990\n```\n\n\n:::\n:::\n\n:::\n:::\n\n::: my-note\n::: my-note-header\n::: {#cor-pi-hpdo}\n: HPDI versus PI\n:::\n:::\n\n::: my-note-container\n**Advantages of HPDI**\n\n1.  HPDI captures the parameters with highest posterior probability\n2.  HPDI is noticeably narrower than PI. In our example\n    0.157\n    versus `r`round(rethinking::PI(samples_skewed_a, prob =\n    0.5)\\[\\[2\\]\\] - rethinking::PI(samples_skewed_a, prob =\n    0.5)\\[\\[1\\]\\], 3)\\`.\n\nBut this is only valid if we have a very skewed distribution.\n\n**Disadvantages of HPDI**\n\n1.  HPDI is more computationally intensive than PI\n2.  HPDI is sensitive of the number of samples drawn (= greater\n    simulation variance)\n3.  HPDI is more difficult to understand\n\n**Remember, the entire posterior distribution is the Bayesian estimate**\n\n> \"Overall, if the choice of interval type makes a big difference, then\n> you shouldn't be using intervals to summarize the posterior. Remember,\n> the entire posterior distribution is the Bayesian 'estimate.' It\n> summarizes the relative plausibilities of each possible value of the\n> parameter. Intervals of the distribution are just helpful for\n> summarizing it. If choice of interval leads to different inferences,\n> then you'd be better off just plotting the entire posterior\n> distribution.\" ([McElreath, 2020, p.\n> 58](zotero://select/groups/5243560/items/NFUEVASQ))\n> ([pdf](zotero://open-pdf/groups/5243560/items/CPFRPHX8?page=77&annotation=XGHNSWCG))\n:::\n:::\n\n\"\\[I\\]n most cases, these two types of interval are very similar.58 They\nonly look so different in this case because the posterior distribution\nis highly skewed.\" ([McElreath, 2020, p.\n57](zotero://select/groups/5243560/items/NFUEVASQ))\n([pdf](zotero://open-pdf/groups/5243560/items/CPFRPHX8?page=76&annotation=FQPNEVHV))n\n\n::: my-r-code\n::: my-r-code-header\n::: {#cnj-pi-hpdi-symmetric-dist-a}\na: Compare PI and HPDI of symmetric distributions: Six 'Water', 9 tosses\n:::\n:::\n\n::: my-r-code-container\n\n::: {.cell hash='03-sampling-the-imaginary_cache/html/pi-hpdi-symmetric-dist-a_83b76a9a735cc676bd488772bdcfcd66'}\n\n```{.r .cell-code}\npi8a <- rethinking::PI(samples_a, prob = 0.8)\nhpdi8a <- rethinking::HPDI(samples_a, prob = 0.8)\n\npi95a <- rethinking::PI(samples_a, prob = 0.95)\nhpdi95a <- rethinking::HPDI(samples_a, prob = 0.95)\n```\n:::\n\n\n-   PI 80% = 0.4514515, 0.8148148 versus HPDI 80% = 0.4874875, 0.8448448.\n-   PI 95% = 0.3493493, 0.8788789 versus HPDI 95% = 0.3703704, 0.8938939.\n:::\n:::\n\nThe 95% interval in frequentist statistics is just a convention, there\nare no analytical reasons why you should choose exactly this interval.\nBut convenience is not a serious criterion. So what to do instead?\n\n::: my-tip\n::: my-tip-header\nInstead of 95% intervals use the widest interval that excludes the value\nyou want to report or provide a series of nested intervals\n:::\n\n::: my-tip-container\n> \"If you are trying to say that an interval doesn't include some value,\n> then you might use the widest interval that excludes the value. Often,\n> all compatibility intervals do is communicate the shape of a\n> distribution. In that case, a series of nested intervals may be more\n> useful than any one interval. For example, why not present 67%, 89%,\n> and 97% intervals, along with the median? Why these values? No reason.\n> They are prime numbers, which makes them easy to remember. But all\n> that matters is they be spaced enough to illustrate the shape of the\n> posterior. And these values avoid 95%, since conventional 95%\n> intervals encourage many readers to conduct unconscious hypothesis\n> tests.\" ([McElreath, 2020, p.\n> 56](zotero://select/groups/5243560/items/NFUEVASQ))\n> ([pdf](zotero://open-pdf/groups/5243560/items/CPFRPHX8?page=75&annotation=TG2LCZAG))\n:::\n:::\n\n::: my-note\n::: my-note-header\nBoundaries versus Probability Mass Intervals\n:::\n\n::: my-note-container\n**Boundaries**:\n\n-   We ask for a **probability of frequencies**.\n-   Result is a **percentage of probability**.\n-   Boundaries are grounded on the **probability (`prob`) values\n    (**$0-1$).\n\n**Probability Mass**:\n\n-   We ask for a specified **amount of posterior probability**.\n-   Result is the probability value of the **percentage of frequencies**\n    we looked for.\n-   Probability Mass is grounded on the **percentage of probabilities\n    (**$0-100\\%$).\n:::\n:::\n\n#### TIDYVERSE\n\n##### Quantiles\n\nKurz offers again different methods --- this time to calculate\nprobability mass:\n\n1.  **Method**: Since we saved our `samples_b` samples within the\n    `df_samples_b` tibble, we'll have to index with `$` within\n    `stats::quantile()`.\n2.  **Method**: For an alternative approach, we could `dplyr::select()`\n    the `samples_b` vector, extract it from the tibble with\n    `dplyr::pull()`, and then pump it into `stats::quantile()`.\n\n> `pull()` is similar to `$`. It's mostly useful because it looks a\n> little nicer in pipes, it also works with remote data frames, and it\n> can optionally name the output. ([`dplyr::pull()` help file \"Extract a\n> single column\"](https://dplyr.tidyverse.org/reference/pull.html))\n\n3.  **Method**: We might also use `stats::quantile()` within\n    `dplyr::summarize()`.\n\n::: my-r-code\n::: my-r-code-header\n::: {#cnj-quantiles-b1}\nb: Compute posterior probability mass intervals of $80\\%$ with different\nmethods\n:::\n:::\n\n::: my-r-code-container\n\n::: {.cell hash='03-sampling-the-imaginary_cache/html/quantiles-b1_d8a9e12aa98dcc92518764eebe4ce17f'}\n\n```{.r .cell-code}\n## R code 3.9b Quantile 0.8 diff. approaches   #######################\n###### Method (1) #######\nmethod_1 <- q80 <- \n  quantile(df_samples_b$samples_b, probs = .8)\n\nglue::glue('Method 1:\\n')\nmethod_1\nglue::glue('##################################################\\n\\n')\n\n###### Method (2) #######\nmethod_2 <- \n  df_samples_b |> \n    dplyr::pull(samples_b) |> \n    quantile(probs = .8)\n\nglue::glue('Method 2:\\n')\nmethod_2\nglue::glue('##################################################\\n\\n')\n\n###### Method (3) #######\nmethod_3 <- \n  df_samples_b |> \n    dplyr::summarize(q80_2 = quantile(samples_b, probs = .8))\n\nglue::glue('Method 3:\\n')\nmethod_3\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> Method 1:\n#>       80% \n#> 0.7627628 \n#> ##################################################\n#> \n#> Method 2:\n#>       80% \n#> 0.7627628 \n#> ##################################################\n#> \n#> Method 3:\n#> # A tibble: 1 × 1\n#>   q80_2\n#>   <dbl>\n#> 1 0.763\n```\n\n\n:::\n:::\n\n:::\n:::\n\n##### Percentile Interval (PI)\n\nHere's the `summarize()` approach with two probabilities returning the\n<a class='glossary' title='The set of divisions that produce exactly 100 equal parts in a series of continuous values, such as blood pressure, weight, height, etc. Thus a person with blood pressure above the 80th percentile has a greater blood pressure value than over 80% of the other recorded values.” (CDS, p.323)'>percentile interval</a> (PI).\n\n::: my-r-code\n::: my-r-code-header\n::: {#cnj-pi-b1}\nb: Compute probability mass of 80% with summarize method\n:::\n:::\n\n::: my-r-code-container\n\n::: {.cell hash='03-sampling-the-imaginary_cache/html/pi-b1_1a616f218aa64abc0f38a3b457ea7604'}\n\n```{.r .cell-code}\n## R code 3.10b(1) PI = Quantile 0.1-0.9 ###################\ndf_samples_b |> \n    dplyr::summarize(q10 = quantile(samples_b, probs = .1),\n              q90 = quantile(samples_b, probs = .9))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> # A tibble: 1 × 2\n#>     q10   q90\n#>   <dbl> <dbl>\n#> 1 0.451 0.815\n```\n\n\n:::\n:::\n\n:::\n:::\n\nKurz refers also to a now deprecated calculation using the vector\nfeature of R to summarize different quantiles with one line.\n\n------------------------------------------------------------------------\n\n```         \nsamples_b |> dplyr::summarize(q10_90 = quantile(samples_b, probs = c(.1, .9)))\n```\n\n------------------------------------------------------------------------\n\nThis produces nowadays the following warning message:\n\n::: callout-warning\nWarning: Returning more (or less) than 1 row per `summarise()` group was\ndeprecated in dplyr 1.1.0.\n\nPlease use `reframe()` instead.\n\nWhen switching from `summarise()` to `reframe()`, remember that\n`reframe()` always returns an ungrouped data frame and adjust\naccordingly.\n:::\n\nTherefore I am going to change `dplyr::summarize()` to\n`dplyr::reframe()`.\n\n::: my-r-code\n::: my-r-code-header\n::: {#cnj-reframe}\nb: Using `dplyr::reframe()` to compute probability mass intervals of 80%\n:::\n:::\n\n::: my-r-code-container\n\n::: {.cell hash='03-sampling-the-imaginary_cache/html/quantile-reframe_69b30bcbce92df99da4f43b36726e49a'}\n\n```{.r .cell-code}\n## R code 3.10b(2) PI = Quantile 0.1-0.9 ###################\ndf_samples_b |> \n    dplyr::reframe(q10_90 = quantile(samples_b, probs = c(.1, .9)))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> # A tibble: 2 × 1\n#>   q10_90\n#>    <dbl>\n#> 1  0.451\n#> 2  0.815\n```\n\n\n:::\n:::\n\n\n::: my-note\n::: my-note-header\n::: {#cor-reframe}\n: Excursion: Using `dplyr::reframe()` and friends\n:::\n:::\n\n::: my-note-container\nFrom the help file of `dplyr::reframe()`:\n\n> While `summarise()` requires that each argument returns a single\n> value, and `mutate()` requires that each argument returns the same\n> number of rows as the input, `reframe()` is a more general workhorse\n> with no requirements on the number of rows returned per group.\n>\n> `reframe()` creates a new data frame by applying functions to columns\n> of an existing data frame. It is most similar to `summarise()`, with\n> two big differences:\n>\n> -   `reframe()` can return an arbitrary number of rows per group,\n>     while `summarise()` reduces each group down to a single row.\n> -   `reframe()` always returns an ungrouped data frame, while\n>     `summarise()` might return a grouped or rowwise data frame,\n>     depending on the scenario.\n>\n> We expect that you'll use `summarise()` much more often than\n> `reframe()`, but `reframe()` can be particularly helpful when you need\n> to apply a complex function that doesn't return a single summary\n> value.\n\nSee also the appropriate [section in the blog\npost](https://www.tidyverse.org/blog/2023/02/dplyr-1-1-0-pick-reframe-arrange/#reframe)\nabout changes in {**dplyr**} 1.1.0. The name `reframe()` is in\naccordance with `tibble::enframe()` and `tibble::deframe()`:\n\n-   `enframe()`: Takes a vector, returns a data frame\n-   `deframe()`: Takes a data frame, returns a vector\n-   `reframe()`: Takes a data frame, returns a data frame\n:::\n:::\n:::\n:::\n\n> The functions of the tidyverse approach typically returns a data\n> frame. But sometimes you just want your values in a numeric vector for\n> the sake of quick indexing. In that case, base R `stats::quantile()`\n> shines: (Kurz in the section: [Intervals of defined\n> mass](https://bookdown.org/content/4857/sampling-the-imaginary.html#intervals-of-defined-mass.))\n\n::: my-r-code\n::: my-r-code-header\n::: {#cnj-pi-b2}\nb: Using `stats::quantile()` to get a vector of a probability mass\ncalculation\n:::\n:::\n\n::: my-r-code-container\n\n::: {.cell hash='03-sampling-the-imaginary_cache/html/pi-b2_b6701835d008ad8c209d8a6f3d086c4d'}\n\n```{.r .cell-code}\n## R code 3.12b(1) PI = Quantile 0.1-0.9#############################\n(q10_q90 = quantile(df_samples_b$samples_b, probs = c(.1, .9)))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>       10%       90% \n#> 0.4514515 0.8148148\n```\n\n\n:::\n:::\n\n\nThis is the same method as in R base with the difference that we are\nworking with tibbles and need therefore to use the `$` operator.\n:::\n:::\n\nTo produce the bottom part of Figure 3.2 of the book we apply following\ncode lines.\n\n::: my-r-code\n::: my-r-code-header\n::: {#cnj-fig-lower-part-3-2b}\nb: Plots of defined mass intervals lower of 80% and the middle 80%\n:::\n:::\n\n::: my-r-code-container\n\n::: {.cell hash='03-sampling-the-imaginary_cache/html/fig-lower-part-3-2b_474cd6cd019b9b59d970ce3c864f3a53'}\n\n```{.r .cell-code}\n## R Code Fig 3.2b Lower Part #############\np1 <-\n  df_samples_b |> \n  ggplot2::ggplot(ggplot2::aes(x = samples_b, y = posterior_samples_b)) +\n  ggplot2::geom_line() +\n  ggplot2::geom_area(data = df_samples_b |> \n                dplyr::filter(samples_b < q80), fill = \"deepskyblue\") +\n  ggplot2::annotate(geom = \"text\",\n           x = .25, y = .0025,\n           label = \"lower 80%\") +\n  ggplot2::labs(x = \"proportion of water (p)\",\n       y = \"density\") +\n  ggplot2::theme_bw()\n\n# upper right panel\np2 <- \n  df_samples_b |> \n  ggplot2::ggplot(ggplot2::aes(x = samples_b, y = posterior_samples_b)) +\n  ggplot2::geom_line() +\n  ggplot2::geom_area(data = df_samples_b |> \n            dplyr::filter(samples_b > q10_q90[[1]] & \n                    samples_b < q10_q90[[2]]), fill = \"deepskyblue\") +\n  ggplot2::annotate(geom = \"text\",\n           x = .25, y = .0025,\n           label = \"middle 80%\") +\n  ggplot2::labs(x = \"proportion of water (p)\",\n       y = \"density\") +\n  ggplot2::theme_bw()\n\nlibrary(patchwork)\np1 + p2\n```\n\n::: {.cell-output-display}\n![Lower part of SR2 Figure 3.2: Intervals of defined mass produced with {**tidyverse**} tools: Left: Lower 80% posterior probability exists below a parameter value of about 0.75. Right: Middle 80% posterior probability lies between the 10% and 90% quantiles.](03-sampling-the-imaginary_files/figure-html/fig-lower-part-3-2b-1.png){#fig-lower-part-3-2b width=672}\n:::\n:::\n\n:::\n:::\n\nAgain we will demonstrate the misleading character of\n<a class='glossary' title='The set of divisions that produce exactly 100 equal parts in a series of continuous values, such as blood pressure, weight, height, etc. Thus a person with blood pressure above the 80th percentile has a greater blood pressure value than over 80% of the other recorded values.” (CDS, p.323)'>Percentile Intervals</a> (PIs) with a very\nskewed distribution.\n\nWe've already defined `p_grid_b` and `prior_b` within `d_b`, above. Here\nwe'll reuse them and create a new tibble by updating all the columns\nwith the skewed parameters of three 'Water' in three tosses.\n\nTo see the difference how the skewed distribution is different to the\nFigure 3.2 lower part, I will draw the appropriate figure here myself.\n\n::: my-r-code\n::: my-r-code-header\n::: {#cnj-fig-skewed-dist-b}\nb: Skewed posterior distribution observing three waters in three tosses\nand a uniform (flat) prior (Tidyverse)\n:::\n:::\n\n::: my-r-code-container\n\n::: {.cell layout-align=\"center\" figh-height='5' hash='03-sampling-the-imaginary_cache/html/fig-skewed-dist-b_0d5029015408fd7a1b8098161d4aebf3'}\n\n```{.r .cell-code}\n## R code 3.11b Skewed data #########################\n# here we update the `dbinom()` parameters \n# for values for a skewed distribution\n# assuming three trials results in 3 W (Water)\n\nn_samples_skewed_b <- 1e4\nn_success_skewed_b <- 3\nn_trials_skewed_b  <- 3\n\n# update `d_b` to d_skewed_b\nd_skewed_b <-\n  d_b |> \n    dplyr::mutate(likelihood_skewed_b = \n        stats::dbinom(n_success_skewed_b,\n           size = n_trials_skewed_b, prob = p_grid_b)) |> \n    dplyr::mutate(posterior_skewed_b  = \n          (likelihood_skewed_b * prior_b) / \n          sum(likelihood_skewed_b * prior_b))\n\n# make the next part reproducible\nbase::set.seed(3)\n\n# here's our new samples tibble\nsamples_skewed_b <- \n    d_skewed_b |> \n    dplyr::slice_sample(n = n_samples_skewed_b, \n        weight_by = posterior_skewed_b, replace = T) |> \n    dplyr::rename(p_skewed_b = p_grid_b,\n           prior_skewed_b = prior_b)\n\n\n# added to see the skewed distribution\nsamples_skewed_b |>  \n  ggplot2::ggplot( ggplot2::aes(x = p_skewed_b, y = posterior_skewed_b)) +\n  ggplot2::geom_line() +\n  ggplot2::theme_bw()\n```\n\n::: {.cell-output-display}\n![Skewed posterior distribution observing three waters in three tosses and a uniform (flat) prior. The distribution is highly skewed, having its maximum value where p equals 1.](03-sampling-the-imaginary_files/figure-html/fig-skewed-dist-b-1.png){#fig-skewed-dist-b fig-align='center' width=50%}\n:::\n:::\n\n:::\n:::\n\nTo see how the skewed distribution is different to the book's Figure 3.2\nlower part, I will draw the appropriate figure here.\n\n::: my-r-code\n::: my-r-code-header\n::: {#cnj-fig-prob-mass-skewed-dist}\nb: Lower 80% and middle 80% of probability mass intervals in the skewed\ndistribution\n:::\n:::\n\n::: my-r-code-container\n\n::: {.cell hash='03-sampling-the-imaginary_cache/html/fig-prob-mass-skewed-dist_65d5d28cdcd1a7fead1c99718a93118f'}\n\n```{.r .cell-code}\n## R code 3.12b(2) PI < 80 & middle 80% #############################\np1 <-\n  samples_skewed_b |> \n  ggplot2::ggplot(ggplot2::aes(x = p_skewed_b, y = posterior_skewed_b)) +\n  ggplot2::geom_line() +\n  ggplot2::geom_area(data = samples_skewed_b |> \n      dplyr::filter(p_skewed_b < q80), fill = \"deepskyblue\") +\n  ggplot2::annotate(geom = \"text\",\n           x = .25, y = .0025,\n           label = \"lower 80%\") +\n  ggplot2::labs(x = \"proportion of water (p)\",\n       y = \"density\") +\n  ggplot2::theme_bw()\n\n# upper right panel\np2 <- \n  samples_skewed_b |> \n  ggplot2::ggplot(ggplot2::aes(x = p_skewed_b, y = posterior_skewed_b)) +\n  ggplot2::geom_line() +\n  ggplot2::geom_area(data = samples_skewed_b |> \n      dplyr::filter(p_skewed_b > q10_q90[[1]] & \n                    p_skewed_b < q10_q90[[2]]), fill = \"deepskyblue\") +\n  ggplot2::annotate(geom = \"text\",\n           x = .25, y = .0025,\n           label = \"middle 80%\") +\n  ggplot2::labs(x = \"proportion of water (p)\",\n       y = \"density\") +\n  ggplot2::theme_bw()\n\nlibrary(patchwork)\np1 + p2\n```\n\n::: {.cell-output-display}\n![Probability mass intervals in a skewed distribution. Left: Lower 80%. right: Middle 80% = 80% Percentile Interval (PI)](03-sampling-the-imaginary_files/figure-html/fig-prob-mass-skewed-dist-1.png){#fig-prob-mass-skewed-dist width=672}\n:::\n:::\n\n:::\n:::\n\n##### Introducing tidybayes {.unnumbered}\n\n::: my-resource\n::: my-resource-header\nIntroducing the {**tidybayes**} package by Matthew Kay\n:::\n\n::: my-resource-container\nThe [{**tidybayes**}](https://mjskay.github.io/tidybayes/) package by\n[Matthew Kay](https://www.mjskay.com/) offers an array of convenience\nfunctions for summarizing Bayesian models.\n\n> {**tidybayes**} is an R package that aims to make it easy to integrate\n> popular Bayesian modeling methods into a tidy data + ggplot workflow.\n> It builds on top of (and re-exports) several functions for visualizing\n> uncertainty from its sister package,\n> [{**ggdist**}](https://mjskay.github.io/ggdist/).\n\n-   For an introduction using {**tidybayes**} with {**brms**} see\n    [Extracting and visualizing tidy draws from {**brms**}\n    models](https://mjskay.github.io/tidybayes/articles/tidy-brms.html).\n\n-   For a general introduction (not confined to {**brms**}) see [Using\n    tidy data with Bayesian\n    models](https://mjskay.github.io/tidybayes/articles/tidybayes.html)\n    but read also the start page [tidybayes: Bayesian analysis + tidy\n    data + geoms](https://mjskay.github.io/tidybayes/) of the package\n    documentation.\n\n-   Besides supporting many types of models there is an additional\n    {**tidybayes.rethinking**} package [available on\n    GitHub](https://mjskay.github.io/tidybayes.rethinking/) that extends\n    {**tidybayes**} to work with the {**rethinking**} package. I think\n    this package is a new development because Kurz didn't mention it.\n    (As far as I know, because at the moment I have read his [version\n    0.40](https://bookdown.org/content/4857/) only until chapter 4.)\n\nFor the following parts the section on [Point Summaries and\nIntervals](https://mjskay.github.io/tidybayes/articles/tidy-brms.html#point-summaries-and-intervals)\nand the reference on [Point and interval summaries for tidy data frames\nof draws from\ndistributions](https://mjskay.github.io/ggdist/reference/point_interval.html)\nare especially important.\n\nThe mentioned vignettes above are long articles I haven't read yet. I\nplan to do this in the next future but for now I am concentrating and\ntrusting on Kurz' text to apply and explain the most important function\nparallel to McElreath book chapters.\n:::\n:::\n\n::: my-watch-out\n::: my-watch-out-header\nMany function names used by Kurz do not apply anymore\n:::\n\n::: my-watch-out-container\nI had difficulties to use Kurz's functions because there was an\n[overhaul in the naming\nscheme](https://mjskay.github.io/tidybayes/reference/tidybayes-deprecated.html)\nof {**tidybayes**} version 1.0 and a deprecation of horizontal shortcut\ngeoms and stats in {**tidybayes**} 2.1. Because {**tidybayes**}\nintegrates function of the sister package {**ggdist**} the [function\ndescriptions and references of\n{**ggdist**}](https://mjskay.github.io/ggdist/reference/index.html) are\nalso important to consult. For instance all the function on [point and\ninterval\nsummaries](https://mjskay.github.io/ggdist/reference/point_interval.html)\nare now documented in {**ggdist**}.\n\nThere is a systematic change of the function names: The `h` (for\n'horizontal') in parameter name of the point estimate was removed. For\ninstance: Instead of `median_qih()`, `median_hdih()` and `median_hdcih()` it is now\n`tidybayes::median_qi()`, `tidybayes::median_hdi()` and\n`tidybayes::median_hdci()`. Similar with `point_inverhalh()`, `mean\\_\\*` and\n`mode\\_\\*`.\n\n------------------------------------------------------------------------\n\nThere is another adaption compared to the Kurz' version: I can't\nreproduce the codes with his `samples` (my `samples_b`) data frame,\nbecause the data has changed values recently to the skewed sampling\nversion. To get the same results as Kurz I have to use in my naming\nscheme the `skewed` version.\n:::\n:::\n\n> The {**tidybayes**} package contains a [family of\n> functions](https://mjskay.github.io/tidybayes/articles/tidy-brms.html#point-summaries-and-intervals)\n> that make it easy to summarize a distribution with a measure of\n> central tendency accompanied by intervals. With\n> `tidybayes::median_qi()`, we will ask for the median and\n> quantile-based intervals --- just like we've been doing with\n> `stats::quantile()`.\n> ([Kurz](https://bookdown.org/content/4857/sampling-the-imaginary.html#intervals-of-defined-mass.))\n\n::: my-r-code\n::: my-r-code-header\n::: {#cnj-median-qi}\n: Computing the median quantile interval with {**tidybayes**}\n:::\n:::\n\n::: my-r-code-container\n\n::: {.cell hash='03-sampling-the-imaginary_cache/html/median-quantile-interval_4e6cf62891adca1869b35c9b291b8166'}\n\n```{.r .cell-code}\ntidybayes::median_qi(samples_skewed_b$p_skewed_b, .width = .5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>           y      ymin      ymax .width .point .interval\n#> 1 0.8428428 0.7087087 0.9349349    0.5 median        qi\n```\n\n\n:::\n:::\n\n\n> Note how the `.width` argument within `tidybayes::median_qi()` worked\n> the same way the `prob` argument did within `rethinking::PI()`. With\n> `.width = .5`, we indicated we wanted a quantile-based 50% interval,\n> which was returned in the `ymin` and `ymax` columns.\n:::\n:::\n\n::: my-note\n::: my-note-header\n::: {#cor-point-interval-summaries}\n: Point and interval summaries for tidy data frames of draws from\ndistributions\n:::\n:::\n\n::: my-note-container\nThe `qi` in `tidybayes::median_qi()` stands for \"quantile interval\". The\nexplanation of this function family (`median_qi()`, `mean_qi()` and\n`mode_qi()`) is now documented in the {**ggdist**} package.\n\n> The `qi`-variants is the short form of the function family of\n> `tidybayes::point_interval(..., .point = median, .interval = qi)`.\n>\n> There are several point intervals that {**tidybayes**} respectively\n> {**ggdist**} computes:\n>\n> -   **qi** yields the quantile interval (also known as the percentile\n>     interval or equi-tailed interval) as a 1x2 matrix.\n> -   **hdi** yields the highest-density interval(s) (also known as the\n>     highest posterior density interval). Note: If the distribution is\n>     multimodal, hdi may return multiple intervals for each probability\n>     level (these will be spread over rows). You may wish to use hdci\n>     (below) instead if you want a single highest-density interval,\n>     with the caveat that when the distribution is multimodal hdci is\n>     not a highest-density interval.\n> -   **hdci** yields the highest-density continuous interval, also\n>     known as the shortest probability interval. Note: If the\n>     distribution is multimodal, this may not actually be the\n>     highest-density interval (there may be a higher-density\n>     discontinuous interval, which can be found using hdi).\n> -   **ll and ul** yield lower limits and upper limits, respectively\n>     (where the opposite limit is set to either Inf or -Inf). ([ggdist\n>     reference](https://mjskay.github.io/ggdist/reference/point_interval.html))\n:::\n:::\n\n> The {**tidybayes**} framework makes it easy to request multiple types\n> of intervals. In the following code chunk we'll request 50%, 80%, and\n> 99% intervals.\n\n::: my-r-code\n::: my-r-code-header\n::: {#cnj-multiple-intervals-b}\nb: Requesting multiple type of intervals with {**tidybayes**}\n:::\n:::\n\n::: my-r-code-container\n\n::: {.cell hash='03-sampling-the-imaginary_cache/html/multiple-intervals-b_e399434b2794763c461b3274996fd7c3'}\n\n```{.r .cell-code}\n## R code 3.12b(3) different PIs ##############\ntidybayes::median_qi(samples_skewed_b$p_skewed_b, .width = c(.5, .8, .99))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>           y      ymin      ymax .width .point .interval\n#> 1 0.8428428 0.7087087 0.9349349   0.50 median        qi\n#> 2 0.8428428 0.5705706 0.9749750   0.80 median        qi\n#> 3 0.8428428 0.2562563 0.9989990   0.99 median        qi\n```\n\n\n:::\n:::\n\n\n> The .width column in the output indexed which line presented which\n> interval. The value in the y column remained constant across rows.\n> That's because that column listed the measure of central tendency, the\n> median in this case.\n:::\n:::\n\n##### Highest Posterior Density Interval (HPDI)\n\n> Now let's use the `rethinking::HPDI()` function to return 50% highest\n> posterior density intervals (HPDIs).\n\n::: my-r-code\n::: my-r-code-header\n::: {#cnj-rethinking-hpdi-b}\nb: Compute Highest Posterior Density Interval (HPDI) (Rethinking /\nTidyverse)\n:::\n:::\n\n::: my-r-code-container\n\n::: {.cell hash='03-sampling-the-imaginary_cache/html/rethinking-HPDI-b_cc3db276038e54fb4520c5c77a9c48a6'}\n\n```{.r .cell-code}\n## R code 3.13b(1) HPDI ###############################\nrethinking::HPDI(samples_skewed_b$p_skewed_b, prob = .5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>      |0.5      0.5| \n#> 0.8418418 0.9989990\n```\n\n\n:::\n:::\n\n:::\n:::\n\n> The reason I introduce {**tidybayes**} now is that the functions of\n> the {**brms**} package only support percentile-based intervals of the\n> type we computed with `quantile()` and `median_qi()`. But\n> {**tidybayes**} also supports HPDIs.\n\n::: my-watch-out\n::: my-watch-out-header\n: Two Version for Highest Density Intervals\n:::\n\n::: my-watch-out-container\nAs already mentioned in @cor-point-interval-summaries there is `hdi`and\n`hcdi`. Both functions produce the same result in unimodal\ndistributions.\n\nBut in the case of an extreme skewed distribution like our data frame\nwith the observation of 3 'Water' with 3 tosses the `tidybayes::hdi()`\nfunctions generates an error.\n\n> Error in quantile.default(dist_y, probs = 1 - .width) :\\\n> missing values and NaN's not allowed if 'na.rm' is FALSE\n\nMy error message with `hdi` is in contrast to Kurz’ version where this function seems to work. BTW: I got the same error message providing the vector `samples_skewed_a`.\nfrom the Base R version.\n:::\n:::\n\n::: my-r-code\n::: my-r-code-header\n::: {#cnj-tidyverse-HPDI-b}\n: High Density Intervals with {**tidybayes**}\n:::\n:::\n\n::: my-r-code-container\n::: panel-tabset\n###### 6 W, n=9\n\n\n::: {.cell hash='03-sampling-the-imaginary_cache/html/tidyverse-HPDI-b1_b149b776066d951da2633fb4d7edb755'}\n\n```{.r .cell-code}\n## R code 3.13b(2a) HPDI 6 Water, 9 tosses #####################\ntidybayes::mode_hdi(df_samples_b$samples_b, .width = .5)\ntidybayes::mode_hdci(df_samples_b$samples_b, .width = .5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>           y      ymin      ymax .width .point .interval\n#> 1 0.6508383 0.5685686 0.7597598    0.5   mode       hdi\n#>           y      ymin      ymax .width .point .interval\n#> 1 0.6508383 0.5685686 0.7597598    0.5   mode      hdci\n```\n\n\n:::\n:::\n\n\n###### 3 W, n=3\n\n\n::: {.cell hash='03-sampling-the-imaginary_cache/html/tidyverse-HPDI-b2_066c5bc08c7652428a542b26146c78c4'}\n\n```{.r .cell-code}\n## R code 3.13b(2b) HPDI 3 Water, 3 tosses #####################\n# tidybayes::mode_hdi(samples_skewed_b$p_skewed_b, .width = .5) # generates error\ntidybayes::mode_hdci(samples_skewed_b$p_skewed_b, .width = .5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>           y      ymin     ymax .width .point .interval\n#> 1 0.9995616 0.8418418 0.998999    0.5   mode      hdci\n```\n\n\n:::\n:::\n\n:::\n:::\n:::\n\nIn contrast to @cnj-multiple-intervals-b and @cnj-rethinking-hpdi-b we\nused this time the mode as the measure of central tendency. With this\nfamily of {**tidybayes**} functions, you specify the measure of central\ntendency in the prefix (i.e., mean, median, or mode) and then the type\nof interval you'd like (i.e., `qi()` or `hdci()`).\n\nIf all you want are the intervals without the measure of central\ntendency or all that other technical information, {**tidybayes**} also\noffers the handy `qi()` and `hdi()` functions.\n\n::: my-r-code\n::: my-r-code-header\n::: {#cnj-pi-4}\n: Numbered R Code Title\n:::\n:::\n\n::: my-r-code-container\n\n\n::: {.cell hash='03-sampling-the-imaginary_cache/html/pi-4_7c52e13b74873cf333162cfdf21d5124'}\n\n```{.r .cell-code}\n## R code 3.12b4 PI 0.5 ##############################\ntidybayes::qi(samples_skewed_b$p_skewed_b, .width = .5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>           [,1]      [,2]\n#> [1,] 0.7087087 0.9349349\n```\n\n\n:::\n:::\n\n\n:::\n:::\n\nWe have now all necessary skills to plot book's Figure 3.3:\n\n::: my-r-code\n::: my-r-code-header\n::: {#cnj-fig-pi-hpdi}\nb: Plot the difference between percentile interval (PI) and highest\nposterior density intervals (HPDI)\n:::\n:::\n\n::: my-r-code-container\n\n::: {.cell hash='03-sampling-the-imaginary_cache/html/fig-pi-hpdi_b99dbdd5fbdb4cf86b74756b578acd86'}\n\n```{.r .cell-code}\n## R code Figure 3.3 #######################\n# left panel\np1 <-\n  samples_skewed_b |> \n  ggplot2::ggplot(ggplot2::aes(x = p_skewed_b, y = posterior_skewed_b)) +\n  # check out our sweet `qi()` indexing\n  ggplot2::geom_area(data = samples_skewed_b |> \n              dplyr::filter(p_skewed_b >\n                tidybayes::qi(samples_skewed_b$p_skewed_b, .width = .5)[1] & \n                     p_skewed_b <\n                tidybayes::qi(samples_skewed_b$p_skewed_b, .width = .5)[2]),\n                fill = \"deepskyblue\") +\n  ggplot2::geom_line() +\n  ggplot2::labs(subtitle = \"50% Percentile Interval\",\n       x = \"proportion of water (p)\",\n       y = \"density\") +\n  ggplot2::theme_bw()\n\n# right panel\np2 <-\n  samples_skewed_b |> \n  ggplot2::ggplot(ggplot2::aes(x = p_skewed_b, y = posterior_skewed_b)) +\n  ggplot2::geom_area(data = samples_skewed_b |> \n              dplyr::filter(p_skewed_b > \n                 tidybayes::hdci(samples_skewed_b$p_skewed_b, .width = .5)[1] & \n                       p_skewed_b < \n                 tidybayes::hdci(samples_skewed_b$p_skewed_b, .width = .5)[2]),\n                 fill = \"deepskyblue\") +\n  ggplot2::geom_line() +\n  ggplot2::labs(subtitle = \"50% HPDI\",\n       x = \"proportion of water (p)\",\n       y = \"density\") +\n  ggplot2::theme_bw()\n\n# combine!\nlibrary(patchwork)\np1 | p2\n```\n\n::: {.cell-output-display}\n![Reproduction of Figure 3.3 (p.57): The difference between percentile and highest posterior density compatibility intervals. The posterior density here corresponds to a flat prior and observing three water samples in three total tosses of the globe. Left: 50% percentile interval. This interval assigns equal mass (25%) to both the left and right tail. As a result, it omits the most probable parameter value, where p equals 1. Right: 50% highest posterior density interval, HPDI. This interval finds the narrowest region with 50% of the posterior probability. Such a region always includes the most probable parameter value.](03-sampling-the-imaginary_files/figure-html/fig-pi-hpdi-1.png){#fig-pi-hpdi width=672}\n:::\n:::\n\n:::\n:::\n\nComparing the two panels of the plot you can see that in contrast to the\n50% HPDI the 50% of PI does not include the highest probability value.\n\n::: my-watch-out\n::: my-watch-out-header\n{**magrittr**} and native R pipe\n:::\n\n::: my-watch-out-container\nKurz uses the {**magrittr**} paipe whereas I am using the native R pipe.\nThese two pipes are not in every aspect equivalent. One difference is\nthe dot (`.`) syntax, \"since the dot syntax is a feature of\n{**magrittr**} and not of base R.\" ([Understanding the native R\npipe](https://ivelasq.rbind.io/blog/understanding-the-r-pipe/#how-the-native-r-pipe-works)).\n\nThe native pipe is available starting with R 4.1.0. It is constructed\nwith `|` followed by `>` resulting in the symbol `|>` to differentiate\nit from the {**magrittr**} pipe (`%>%`). To understand the details of\nthe differences of `|>` and the native R pipe `|>` read this elaborated\n[blog article by Isabella\nVelásquez](https://ivelasq.rbind.io/blog/understanding-the-r-pipe/index.html),\nan employee of [Posit](https://posit.co/) (formerly RStudio).\n\nSo the following trick does not work with the native R pipe:\n\n> In the geom_area() line for the HPDI plot, did you notice how we\n> replaced `data = samples_skewed_b` with `data = .`? When using the\n> pipe (i.e., `%>%`), you can use the `.` as a placeholder for the\n> original data object. It's an odd and handy trick to know about.\n\nTherefore I had to replace the dot with the name of the data frame.\n\nLearn more of the [pipe function `%>%` of the {**magrittr**}\npackage](https://magrittr.tidyverse.org/reference/pipe.html) and about\nthe [base R native forward pipe\noperator](https://stat.ethz.ch/R-manual/R-devel/library/base/html/pipeOp.html).\n:::\n:::\n\nPI and HPDI are only different if you have a very skewed distribution.\nThis means that in unimodal somewhat normal distribution `hdi` and\n`hdci` are exactly the same and pretty similar to `qi` calculation. In\nskewed distribution they differ. assertion:\n\n::: my-r-code\n::: my-r-code-header\n<div>\n\nb: High Density Intervals with {**tidybayes**}\n\n</div>\n:::\n\n::: my-r-code-container\n::: panel-tabset\n###### 6 W, n=9\n\n\n::: {.cell hash='03-sampling-the-imaginary_cache/html/tidyverse-PI-HPDI-b1_41c2c7f200ac308e6a6e76a6965579d9'}\n\n```{.r .cell-code}\n## R code 3.13b(2a) HPDI 6 Water, 9 tosses #####################\ntidybayes::mode_hdi(df_samples_b$samples_b, .width = .5)\ntidybayes::mode_hdci(df_samples_b$samples_b, .width = .5)\ntidybayes::mode_qi(df_samples_b$samples_b, .width = .5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>           y      ymin      ymax .width .point .interval\n#> 1 0.6508383 0.5685686 0.7597598    0.5   mode       hdi\n#>           y      ymin      ymax .width .point .interval\n#> 1 0.6508383 0.5685686 0.7597598    0.5   mode      hdci\n#>           y      ymin      ymax .width .point .interval\n#> 1 0.6508383 0.5475475 0.7427427    0.5   mode        qi\n```\n\n\n:::\n:::\n\n\n###### 3 W, n=3\n\n\n::: {.cell hash='03-sampling-the-imaginary_cache/html/tidyverse-PI-HPDI-b2_bf469faff3bfb4ddfc48237d9c1e7fc4'}\n\n```{.r .cell-code}\n## R code 3.13b(2b) HPDI 3 Water, 3 tosses #####################\n# tidybayes::mode_hdi(samples_skewed_b$p_skewed_b, .width = .5) # generates error\ntidybayes::mode_hdci(samples_skewed_b$p_skewed_b, .width = .5)\ntidybayes::mode_qi(samples_skewed_b$p_skewed_b, .width = .5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>           y      ymin     ymax .width .point .interval\n#> 1 0.9995616 0.8418418 0.998999    0.5   mode      hdci\n#>           y      ymin      ymax .width .point .interval\n#> 1 0.9995616 0.7087087 0.9349349    0.5   mode        qi\n```\n\n\n:::\n:::\n\n:::\n:::\n:::\n\nBecause of the disadvantages of <a class='glossary' title='Highest Posterior Density Interval (HPDI) is the Highest Density Interval (HDI) or Highest Density Region (HDR) of all possible regions of probability coverage, the HDR has the smallest region possible in the sample space. For a unimodal distribution it will include the mode (the maximum a posteriori, or MAP). (Cross Validated).'>HPDI</a> (more\ncomputationally intensive, greater simulation variance and harder to\nunderstand) Kurz will primarily stick to the PI-based intervals. And he\nwill not use the 5.5% and 94.5% <a class='glossary' title='Quantiles are cut points dividing the range of a probability distribution into continuous intervals with equal probabilities (Wikipedia)'>quantiles</a>\nthat are <a class='glossary' title='The set of divisions that produce exactly 100 equal parts in a series of continuous values, such as blood pressure, weight, height, etc. Thus a person with blood pressure above the 80th percentile has a greater blood pressure value than over 80% of the other recorded values.” (CDS, p.323)'>percentile intervals</a> boundaries,\ncorresponding to an 89% <a class='glossary' title='Two parameter values that contain between them a specified amount of posterior probability, a probability mass, is usually known as confidence interval that may instead be called a credible interval. We’re going to call it a compatibility interval instead, in order to avoid the unwarranted implications of “confidence”” and “credibility.” What the interval indicates is a range of parameter values compatible with the model and data. The model and data themselves may not inspire confidence, in which case the interval will not either. (Chap.3)'>compatibility interval</a> but stick\nto the 95% standard (frequentist) <a class='glossary' title='A range of values, calculated from the sample observations, that is believed, with a particular probability, to contain the true parameter value. (Cambridge Dictionary of Statistics, 4th ed., p.98)'>confidence interval</a>.\n\n### Point Estimates {#sec-chap-03-point-estimates}\n\n#### ORIGINAL\n\n##### Measures of Central Tendency\n\n> \"Given the entire posterior distribution, what value should you\n> report? This seems like an innocent question, but it is difficult to\n> answer. The Bayesian parameter estimate is precisely the entire\n> posterior distribution, which is not a single number, but instead a\n> function that maps each unique parameter value onto a plausibility\n> value. So really the most important thing to note is that you don't\n> have to choose a point estimate. It's hardly ever necessary and often\n> harmful. It discards information.\" ([McElreath, 2020, p.\n> 58](zotero://select/groups/5243560/items/NFUEVASQ))\n> ([pdf](zotero://open-pdf/groups/5243560/items/CPFRPHX8?page=77&annotation=EVCFUS3F))\n\nBut whenever you have to do it, you must choose between mean, median and\nMAP (= the parameter value with highest posterior probability, a\n*maximum a posteriori*, essentially the \"peak\" or mode of the posterior\ndistribution.\n\nIn the very skewed globe tossing example where we observed 3 waters out\nof 3 tosses they are all different.\n\n::: my-r-code\n::: my-r-code-header\n::: {#cnj-point-estimates-a}\na: Compute MAP, median and mean\n:::\n:::\n\n::: my-r-code-container\n\n::: {.cell hash='03-sampling-the-imaginary_cache/html/point-estimates-a_71f0f1b0438e135c58d7f40776faa901'}\n\n```{.r .cell-code}\n## R code 3.14a MAP (from grid) ###############\nmap_skewed_a_1 <- p_grid_skewed_a[which.max(posterior_skewed_a)]\n\n## R code 3.15a MAP from posterior samples ################\nmap_skewed_a_2 <- rethinking::chainmode(samples_skewed_a, adj = 0.01)\n\n## R code 3.16a mean and median #############\nmean_skewed_a <- mean(samples_skewed_a)\nmedian_skewed_a <- median(samples_skewed_a)\n```\n:::\n\n\n**Results:**\n\n-   MAP with `which.max()` = 1\n-   MAP with `rethinking::chainmode()` = 0.9938226\n-   Mean: 0.8027632\n-   Median: 0.8428428\n:::\n:::\n\n::: my-watch-out\n::: my-watch-out-header\nDifference between MAP and mode calculation?\n:::\n\n::: my-watch-out-container\nI have observed small differences between the MAP calculation in\n@cnj-point-estimates-a and the mode calculation of other packages. I\nwonder why all these other methods give 0.95/0.96 whereas the MAP\ncalculation results in 0.99/1.0.\n\nOne explanation I could think is that the mode is defined by the\n*maximum frequency* of observations, whereas the MAP is calculated from\nthe *maximum of the weighted probability frequency* .\n\nBut I am not sure. One thing I can say with some certainty is that MAP\nseems [a complicated theoretical\nconstruct](https://web.stanford.edu/class/archive/cs/cs109/cs109.1216/lectures/22_map.pdf)\nand a [difficult computational\nprocedure](https://machinelearningmastery.com/maximum-a-posteriori-estimation/).\n\n::: my-r-code\n::: my-r-code-header\n::: {#cnj-map-mode}\na: Compare MAP and mode calculation of different packages\n:::\n:::\n\n::: my-r-code-container\n\n::: {.cell hash='03-sampling-the-imaginary_cache/html/different-modes_989d4a1eb57ac4288219b5ec2169d657'}\n\n```{.r .cell-code}\nm_skewed_1 <- modeest::mlv(samples_skewed_a, method = \"mfv\")\nm_skewed_2 <- DescTools::Mode(samples_skewed_a)\nm_skewed_3 <- bayestestR::map_estimate(samples_skewed_a)\n```\n:::\n\n\nResults of mode calculation with several packages:\n\n-   `modeest::mlv()`: 0.953954\n-   `DescTools::Mode()`: 0.953954\n-   `bayestestR::map_estimate()`: 0.9622849\n:::\n:::\n:::\n:::\n\nThe graphical representation as shown in Figure 3.4 will be calculated\nin the tidyverse version of this section. See:\n@fig-left-panel-3-4-skewed-b for the left panel and @fig-prop-loss-b for\nthe right panel of Figure 3.4.\n\n##### Loss function to support particular decisions\n\n\"One principled way to go beyond using the entire posterior as the\nestimate is to choose a <a class='glossary' title='A loss function is a rule that tells you the cost associated with using any particular point estimate. … The key insight is that different loss functions imply different point estimates. (SR2, p.59)'>loss function</a>.\" ([McElreath,\n2020, p. 59](zotero://select/groups/5243560/items/NFUEVASQ))\n([pdf](zotero://open-pdf/groups/5243560/items/CPFRPHX8?page=78&annotation=42KE9FFZ))\n\n::: my-important\n::: my-important-header\nDifferent loss functions imply different point estimates. ([McElreath,\n2020, p. 59](zotero://select/groups/5243560/items/NFUEVASQ))\n([pdf](zotero://open-pdf/groups/5243560/items/CPFRPHX8?page=78&annotation=3X2FI82B))\n:::\n:::\n\n> \"Here's an example to help us work through the procedure. Suppose I\n> offer you a bet. Tell me which value of p, the proportion of water on\n> the Earth, you think is correct. I will pay you $\\$100$, if you get it\n> exactly right. But I will subtract money from your gain, proportional\n> to the distance of your decision from the correct value. Precisely,\n> your loss is proportional to the absolute value of $d − p$, where $d$\n> is your decision and $p$ is the correct answer. We could change the\n> precise dollar values involved, without changing the important aspects\n> of this // problem. What matters is that the loss is proportional to\n> the distance of your decision from the true value. Now once you have\n> the posterior distribution in hand, how should you use it to maximize\n> your expected winnings? It turns out that the parameter value that\n> maximizes expected winnings (minimizes expected loss) is the median of\n> the posterior distribution.\" ([McElreath, 2020, p.\n> 59/60](zotero://select/groups/5243560/items/NFUEVASQ))\n> ([pdf](zotero://open-pdf/groups/5243560/items/CPFRPHX8?page=79&annotation=59IS3PFL))\n\n> \"Calculating expected loss for any given decision means using the\n> posterior to average over our uncertainty in the true value. Of course\n> we don't know the true value, in most cases. But if we are going to\n> use our model's information about the parameter, that means using the\n> entire posterior distribution. So suppose we decide $p = 0.5$ will be\n> our decision.\" ([McElreath, 2020, p.\n> 60](zotero://select/groups/5243560/items/NFUEVASQ))\n> ([pdf](zotero://open-pdf/groups/5243560/items/CPFRPHX8?page=79&annotation=UTEYE7VX)).\n\n::: my-r-code\n::: my-r-code-header\n::: {#cnj-expected-loss-a}\na: Calculated expected loss for $p = 0.5$\n:::\n:::\n\n::: my-r-code-container\n\n::: {.cell hash='03-sampling-the-imaginary_cache/html/expected-loss-a_9980eaa36942804aa11ce90b1c62e2f1'}\n\n```{.r .cell-code}\n## R code 3.17a weighted average loss ##################\nloss_avg_a <- sum(posterior_skewed_a * abs(0.5 - p_grid_skewed_a))\n\n## R code 3.18a for every possible value #############################\nloss_a <- sapply(p_grid_skewed_a, \n     function(d) sum(posterior_skewed_a * abs(d - p_grid_skewed_a)))\n\n## R code 3.19a minimized loss value #############################\nloss_min_a <- p_grid_skewed_a[which.min(loss_a)]\n```\n:::\n\n\n**Results:**\n\n-   Weighted average loss value = 0.3128752.\n-   Parameter value that minimizes the loss = 0.8408408. This is\n    the posterior median that we already have calculated in @cnj-point-estimates-a. Because of sampling variation it is not identical but pretty close (0.8428428 versus\n    0.8408408).\n:::\n:::\n\n::: my-important\n::: my-important-header\nLearnings: Point estimates\n:::\n\n::: my-important-container\n> \"In order to decide upon a *point estimate*, a single-value summary of\n> the posterior distribution, we need to pick a loss function. Different\n> loss functions nominate different point estimates. The two most common\n> examples are the absolute loss as above, which leads to the median as\n> the point estimate, and the quadratic loss $(d − p)^{2}$, which leads\n> to the posterior mean (`mean(samples_a)`) as the point estimate. When\n> the posterior distribution is symmetrical and normal-looking, then the\n> median and mean converge to the same point, which relaxes some anxiety\n> we might have about choosing a loss function. For the original globe\n> tossing data (6 waters in 9 tosses), for example, the mean and median\n> are barely different.\" ([McElreath, 2020, p.\n> 60](zotero://select/groups/5243560/items/NFUEVASQ))\n> ([pdf](zotero://open-pdf/groups/5243560/items/CPFRPHX8?page=79&annotation=JHGI3FVY))\n\n> \"Usually, research scientists don't think about loss functions. And so\n> any point estimate like the mean or MAP that they may report isn't\n> intended to support any particular decision, but rather to describe\n> the shape of the posterior. You might argue that the decision to make\n> is whether or not to accept an hypothesis. But the challenge then is\n> to say what the relevant costs and benefits would be, in terms of the\n> knowledge gained or lost. Usually it's better to communicate as much\n> as you can about the posterior distribution, as well as the data and\n> the model itself, so that others can build upon your work. Premature\n> decisions to accept or reject hypotheses can cost lives.\" ([McElreath,\n> 2020, p. 61](zotero://select/groups/5243560/items/NFUEVASQ))\n> ([pdf](zotero://open-pdf/groups/5243560/items/CPFRPHX8?page=80&annotation=6GVPUF4Z))\n:::\n:::\n\n#### TIDYVERSE\n\n##### Measures of Central Tendency\n\nIf we sort the posterior values of `d_skewed_b` (three tosses with three\n`W`) from highest to lowest values then the first row (= the maximum\nvalue of `posterior_skewed_b`) will give us the MAP as the corresponding\n`p_grid_b` value. Additionally the {**tidybayes**} has other options to\ncompute the MAP. To calculate mean and median we will use the Base R\nfunctions. In the following code chunk I have collected all these\ndifferent calculations.\n\n::: my-r-code\n::: my-r-code-header\n::: {#cnj-point-estimates-b}\nb: Compute MAP, median and mean\n:::\n:::\n\n::: my-r-code-container\n\n::: {.cell hash='03-sampling-the-imaginary_cache/html/point-estimates-b_3160fca7da5557539cb06baf3d8148c2'}\n\n```{.r .cell-code}\n## R code 3.14b MAP (from grid) ###############################\nglue::glue('MAP computed with dplyr::arrange(dplyr::desc())\\n')\nmap_skewed_b <- d_skewed_b |> \n  dplyr::arrange(dplyr::desc(posterior_skewed_b)) \n\nmap_skewed_b[1, c(1,6)]\nglue::glue('#####################################################\\n\\n')\n\n## R code 3.15b MAP (from posterior sample) ###############################\nglue::glue('MAP computed with tidybayes::mode_qi()\\n')\nsamples_skewed_b |> tidybayes::mode_qi(p_skewed_b)\nglue::glue('#####################################################\\n\\n')\n\nglue::glue('MAP computed with tidybayes::mode_hdci()\\n')\nsamples_skewed_b |> tidybayes::mode_hdci(p_skewed_b)\nglue::glue('#####################################################\\n\\n')\n\nglue::glue('MAP computed with tidybayes::Mode()\\n')\ntidybayes::Mode(samples_skewed_b$p_skewed_b)\nglue::glue('#####################################################\\n\\n')\n\n## R code 3.16b mean and median #############################\nglue::glue('Mean & Median computed with mean() & median()\\n')\nsamples_skewed_b |> \n  dplyr::summarize(mean   = mean(p_skewed_b),\n            median = median(p_skewed_b))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> MAP computed with dplyr::arrange(dplyr::desc())\n#> # A tibble: 1 × 2\n#>   p_grid_b posterior_skewed_b\n#>      <dbl>              <dbl>\n#> 1        1            0.00400\n#> #####################################################\n#> \n#> MAP computed with tidybayes::mode_qi()\n#> # A tibble: 1 × 6\n#>   p_skewed_b .lower .upper .width .point .interval\n#>        <dbl>  <dbl>  <dbl>  <dbl> <chr>  <chr>    \n#> 1       1.00  0.399  0.994   0.95 mode   qi       \n#> #####################################################\n#> \n#> MAP computed with tidybayes::mode_hdci()\n#> # A tibble: 1 × 6\n#>   p_skewed_b .lower .upper .width .point .interval\n#>        <dbl>  <dbl>  <dbl>  <dbl> <chr>  <chr>    \n#> 1       1.00  0.475      1   0.95 mode   hdci     \n#> #####################################################\n#> \n#> MAP computed with tidybayes::Mode()\n#> [1] 0.9995616\n#> #####################################################\n#> \n#> Mean & Median computed with mean() & median()\n#> # A tibble: 1 × 2\n#>    mean median\n#>   <dbl>  <dbl>\n#> 1 0.803  0.843\n```\n\n\n:::\n:::\n\n:::\n:::\n\nWe can now plot a graph to reproduce the left panel of the books Figure\n3.4 where we will see the three different measures of central tendency.\nI will compare the skewed (three 'W', three tosses) with the somewhat\nnormal version (six 'W', nine tosses).\n\n::: my-r-code\n::: my-r-code-header\n::: {#cnj-fig-left-panel-3-4-b}\n: Posterior density for skewed and symmetric distribution\n:::\n:::\n\n::: my-r-code-container\n::: panel-tabset\n###### 3W, n=3\n\n\n::: {.cell hash='03-sampling-the-imaginary_cache/html/fig-left-panel-3-4-skewed-b_c318b076e05ece78dea463aa246d2359'}\n\n```{.r .cell-code}\n## 1. bundle three types of estimates into a tibble. #######\npoint_estimates_b1 <-\n  dplyr::bind_rows(samples_skewed_b |> tidybayes::mean_qi(p_skewed_b),\n            samples_skewed_b |> tidybayes::median_qi(p_skewed_b),\n            samples_skewed_b |> tidybayes::mode_qi(p_skewed_b)) |> \n  dplyr::select(p_skewed_b, .point) |> \n\n## 2. create two columns to annotate the plot #######\n  dplyr::mutate(x = p_skewed_b + c(-.03, .03, -.03),\n       y = c(.0005, .0012, .002))\n\n## 3. plot #######\nsamples_skewed_b |> \n  ggplot2::ggplot(ggplot2::aes(x = p_skewed_b)) +\n  ggplot2::geom_area(ggplot2::aes(y = posterior_skewed_b),\n            fill = \"deepskyblue\") +\n  ggplot2::geom_vline(xintercept = point_estimates_b1$p_skewed_b) +\n  ggplot2::geom_text(data = point_estimates_b1,\n            ggplot2::aes(x = x, y = y, label = .point),\n            angle = 90) +\n  ggplot2::labs(x = \"proportion of water (p)\",\n       y = \"density\") +\n  ggplot2::theme(panel.grid = ggplot2::element_blank()) +\n  ggplot2::theme_bw()\n```\n\n::: {.cell-output-display}\n![Posterior distribution after observing 3 'water' in 3 tosses of the globe. Vertical lines show the locations of the mode, median, and mean. All three measures of central tendency differ because of the skewness of the distribution. Therefore each point implies a different loss function. ](03-sampling-the-imaginary_files/figure-html/fig-left-panel-3-4-skewed-b-1.png){#fig-left-panel-3-4-skewed-b width=672}\n:::\n:::\n\n\n###### 6W, n=9\n\n\n\n\n::: {.cell hash='03-sampling-the-imaginary_cache/html/fig-left-panel-3-4-sym-b2_6be90295c559eed1ee47d3ab0eef455f'}\n\n```{.r .cell-code}\n## 0. compute mode with different method\nmode2_b <- df_samples_b |>\n  dplyr::arrange(dplyr::desc(posterior_samples_b)) |> \n  dplyr::slice(1) |> \n  dplyr::rename(.point = prior_samples_b) |> \n  dplyr::select(samples_b, .point) |> \n  dplyr::mutate(.point = \"mode2\")\n\n## 1. bundle three types of estimates into a tibble ######\npoint_estimates_b2 <-\n  dplyr::bind_rows(df_samples_b |> tidybayes::mean_qi(samples_b),\n            df_samples_b |> tidybayes::median_qi(samples_b),\n            df_samples_b |> tidybayes::mode_qi(samples_b)) |> \n  dplyr::select(samples_b, .point) |> \n  dplyr::bind_rows(mode2_b) |>\n  \n## 2. create two columns to annotate the plot #######\n  dplyr::mutate(x = c(.55, .55, .75, .75),\n         y = c(.0006, .0011, .0016, .0021))\n\n## 3. plot ##########################################\ndf_samples_b |> \n  ggplot2::ggplot(ggplot2::aes(x = samples_b)) +\n  ggplot2::geom_area(ggplot2::aes(y = posterior_samples_b),\n           fill = \"deepskyblue\") +\n  ggplot2::geom_vline(xintercept = point_estimates_b2$samples_b) +\n  ggplot2::geom_text(data = point_estimates_b2,\n            ggplot2::aes(x = x, y = y, label = .point)) +\n  ggplot2::labs(x = \"proportion of water (p)\",\n       y = \"density\") +\n  ggplot2::theme(panel.grid = ggplot2::element_blank()) +\n  ggplot2::theme_bw() + \n\n## 4. annotation (arrows & text) ####################\n  ggplot2::geom_segment(\n    ggplot2::aes(x = 0.4, y = .0005, xend = point_estimates_b2$samples_b[[1]], yend = .0005),\n    arrow = grid::arrow(length = grid::unit(0.5, \"cm\"))) +\n  ggplot2::geom_segment(\n    ggplot2::aes(x = 0.4, y = .001, xend = point_estimates_b2$samples_b[[2]], yend = .001),\n    arrow = grid::arrow(length = grid::unit(0.5, \"cm\"))) +  \n  ggplot2::geom_segment(\n    ggplot2::aes(x = 0.85, y = .0015, xend = point_estimates_b2$samples_b[[3]], yend = .0015),\n    arrow = grid::arrow(length = grid::unit(0.5, \"cm\"))) +\n  ggplot2::geom_segment(\n    ggplot2::aes(x = 0.85, y = .002, xend = point_estimates_b2$samples_b[[4]], yend = .002),\n    arrow = grid::arrow(length = grid::unit(0.5, \"cm\"))\n)\n```\n\n::: {.cell-output-display}\n![Point estimates in the almost symmetrical distribution of 6 'water' in 9 tosses. Vertical lines show the locations of the mode, median, and mean. All three points are in a similar locatioon and have approximately the same loss function.](03-sampling-the-imaginary_files/figure-html/fig-left-panel-3-4-sym-b2-1.png){#fig-left-panel-3-4-sym-b2 width=672}\n:::\n:::\n\n\n::: my-watch-out\n::: my-watch-out-header\nMAP (mode) is not the highest point in the more symmetric version (6\n'W', n=9)\n:::\n\n::: my-watch-out-container\nI wounder if the calculation of the MAP of the somewhat symmetrical\nversion is correct, because the MAP or mode is not the highest value in\nthe distribution. In addition to calculate the mode with\n{**tidybayes**}, I have also used R code 3.14b from\n@cnj-point-estimates-b to compute MAP with\n`dplyr::arrange(dplyr::desc())`.\n\nIt turns out that there is difference: In contrast to {**tidybayes**}\narranging the data frame results in a MAP value (`mode2`) which is\nindeed the highest point of the distribution. I don't know how to\ninterpret this disparity.\n:::\n:::\n:::\n:::\n:::\n\n##### Loss function to support particular decisions\n\n::: my-r-code\n::: my-r-code-header\n::: {#cnj-expected-loss-b}\nb: Calculated expected loss for $p = 0.5$ with proportional and\nquadratic loss function\n:::\n:::\n\n::: my-r-code-container\n::: panel-tabset\n###### $d-p$\n\nThe absolute proportional loss $d-p$ for the decision $p = 0.5$ results\ninto the median.\n\n\n::: {.cell hash='03-sampling-the-imaginary_cache/html/expected-prop-loss-b_5b4df455a8cfc9620f5b334cd4283643'}\n\n```{.r .cell-code}\n## R code 3.17b weighted average loss ##################\nloss_avg_b <- d_skewed_b |> \n    dplyr::summarise(`expected loss` = \n               base::sum(posterior_skewed_b * base::abs(0.5 - p_grid_b)))\n\n## R code 3.18b for every possible value #############################\n\n## write function\nmake_loss_b <- function(our_d) {\n  d_skewed_b |> \n    dplyr::mutate(loss_b = posterior_skewed_b * base::abs(our_d - p_grid_b)) |> \n    dplyr::summarise(weighted_average_loss_b = base::sum(loss_b))\n}\n\n## calculate loss for all possible values \nglue::glue(\"Every possible loss values for decision 0.5 with proportional loss function\\n\")\n\nl_b <-\n  d_skewed_b |> \n  dplyr::select(p_grid_b) |> \n  dplyr::rename(decision_b = p_grid_b) |> \n  dplyr::mutate(weighted_average_loss_b = purrr::map(decision_b, make_loss_b)) |> \n  tidyr::unnest(weighted_average_loss_b) \nhead(l_b)\n\n## R code 3.19b minimized loss value #############################\n# this will help us find the x and y coordinates for the minimum value\nloss_min_b <-\n    l_b |> \n    dplyr::filter(weighted_average_loss_b == base::min(weighted_average_loss_b)) |> \n    base::as.numeric()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> Every possible loss values for decision 0.5 with proportional loss function\n#> # A tibble: 6 × 2\n#>   decision_b weighted_average_loss_b\n#>        <dbl>                   <dbl>\n#> 1    0                         0.800\n#> 2    0.00100                   0.799\n#> 3    0.00200                   0.798\n#> 4    0.00300                   0.797\n#> 5    0.00400                   0.796\n#> 6    0.00501                   0.795\n```\n\n\n:::\n:::\n\n\n**Results:**\n\n- Weighted average loss value = 0.3128752.\n- Parameter value that minimizes the loss = 0.8408408. This is the posterior median that we already have calculated in @cnj-point-estimates-b. Because of sampling variation it is not identical but pretty close (0.8428428 versus 0.8408408).\n\n###### $(d−p)^{2}$\n\nThe quadratic loss $(d−p)^{2}$ for the decision $p = 0.5$ suggests we\nshould use the mean.\n\n\n::: {.cell hash='03-sampling-the-imaginary_cache/html/expected-quad-loss-b_8aff1bdaad17476b29bf4fa07b034e99'}\n\n```{.r .cell-code}\n## R code 3.17b weighted average loss ##################\nloss_avg_b2 <- d_skewed_b |> \n    dplyr::summarise(`expected loss` = \n               base::sum(posterior_skewed_b * base::sqrt(abs(0.5 - p_grid_b))))\n\n## R code 3.18b for every possible value #############################\n# amend our loss function\n\nmake_loss2_b <- function(our_d2) {\n  d_skewed_b |> \n    dplyr::mutate(loss2_b = posterior_skewed_b * (our_d2 - p_grid_b)^2) |> \n    dplyr::summarise(weighted_average_loss2_b = base::sum(loss2_b))\n}\n\n\n# remake our `l` data\nglue::glue(\"Every possible loss values for decision 0.5 with quadratic loss function\\n\")\n\nl2_b <-\n    d_skewed_b |> \n    dplyr::select(p_grid_b) |> \n    dplyr::rename(decision2_b = p_grid_b) |> \n    dplyr::mutate(weighted_average_loss2_b = purrr::map(decision2_b, make_loss2_b)) |> \n    tidyr::unnest(weighted_average_loss2_b)\nhead(l2_b)\n\n## R code 3.19b minimized loss value #############################\n# update to the new minimum loss coordinates\n\n\nloss_min_b2 <-\n    l2_b |> \n    dplyr::filter(weighted_average_loss2_b == base::min(weighted_average_loss2_b)) |> \n    base::as.numeric()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> Every possible loss values for decision 0.5 with quadratic loss function\n#> # A tibble: 6 × 2\n#>   decision2_b weighted_average_loss2_b\n#>         <dbl>                    <dbl>\n#> 1     0                          0.667\n#> 2     0.00100                    0.666\n#> 3     0.00200                    0.664\n#> 4     0.00300                    0.663\n#> 5     0.00400                    0.661\n#> 6     0.00501                    0.659\n```\n\n\n:::\n:::\n\n\n**Results:**\n\n- Weighted average loss value = 0.5390867.\n- Parameter value that minimizes the loss = 0.8008008. This is the posterior mean that we already have calculated in @cnj-point-estimates-b. Because of sampling variation it is not identical but pretty close (0.8027632 versus 0.8008008).\n:::\n:::\n:::\n\nNow we're ready to reproduce the right panel of Figure 3.4., e.g.,\ndisplaying the the loss function and computing the minimum loss value.\nRemember: Different loss functions imply different point estimates.\n\n::: my-r-code\n::: my-r-code-header\n::: {#cnj-fig-prop-loss-b}\nb: Plot expected loss for $p = 0.5$ with proportional and quadratic loss\nfunction\n:::\n:::\n\n::: my-r-code-container\n::: panel-tabset\n###### $d-p$\n\nThe absolute proportional loss $d-p$ for the decision $p = 0.5$ results\ninto the median.\n\n\n::: {.cell hash='03-sampling-the-imaginary_cache/html/fig-prop-loss-b_53ed4faba78d5504d75206c9d397a84b'}\n\n```{.r .cell-code}\n## right panel figure 3.4 ########################\n\nl_b |>   \n  ggplot2::ggplot(ggplot2::aes(x = decision_b, y = weighted_average_loss_b)) +\n  ggplot2::geom_area(fill = \"deepskyblue\") +\n  ggplot2::geom_vline(xintercept = loss_min_b[1], color = \"black\", linetype = 3) +\n  ggplot2::geom_hline(yintercept = loss_min_b[2], color = \"black\", linetype = 3) +\n  ggplot2::ylab(\"expected proportional loss\") +\n  ggplot2::theme(panel.grid = ggplot2::element_blank()) +\n  ggplot2::theme_bw()\n```\n\n::: {.cell-output-display}\n![Expected loss under the rule that loss is proportional to absolute distance of decision (horizontal axis) from the true value. The point marks the value of `p` that minimizes the expected loss, the posterior median.](03-sampling-the-imaginary_files/figure-html/fig-prop-loss-b-1.png){#fig-prop-loss-b width=672}\n:::\n:::\n\n\nWe saved the exact minimum value as `loss_min_b[1]`, which is\n0.8408408. Within sampling error, this is the posterior median\nas depicted by our samples (0.8428428\nversus 0.8408408).\n\n###### $(d−p)^{2}$\n\nThe quadratic loss $(d−p)^{2}$ for the decision $p = 0.5$ suggests we\nshould use the mean.\n\n\n::: {.cell hash='03-sampling-the-imaginary_cache/html/fig-quad-loss-b_6cab62a00b7dc0e7d8cf5fb7536dff33'}\n\n```{.r .cell-code}\n# update the plot\nl2_b |>   \n  ggplot2::ggplot(ggplot2::aes(x = decision2_b, y = weighted_average_loss2_b)) +\n  ggplot2::geom_area(fill = \"deepskyblue\") +\n  ggplot2::geom_vline(xintercept = loss_min_b2[1], color = \"black\", linetype = 3) +\n  ggplot2::geom_hline(yintercept = loss_min_b2[2], color = \"black\", linetype = 3) +\n  ggplot2::ylab(\"expected proportional loss\") +\n  ggplot2::theme(panel.grid = ggplot2::element_blank()) +\n  ggplot2::theme_bw()\n```\n\n::: {.cell-output-display}\n![Expected loss under the rule that loss is quadratic to the distance of decision (horizontal axis) from the true value. The point marks the value of `p` that minimizes the expected loss, the posterior mean](03-sampling-the-imaginary_files/figure-html/fig-quad-loss-b-1.png){#fig-quad-loss-b width=672}\n:::\n:::\n\n\nBased on quadratic loss $(d−p)^{2}$, the exact minimum value is\n0.8008008. Within sampling error, this is the posterior mean of\nour samples (0.8027632 versus\n0.8008008).\n:::\n:::\n:::\n\n## Sampling to simulate prediction\n\n### ORIGINAL\n\n::: my-procedure\n::: my-procedure-header\n::: {#prp-ease-sim}\n: 5 Reasons to simulate implied observations\n:::\n:::\n\n::: my-procedure-container\n> \"Another common job for samples is to ease **simulation** of the\n> model's implied observations. Generating implied observations from a\n> model is useful for at least ~~four~~ five reasons.\" ([McElreath,\n> 2020, p. 61](zotero://select/groups/5243560/items/NFUEVASQ))\n> ([pdf](zotero://open-pdf/groups/5243560/items/CPFRPHX8?page=80&annotation=N8SBHXFN))\n\n1.  Model design\n2.  Model checking\n3.  Software validation\n4.  Research design\n5.  Forecasting\n\n> \"We will call such simulated data **dummy data**, to indicate that it\n> is a stand-in for actual data.\" ([McElreath, 2020, p.\n> 62](zotero://select/groups/5243560/items/NFUEVASQ))\n> ([pdf](zotero://open-pdf/groups/5243560/items/CPFRPHX8?page=81&annotation=EG7YYPVK))\n:::\n:::\n\n#### Dummy data\n\nLikelihood functions work in both directions:\n\n-   They help to infer the plausibility of each possible value of *p*.\n    \"With the globe tossing model, the <a class='glossary' title='Simulated data are called dummy data to indicate that it is a stand-in for actual data. (SR2, p.62)'>dummy data</a>\n    arises from a binomial likelihood:\" ([McElreath, 2020, p.\n    62](zotero://select/groups/5243560/items/NFUEVASQ))\n    ([pdf](zotero://open-pdf/groups/5243560/items/CPFRPHX8?page=81&annotation=5PLAWZ8J))\n-   They can be used to simulate the observations that the model\n    implies. \"You could use `base::sample()` to do this, but R provides\n    convenient sampling functions for all the ordinary probability\n    distributions, like the binomial.\" ([McElreath, 2020, p.\n    62](zotero://select/groups/5243560/items/NFUEVASQ))\n    ([pdf](zotero://open-pdf/groups/5243560/items/CPFRPHX8?page=81&annotation=W69A2SQI))\n\n> \"Given a realized observation, the likelihood function says how\n> plausible the observation is. And given only the parameters, the\n> likelihood defines a distribution of possible observations that we can\n> sample from, to simulate observation.\" ([McElreath, 2020, p.\n> 62](zotero://select/groups/5243560/items/NFUEVASQ))\n> ([pdf](zotero://open-pdf/groups/5243560/items/CPFRPHX8?page=81&annotation=PNGM8F8P))\n\n::: my-r-code\n::: my-r-code-header\n::: {#cnj-two-tosses-a}\na: Suppose $N = 2$, two tosses of the globe with $p = 0.7$\n:::\n:::\n\n::: my-r-code-container\n::: panel-tabset\n###### Probability\n\n\n::: {.cell hash='03-sampling-the-imaginary_cache/html/two-tosses-prob-a_61a4dce897a2167de7ba19a42c01a1ee'}\n\n```{.r .cell-code}\n## R code 3.20a #############################\n(\n  two_tosses_prob_a <- dbinom(0:2, size = 2, prob = 0.7)\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 0.09 0.42 0.49\n```\n\n\n:::\n:::\n\n\n**Interpretation of the observed result of two tosses with a probability\nof** $p = 0.7$\n\nWith $N = 2$ there are only three possibilities: 0, 1 or 2 water.\n\n-   9% chance of observing 0 water.\n-   42% chance of observing 1 water.\n-   49% chance of observing 2 water.\n\nWith different $p$ you will get a different result.\n\n###### Simulation\n\n\n::: {.cell hash='03-sampling-the-imaginary_cache/html/two-tosses-sim-a_a700de05292cfbdc024d1c755fd879a6'}\n\n```{.r .cell-code}\nbase::set.seed(3) # for reproducibility\n\n## R code 3.21a #############################\n(\n  two_tosses_sim_a <- rbinom(1, size = 2, prob = 0.7)\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 2\n```\n\n\n:::\n:::\n\n\n**Interpretation of the simulated result of two tosses with a\nprobability of** $p = 0.7$\n\nOne simulation (trial) consists with $N = 2$ of two simulated tosses:\n\n-   In our simulation (trial) of two simulated tosses $N = 2$ we got\n    2 water.\n\nWithout the `base::set.seed()` function the result will change. Try it.\n:::\n:::\n:::\n\nWith `rbinom()` you can also generate more than one simulation (trial)\nat a time.\n\n::: my-r-code\n::: my-r-code-header\n::: {#cnj-several-sims}\na: Using `rbinom()` to simulate two tosses to generate 10 and 100,000\ndummy observations\n:::\n:::\n\n::: my-r-code-container\n::: panel-tabset\n###### 10 trials\n\n\n::: {.cell hash='03-sampling-the-imaginary_cache/html/simulate-10-obs-a_26d624bfea26b655f982df3c668822ca'}\n\n```{.r .cell-code}\nbase::set.seed(3)\n## R code 3.22a #############################\nrbinom(10, size = 2, prob = 0.7)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>  [1] 2 1 2 2 1 1 2 2 1 1\n```\n\n\n:::\n:::\n\n\n###### 1e5 trials\n\n\n::: {.cell hash='03-sampling-the-imaginary_cache/html/simulate-1e5-obs-a_255320d1089287a289ef642ddb56a48e'}\n\n```{.r .cell-code}\nbase::set.seed(3)\n## R code 3.23a #############################\ndummy_w_a <- rbinom(1e5, size = 2, prob = 0.7)\ntable(dummy_w_a) / 1e5\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> dummy_w_a\n#>       0       1       2 \n#> 0.09000 0.42051 0.48949\n```\n\n\n:::\n:::\n\n:::\n:::\n:::\n\nNow let's simulate the same amount of tosses (sample size = 9) as we\nhave used previously. I will provide two kinds of R graphs: One for\n`rethinking::simplehist()` as in the book and one using base R with\n`graphics::hist()`.\n\n::: my-r-code\n::: my-r-code-header\n::: {#cnj-9-toss-fig-a}\na: Distribution of simulated sample observations from 9 tosses of the\nglobe\n:::\n:::\n\n::: my-r-code-container\n::: panel-tabset\n###### Base R\n\n\n::: {.cell hash='03-sampling-the-imaginary_cache/html/fig-plot-hist-figure-3.5-a_e187b22823179ca43f83e26f9c9c2362'}\n\n```{.r .cell-code}\nbase::set.seed(3)\n## R code 3.24a with hist() ##############\ndummy_w_a <- rbinom(1e5, size = 9, prob = 0.7)\nhist(dummy_w_a, xlab = \"dummy water count\")\n```\n\n::: {.cell-output-display}\n![Distribution of simulated sample observations from 9 tosses of the globe. These samples assume the proportion of water is 0.7. The plot uses the base R `hist()` function](03-sampling-the-imaginary_files/figure-html/fig-plot-hist-figure-3.5-a-1.png){#fig-plot-hist-figure-3.5-a width=672}\n:::\n:::\n\n\n###### Rethinking\n\n\n::: {.cell hash='03-sampling-the-imaginary_cache/html/fig-plot-simplehist-figure-3.5-a_895cb63e2ef1282ac32702c4d3098b43'}\n\n```{.r .cell-code}\nbase::set.seed(3)\n## R code 3.24a with simplehist() #############################\ndummy_w_a <- stats::rbinom(1e5, size = 9, prob = 0.7)\nrethinking::simplehist(dummy_w_a, xlab = \"dummy water count\")\n```\n\n::: {.cell-output-display}\n![Distribution of simulated sample observations from 9 tosses of the globe. These samples assume the proportion of water is 0.7. the plot uses the `rethinking::simplehist()``` function](03-sampling-the-imaginary_files/figure-html/fig-plot-simplehist-figure-3.5-a-1.png){#fig-plot-simplehist-figure-3.5-a width=672}\n:::\n:::\n\n:::\n\nNote that in our example using `base::set.seed(3)` the simulation does\nnot generate the water in its true proportion of $0.7$.\n\n> \"That's the nature of observation: There is a one-to-many relationship\n> between data and data-generating processes. You should \\[delete the\n> `base::set.seed()` line and\\] experiment with sample size, the `size`\n> input in the code above, as well as the `prob`, to see how the\n> distribution of simulated samples changes shape and location.\"\n> ([McElreath, 2020, p.\n> 63](zotero://select/groups/5243560/items/NFUEVASQ))\n> ([pdf](zotero://open-pdf/groups/5243560/items/CPFRPHX8?page=82&annotation=2NRZ2EV9))\n:::\n:::\n\n::: my-important\n::: my-important-header\nSampling distributions versus Samples drawn from the posterior\n:::\n\n::: my-important-container\n> \"Many readers will already have seen simulated observations.\n> <a class='glossary' title='“The most commonly used measure of the spread of a set of observations. Equal to the square root of the variance.” (CDS, p. 409)'>Sampling distributions</a> are\n> the foundation of common non-Bayesian statistical traditions. In those\n> approaches, inference about parameters is made through the sampling\n> distribution. In this book, inference about parameters is never done\n> directly through a sampling distribution. The posterior distribution\n> is not sampled, but deduced logically. Then samples can be drawn from\n> the posterior, as earlier in this chapter, to aid in inference. In\n> neither case is 'sampling' a physical act. In both cases, it's just a\n> mathematical device and produces only *small world* (@sec-chap02)\n> numbers.\" ([McElreath, 2020, p.\n> 63](zotero://select/groups/5243560/items/NFUEVASQ))\n> ([pdf](zotero://open-pdf/groups/5243560/items/CPFRPHX8?page=82&annotation=C7QLRFPI))\n:::\n:::\n\n#### Model checking\n\nTwo main purposes:\n\n1.  Checking if software is working correctly\n2.  Evaluation the adequacy of the model\n\n> \"All that is required is averaging over the posterior density for $p$,\n> while computing the predictions. For each possible value of the\n> parameter $p$, there is an implied distribution of outcomes. So if you\n> were to compute the sampling distribution of outcomes at each value of\n> $p$, then you could average all of these prediction distributions\n> together, using the posterior probabilities of each value of $p$, to\n> get a <a class='glossary' title='An approach to assessing model fit. It is the distribution for future predicted data based on the data you have already seen. Measures of discrepancy between the estimated model and the data are constructed and their posterior predictive distribution compared to the discrepancy observed for the dataset. (CDS, p. 334)'>posterior predictive distribution</a>.\" ([McElreath,\n> 2020, p. 65](zotero://select/groups/5243560/items/NFUEVASQ))\n> ([pdf](zotero://open-pdf/groups/5243560/items/CPFRPHX8?page=84&annotation=EZT523XH))\n\n::: my-procedure\n::: my-procedure-header\n::: {#prp-post-pred-sim-a}\na: How to generate the <a class='glossary' title='An approach to assessing model fit. It is the distribution for future predicted data based on the data you have already seen. Measures of discrepancy between the estimated model and the data are constructed and their posterior predictive distribution compared to the discrepancy observed for the dataset. (CDS, p. 334)'>posterior predictive distribution</a>\n:::\n:::\n\n::: my-procedure-container\n1.  Use `rbinom()` to generate random binomial samples.\n2.  Use as `prob` value not a single value but samples from the\n    posterior\n\nI will not reproduce Figure 3.6 in the upcoming section. The complex\nprocedure to plot the graph does not add much understanding in Bayesian\nstatistics. But the content of the picture itself is very important to\nunderstand how the posterior predictive distribution is generated.\n\n------------------------------------------------------------------------\n\n![\"Simulating predictions from the total posterior. Top: The familiar\nposterior distribution for the globe tossing data. Ten example parameter\nvalues are marked by the vertical lines. Values with greater posterior\nprobability indicated by thicker lines. Middle row: Each of the ten\nparameter values implies a unique sampling distribution of predictions.\nBottom: Combining simulated observation distributions for all parameter\nvalues (not just the ten shown), each weighted by its posterior\nprobability, produces the posterior predictive distribution. This\ndistribution propagates uncertainty about parameter to uncertainty about\nprediction.\" ([McElreath, 2020, p.\n65](zotero://select/groups/5243560/items/NFUEVASQ))\n([pdf](zotero://open-pdf/groups/5243560/items/CPFRPHX8?page=84&annotation=ZBMIA85F))](img/SR2-fig3_6.png){#fig-3-6\nfig-alt=\"Top panel shows the posterior probability, middle panel the sampling distribution and the bottom panel the posterior predictive distribution\"\nfig-align=\"center\" width=\"90%\"}\n:::\n:::\n\nWe will generates 10,000 (1e4) simulated predictions of 9 globe tosses\n(size = 9)\n\n::: my-r-code\n::: my-r-code-header\n::: {#cnj-fig-post-pred-sim-a}\na: Simulate predicted observations for a single value ($p = 0.6$) and\nwith samples of the posterior\n:::\n:::\n\n::: my-r-code-container\nGenerating 10,000 (1e4) simulated predictions of 9 globe tosses (size =\n9).\n\n::: panel-tabset\n###### p = single value of 0.6\n\n\n::: {.cell hash='03-sampling-the-imaginary_cache/html/fig-post-pred-sim-a1_fef559ac8ef2a307765bd531fcb375d8'}\n\n```{.r .cell-code}\nbase::set.seed(3)\n## R code 3.25a #############################\nw_a1 <- rbinom(1e4, size = 9, prob = 0.6)\nrethinking::simplehist(w_a1)\n```\n\n::: {.cell-output-display}\n![Simulate predicted observations for a single value p value of 0.6](03-sampling-the-imaginary_files/figure-html/fig-post-pred-sim-a1-1.png){#fig-post-pred-sim-a1 width=672}\n:::\n:::\n\n\nThe predictions are stored as counts of water, so the theoretical\nminimum is zero and the theoretical maximum is nine. Although our fix\n`prob` value = 0.6 the samples show 5 as the mode of the randomly\ngenerated distribution.\n\n###### p = posterior samples\n\n\n::: {.cell hash='03-sampling-the-imaginary_cache/html/fig-post-pred-sim-a2_f8f28078420f60fd4ccc9814bb41fc9d'}\n\n```{.r .cell-code}\nbase::set.seed(3)\n## R code 3.26a #############################\nw_a2 <- rbinom(1e4, size = 9, prob = samples_a)\nrethinking::simplehist(w_a2)\n```\n\n::: {.cell-output-display}\n![Simulate predicted observations with samples of the posterior](03-sampling-the-imaginary_files/figure-html/fig-post-pred-sim-a2-1.png){#fig-post-pred-sim-a2 width=672}\n:::\n:::\n\n\nThe code propagate parameter uncertainty into the predictions by\nreplacing a fixed `prob` value by the vector `samples_a`. The symbol\n`samples_a` is the same list of random samples from the posterior\ndistribution that we have calculated in @cnj-sample-globe-tossing and\nused in previous sections.\n:::\n:::\n:::\n\n> \"For each sampled value, a random binomial observation is generated.\n> Since the sampled values appear in proportion to their posterior\n> probabilities, the resulting simulated observations are averaged over\n> the posterior. You can manipulate these simulated observations just\n> like you manipulate samples from the posterior---you can compute\n> intervals and point statistics using the same procedures.\"\n> ([McElreath, 2020, p.\n> 66](zotero://select/groups/5243560/items/NFUEVASQ))\n> ([pdf](zotero://open-pdf/groups/5243560/items/CPFRPHX8?page=85&annotation=BVUDPY9U))\n\nBut @fig-post-pred-sim-a2 just predicts the posterior distribution as\nour model sees the data. To evaluate the adequacy of the model for\ncertain purposes it is important to investigate it under different point\nof views. McElreath proposes two look at the data in additional two\nways:\n\n1.  Plot the distribution of the longest run of either water or land.\n2.  Plot the distribution of the number of switches from water to land\n    and reverse.\n\nThe calculation and reproduction of Figure 3.7 is demonstrated in the\nnext tidyverse section.\n\n### TIDYVERSE\n\n#### Dummy data\n\n::: my-r-code\n::: my-r-code-header\n::: {#cnj-two-tosses-b}\nb: Suppose $N = 2$, two tosses of the globe with $p = 0.7$\n:::\n:::\n\n::: my-r-code-container\n::: panel-tabset\n###### Probability\n\n\n::: {.cell hash='03-sampling-the-imaginary_cache/html/two-tosses-prob-b_7aa98d5f03a1e968ecee916ef930a106'}\n\n```{.r .cell-code}\n## R code 3.20b ######################\ntibble::tibble(n      = 2,\n       `p(w)` = .7,\n       w      = 0:n) |> \n  dplyr::mutate(density = stats::dbinom(w, size = n, prob = `p(w)`))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> # A tibble: 3 × 4\n#>       n `p(w)`     w density\n#>   <dbl>  <dbl> <int>   <dbl>\n#> 1     2    0.7     0    0.09\n#> 2     2    0.7     1    0.42\n#> 3     2    0.7     2    0.49\n```\n\n\n:::\n:::\n\n\n###### Simulation\n\n\n::: {.cell hash='03-sampling-the-imaginary_cache/html/two-tosses-sim-b_e1c074c13d1b5a524ae42dafb7195d07'}\n\n```{.r .cell-code}\n## R code 3.21b = 3.21a ######################\nbase::set.seed(3)\nstats::rbinom(1, size = 2, prob = .7)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 2\n```\n\n\n:::\n:::\n\n:::\n\nCompare the results with the calculation in @cnj-two-tosses-a.\n:::\n:::\n\n::: my-r-code\n::: my-r-code-header\n<div>\n\nb: Using `stats::rbinom()` to simulate two tosses to generate 10 and\n100,000 dummy observations\n\n</div>\n:::\n\n::: my-r-code-container\n::: panel-tabset\n###### 10 trials\n\n\n::: {.cell hash='03-sampling-the-imaginary_cache/html/simulate-10-obs-b_4f213b266af8debecc337b17dd0d9e7d'}\n\n```{.r .cell-code}\nbase::set.seed(3)\n## R code 3.22b = 3.22a #############################\nstats::rbinom(10, size = 2, prob = 0.7)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>  [1] 2 1 2 2 1 1 2 2 1 1\n```\n\n\n:::\n:::\n\n\n###### 1e5 trials\n\n\n::: {.cell hash='03-sampling-the-imaginary_cache/html/simulate-1e5-obs-b_77ef52a215a11ed0e99084ab3d25ba15'}\n\n```{.r .cell-code}\n## R code 3.23b ########################\nn_draws_b <- 1e5\nbase::set.seed(3)\ndummy_w_b <- tibble::tibble(draws = stats::rbinom(n_draws_b, size = 2, prob = .7)) \n\ndummy_w_b |> \n    dplyr::count(draws) |> \n    dplyr::mutate(proportion = n / base::nrow(dummy_w_b))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> # A tibble: 3 × 3\n#>   draws     n proportion\n#>   <int> <int>      <dbl>\n#> 1     0  9000      0.09 \n#> 2     1 42051      0.421\n#> 3     2 48949      0.489\n```\n\n\n:::\n:::\n\n:::\n:::\n:::\n\nThe simulation updated to $n=9$ and plotting the tidyverse version of\nFigure 3.5.\n\n::: my-r-code\n::: my-r-code-header\n::: {#cnj-9-toss-fig-b}\nb: Distribution of simulated sample observations from 9 tosses of the\nglobe\n:::\n:::\n\n::: my-r-code-container\n\n::: {.cell hash='03-sampling-the-imaginary_cache/html/fig-plot-ggplot2-figure-3.5-b_3111651416befc07f6843a34db938e02'}\n\n```{.r .cell-code}\n## R code 3.24b with ggplot2 #########################\nn_draws_b <- 1e5\n\nbase::set.seed(3)\ndummy_w2_b <- tibble::tibble(draws = stats::rbinom(n_draws_b, size = 9, prob = .7))\n\np1 <- dummy_w2_b |> \n    ggplot2::ggplot(ggplot2::aes(x = draws)) + \n    ggplot2::geom_histogram(binwidth = 1, center = 0,\n                 fill = \"deepskyblue\", color = \"black\", \n                 linewidth = 1/10) +\n    # breaks = 0:10 * 2 = equivalent in Kurz's versions:  breaks = 0:4 * 2\n    ggplot2::scale_x_continuous(\"dummy water count\", breaks = 0:10 * 2) +\n    ggplot2::ylab(\"frequency\") +\n    ggplot2::coord_cartesian(xlim = c(0, 9)) +\n    ggplot2::theme(panel.grid = ggplot2::element_blank()) + \n    ggplot2::theme_bw()\n\np2 <- dummy_w2_b |> \n    ggplot2::ggplot(ggplot2::aes(x = draws)) + \n    ggplot2::geom_histogram(binwidth = 1, center = 0,\n                 fill = \"deepskyblue\", color = \"black\", \n                 linewidth = 1/10) +\n    ## breaks = 0:10 * 2 = equivalent in Kurz's versions:  breaks = 0:4 * 2\n    ## I decided to set a break at each of the draws: breaks = 0:9 * 1\n    ggplot2::scale_x_continuous(\"dummy water count\", breaks = 0:9 * 1) +\n    ggplot2::ylab(\"frequency\") +\n    ## I did not zoom into the graph because doesn't look so nice\n    ## for instance the last line in Kurz’ version is not visible\n    # coord_cartesian(xlim = c(0, 9)) +\n    ggplot2::theme(panel.grid = ggplot2::element_blank()) +\n    ggplot2::theme_bw()\n\nlibrary(patchwork)\np1 + p2\n```\n\n::: {.cell-output-display}\n![Distribution of simulated sample observations from 9 tosses of the globe. These samples assume the proportion of water is 0.7. The plot uses the {**ggplot2**} functions. The left panel is Kurz's original, the right one is my version slightly changed.](03-sampling-the-imaginary_files/figure-html/fig-plot-ggplot2-figure-3.5-b-1.png){#fig-plot-ggplot2-figure-3.5-b width=672}\n:::\n:::\n\n:::\n:::\n\nMcElreath suggested to play around with different values of `size` and\n`prob`. But instead of reproducing all codes block introduced by Kurz, I\nwill just replicate the first chunk, because it has some interesting and\n(for me) unfamiliar functions.\n\n::: my-r-code\n::: my-r-code-header\n::: {#cnj-sim-9-cond}\nb: Simulated sample observations, using different sizes and\nprobabilities\n:::\n:::\n\n::: my-r-code-container\n::: panel-tabset\n###### Simulation\n\n\n::: {.cell hash='03-sampling-the-imaginary_cache/html/simulate-9-conditions_9c2c04f51c55c50bfede1c4a4b83798b'}\n\n```{.r .cell-code}\nn_draws <- 1e5\nsimulate_binom <- function(n, probability) {\n  base::set.seed(3)\n  stats::rbinom(n_draws, size = n, prob = probability) \n}\n\nd9_b <-\n  tidyr::crossing(n9_b           = c(3, 6, 9),\n           probability9_b = c(.3, .6, .9)) |> \n  dplyr::mutate(draws9_b = purrr::map2(n9_b, probability9_b, simulate_binom)) |> \n  dplyr::ungroup() |> \n  dplyr::mutate(n           = stringr::str_c(\"n = \", n9_b),\n         probability = stringr::str_c(\"p = \", probability9_b)) |> \n  tidyr::unnest(draws9_b)\n\nd9_b |> \n    dplyr::slice_sample(n = 10) |> \n    dplyr::arrange(n9_b)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> # A tibble: 10 × 5\n#>     n9_b probability9_b draws9_b n     probability\n#>    <dbl>          <dbl>    <int> <chr> <chr>      \n#>  1     3            0.3        2 n = 3 p = 0.3    \n#>  2     3            0.9        3 n = 3 p = 0.9    \n#>  3     3            0.9        3 n = 3 p = 0.9    \n#>  4     3            0.9        3 n = 3 p = 0.9    \n#>  5     3            0.6        3 n = 3 p = 0.6    \n#>  6     6            0.9        5 n = 6 p = 0.9    \n#>  7     6            0.9        5 n = 6 p = 0.9    \n#>  8     6            0.6        3 n = 6 p = 0.6    \n#>  9     9            0.6        7 n = 9 p = 0.6    \n#> 10     9            0.3        3 n = 9 p = 0.3\n```\n\n\n:::\n:::\n\n\n::: my-watch-out\n::: my-watch-out-header\nUsing `tidyr::crossing()` and `tidyr::unnest()`\n:::\n\n::: my-watch-out-container\nI am still not very experienced with `tidyr::crossing()` and\n`tidyr::unnest()`:\n\n-   **`tidyr::crossing()`** is a wrapper around `tidyr::expand_grid()`\n    (not to confuse with `base::expand.grid()`) and therefore creates a\n    tibble from all combination of inputs. In addition to\n    `tidyr::expand_grid()` it de-duplicates and sorts its input.\n-   **`tidyr::unnest()`** expands a list-column containing data frames\n    into row and columns. In the above case `purrr::map2()` returns a\n    list and stores the data in `draws9_b`.\n\nInstead of `utils::head()` I used `dplyr::slice_sample()` and ordered\nthe result by the first column. I think this will get a better glimpse\non the data as just the first 6 rows.\n:::\n:::\n\n###### Plot\n\n\n::: {.cell hash='03-sampling-the-imaginary_cache/html/fig-sim-plot-9-cond-b_e5c8c06b2d3877fd887d1e5c326b45d9'}\n\n```{.r .cell-code}\nd9_b |> \n  ggplot2::ggplot(ggplot2::aes(x = draws9_b)) +\n  ggplot2::geom_histogram(binwidth = 1, center = 0,\n                 fill = \"deepskyblue\", color = \"white\", linewidth = 1/10) +\n  ggplot2::scale_x_continuous(\"dummy water count\", breaks = 0:4 * 2) +\n  ggplot2::ylab(\"frequency\") +\n  ggplot2::coord_cartesian(xlim = c(0, 9)) +\n  ggplot2::theme(panel.grid = ggplot2::element_blank()) +\n  ggplot2::theme_bw() +\n  ggplot2::facet_grid(n9_b ~ probability9_b)\n```\n\n::: {.cell-output-display}\n![](03-sampling-the-imaginary_files/figure-html/fig-sim-plot-9-cond-b-1.png){#fig-sim-plot-9-cond-b width=672}\n:::\n:::\n\n:::\n:::\n:::\n\n#### Model checking\n\n::: my-resource\n::: my-resource-header\nChecking if the software works correctly\n:::\n\n::: my-resource-container\nOn software checking Kurz refers to some material, that is too special\nat the moment for me. I will it include here, even if I had not read it.\nMaybe I will come later here again and pick up these resources when I\nhave more experiences with Bayesian statistics and the necessary tools.\n\n-   [Esther Williams in the Harold Holt Memorial Swimming\n    Pool](https://youtu.be/pKZLJPrZLhU?t=26285) by [Dan\n    Simpson](https://twitter.com/dan_p_simpson)\n-   [Visualisation in Bayesian\n    workflow](https://www.youtube.com/watch?v=E8vdXoJId8M), YouTube\n    video lecture at the Royal Statistics Society by Jonah Gabry &\n    Daniel Simpson\n-   [Maybe it's time to let the old ways die; or We broke R-hat so now\n    we have to fix\n    it](https://statmodeling.stat.columbia.edu/2019/03/19/maybe-its-time-to-let-the-old-ways-die-or-we-broke-r-hat-so-now-we-have-to-fix-it/),\n    blog post by Daniel Simpson\n-   Vehtari, A., Gelman, A., Simpson, D., Carpenter, B., & Bürkner,\n    P.-C. (2021). Rank-normalization, folding, and localization: An\n    improved $\\widehat{R}$ for assessing convergence of MCMC. Bayesian\n    Analysis, 16(2). https://doi.org/10.1214/20-BA1221\n:::\n:::\n\nThere are three computing steps to reproduce the three levels of Figure\n3.6 copied here as @fig-3-6.\n\n1.  Posterior probability (top level)\n2.  Sampling distributions for nine values (0.1-0.9) (middle level)\n3.  Posterior predictive distribution (bottom level)\n\n::: my-r-code\n::: my-r-code-header\n::: {#cnj-fig-3-6-top}\nb: Posterior probability\n:::\n:::\n\n::: my-r-code-container\n::: panel-tabset\n###### Top\n\n**Posterior probability**\n\n\n::: {.cell hash='03-sampling-the-imaginary_cache/html/fig-repr-figure-3.6-top-b_2ea15639b16c7ee22557b31af15bc721'}\n\n```{.r .cell-code}\n## data wrangling ####################\nn2_b <- 1001L\nn_success <- 6L\nn_trials  <- 9L\n\nd2_b <-\n  tibble::tibble(p_grid2_b = base::seq(from = 0, to = 1, length.out = n2_b),\n         # note we're still using a flat uniform prior\n         prior2_b  = 1) |> \n  dplyr::mutate(likelihood2_b = \n                stats::dbinom(n_success, size = n_trials, prob = p_grid2_b)) |> \n  dplyr::mutate(posterior2_b = \n                (likelihood2_b * prior2_b) / sum(likelihood2_b * prior2_b))\nhead(d2_b)\n\n\n## plot ##############################\nd2_b |> \n  ggplot2::ggplot(ggplot2::aes(x = p_grid2_b, y = posterior2_b)) +\n  ggplot2::geom_area(color = \"deepskyblue\", fill = \"deepskyblue\") +\n  ggplot2::geom_segment(data = d2_b |>   \n     dplyr::filter(p_grid2_b %in% \n         c(base::seq(from = .1, to = .9, by = .1), 3 / 10)),\n     ## Note how we Wweight the widths of the vertical lines \n     ## by the posterior density `posterior2_b`\n         ggplot2::aes(xend = p_grid2_b, yend = 0, linewidth = posterior2_b),\n         color = \"black\", show.legend = F) +\n  ggplot2::geom_point(data = d2_b |>  \n     dplyr::filter(p_grid2_b %in% \n         c(base::seq(from = .1, to = .9, by = .1), 3 / 10))) +\n  ggplot2::annotate(geom = \"text\", \n         x = .08, y = .0025,\n         label = \"Posterior probability\") +\n  ggplot2::scale_linewidth_continuous(range = c(0, 1)) +\n  ggplot2::scale_x_continuous(\"probability of water\", breaks = 0:10 / 10) +\n  ggplot2::scale_y_continuous(NULL, breaks = NULL) +\n  ggplot2::theme(panel.grid = ggplot2::element_blank()) +\n  ggplot2::theme()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> # A tibble: 6 × 4\n#>   p_grid2_b prior2_b likelihood2_b posterior2_b\n#>       <dbl>    <dbl>         <dbl>        <dbl>\n#> 1     0            1      0            0       \n#> 2     0.001        1      8.37e-17     8.37e-19\n#> 3     0.002        1      5.34e-15     5.34e-17\n#> 4     0.003        1      6.07e-14     6.07e-16\n#> 5     0.004        1      3.40e-13     3.40e-15\n#> 6     0.005        1      1.29e-12     1.29e-14\n```\n\n\n:::\n\n::: {.cell-output-display}\n![Reproduction of the top part of figure 3.6](03-sampling-the-imaginary_files/figure-html/fig-repr-figure-3.6-top-b-1.png){#fig-repr-figure-3.6-top-b width=672}\n:::\n:::\n\n\nAt first I thought I do not need to refresh the original grid\napproximation from @cnj-grid-globe-tossing-b as I have it stored it with\nthe unique name `d_b`. But it turned out that the above code with\n`n_grid_b = 1000L` does not work, because it draws no vertical lines by\nthe posterior density. Instead one has to sample 1001 times.\n\nI noticed that with most sample numbers the plot does not work\ncorrectly. It worked with 1071. The sequence 1011, 1021, 1031, 1041,\n1051, 1061 misses just one vertical line at $p = 0.7$ An exception is\n1041, which misses $p = 0.6$. I do not know why this happens.\n\n###### Middle\n\n\n::: {.cell hash='03-sampling-the-imaginary_cache/html/fig-repr-figure-3.6-middle-b_a3e1d786394ab25dd7dc939dd50b2d1a'}\n\n```{.r .cell-code}\n## data wrangling #####################\nn_draws_b <- 1e5\n\nsimulate_binom <- function(probability) {\n  base::set.seed(3)\n  stats::rbinom(n_draws_b, size = 9, prob = probability) \n}\n\nd_small_b <-\n  tibble::tibble(probability = base::seq(from = .1, to = .9, by = .1)) |> \n  dplyr::mutate(draws = purrr::map(probability, simulate_binom)) |>  \n  tidyr::unnest(draws) |> \n  dplyr::mutate(label = stringr::str_c(\"p = \", probability))\n\nutils::head(d_small_b)\n\n## plot ###############################\nd_small_b |>\n  ggplot2::ggplot(ggplot2::aes(x = draws)) +\n  ggplot2::geom_histogram(binwidth = 1, center = 0, color = \"black\",\n                 fill = \"deepskyblue\", linewidth = 1/10) +\n  ggplot2::scale_x_continuous(NULL, breaks = 0:3 * 3) +\n  ggplot2::scale_y_continuous(NULL, breaks = NULL) +\n  ggplot2::labs(subtitle = \"Sampling distributions\") +\n  ggplot2::coord_cartesian(xlim = c(0, 9)) +\n  ggplot2::theme(panel.grid = ggplot2::element_blank()) +\n  ggplot2::theme_bw() +\n  ggplot2::facet_wrap(~ label, ncol = 9)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> # A tibble: 6 × 3\n#>   probability draws label  \n#>         <dbl> <int> <chr>  \n#> 1         0.1     0 p = 0.1\n#> 2         0.1     2 p = 0.1\n#> 3         0.1     0 p = 0.1\n#> 4         0.1     0 p = 0.1\n#> 5         0.1     1 p = 0.1\n#> 6         0.1     1 p = 0.1\n```\n\n\n:::\n\n::: {.cell-output-display}\n![Reproduction of the middle part of figure 3.6](03-sampling-the-imaginary_files/figure-html/fig-repr-figure-3.6-middle-b-1.png){#fig-repr-figure-3.6-middle-b width=672}\n:::\n:::\n\n\n###### Bottom\n\n\n::: {.cell hash='03-sampling-the-imaginary_cache/html/fig-repr-figure-3.6-bottom-b_43d63b3e802a692864e9e1a2922ea2a8'}\n\n```{.r .cell-code}\n## data wrangling ########################################\n# how many samples would you like?\nn_samples_b <- 1e4\n\n# make it reproducible\nbase::set.seed(3)\n\nd2_samples_b <-\n  d2_b |> \n  dplyr::slice_sample(n = n_samples_b, weight_by = posterior2_b, replace = T)  |>  \n  dplyr::mutate(w = purrr::map_dbl(p_grid2_b, stats::rbinom, n = 1, size = 9))\n\ndplyr::glimpse(d2_samples_b)\n\n## plot ###################################\nd2_samples_b |> \n  ggplot2::ggplot(ggplot2::aes(x = w)) +\n  ggplot2::geom_histogram(binwidth = 1, center = 0, color = \"black\",\n                 fill = \"deepskyblue\", linewidth = 1/10) +\n  ggplot2::scale_x_continuous(\"number of water samples\",\n                     breaks = 0:3 * 3) +\n  ggplot2::scale_y_continuous(NULL, breaks = NULL) +\n  ggplot2::ggtitle(\"Posterior predictive distribution\") +\n  ggplot2::coord_cartesian(xlim = c(0, 9),\n                  ylim = c(0, 3000)) +\n  ggplot2::theme(panel.grid = ggplot2::element_blank()) +\n  ggplot2::theme_bw()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> Rows: 10,000\n#> Columns: 5\n#> $ p_grid2_b     <dbl> 0.564, 0.651, 0.487, 0.592, 0.596, 0.787, 0.727, 0.490, …\n#> $ prior2_b      <dbl> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,…\n#> $ likelihood2_b <dbl> 0.22408531, 0.27179502, 0.15128823, 0.24557832, 0.248256…\n#> $ posterior2_b  <dbl> 0.0022408531, 0.0027179502, 0.0015128823, 0.0024557832, …\n#> $ w             <dbl> 4, 7, 3, 3, 7, 6, 8, 2, 6, 4, 5, 5, 8, 6, 4, 6, 8, 2, 6,…\n```\n\n\n:::\n\n::: {.cell-output-display}\n![Reproduction of the bottom part of figure 3.6](03-sampling-the-imaginary_files/figure-html/fig-repr-figure-3.6-bottom-b-1.png){#fig-repr-figure-3.6-bottom-b width=672}\n:::\n:::\n\n:::\n:::\n:::\n\nIn Figure 3.7, McElreath checked the adequacy of the model with\n\n(a) the longest sequence of the sample values and\n(b) number of switches between water and land.\n\nBut he didn't show who to calculate and produce his Figure 3.7. To\ncompute these alternative views and replicate the graph Kurz used the\n(for me until now unknown) `base::rle()` function in a brilliant manner.\nBefore we replicate his computation let's look more into the details of\n`base::rle()`\n\n::: my-r-code\n::: my-r-code-header\n::: {#cnj-rle-function}\nb: How the `base::rle()` function works for checking our model\n:::\n:::\n\n::: my-r-code-container\n\n::: {.cell hash='03-sampling-the-imaginary_cache/html/rle-function_f5870f19a251945ee34a5ee4118b9a44'}\n\n```{.r .cell-code}\ntosses <- c(\"w\", \"l\", \"w\", \"w\", \"w\", \"l\", \"w\", \"l\", \"w\")\nbase::rle(tosses)\n\n## In the left panel of Figure 3.7 we are interested in maximal length\nrle(tosses)$lengths  |>  max()\n\n## In the right panel of Figure 3.7 we are interested in maximal switches\nrle(tosses)$lengths |>  length() - 1\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> Run Length Encoding\n#>   lengths: int [1:7] 1 1 3 1 1 1 1\n#>   values : chr [1:7] \"w\" \"l\" \"w\" \"l\" \"w\" \"l\" \"w\"\n#> [1] 3\n#> [1] 6\n```\n\n\n:::\n:::\n\n\nThe observed events in our globe tossing example are:\n`w,l,w,w,w,l,w,l,w`. The maximal length of consecutive water events is:\n`rle(tosses)$lengths  |>  max()` = 3.\n\nBecause `rle()` aggregated the consecutive length of water and land we\ncan use this result as the maximum length of switches between water and\nland: `rle(tosses)$lengths |>  length() - 1` =\n6\n\n::: my-typo\n::: my-typo-header\nDifferent observations versus switches\n:::\n\n::: my-typo-container\nI think there is a small miscalculation in Kurz' text: The number of\nswitches is the length of different observation minus one. There are 7\ndifferent observation but only 6 switches. This also conforms to the\nbook.\n:::\n:::\n:::\n:::\n\nNow we will follow Kurz' procedure of calculating and plotting Figure\n3.7.\n\n::: my-procedure\n::: my-procedure-header\n::: {#prp-rle-function}\n: How the `base::rle()` function works\n:::\n:::\n\n::: my-procedure-container\nHe reasoned:\n\n1.  We've been using `stats::rbinom()` with the size parameter set to 9\n    for our simulations for a certain number of observation, e.g., 10\n    experiments á la 9 tosses each. This gives us the aggregated results\n    of the number of water events: `rbinom(10, size = 9, prob = .6)` =\n    7, 5, 6, 8, 7, 5, 6, 3, 3, 4\n2.  But what we need is to simulate nine *individual* trials many times\n    over: `rbinom(9, size = 1, prob = .6)` =\n    0, 1, 1, 1, 0, 0, 0, 0, 0\n3.  We simulate the result of individual trials many times and add their\n    outcomes into a tibble `d2_samples_b`.\n\n\n::: {.cell hash='03-sampling-the-imaginary_cache/html/sim-indiv-trials_0d77aa1977788c9ecb74cacfc6d2ef35'}\n\n```{.r .cell-code}\nset.seed(3)\n\nd2_samples_b <-\n  d2_samples_b |> \n  dplyr::mutate(iter  = 1:dplyr::n(),\n         draws = purrr::map(p_grid2_b, rbinom, n = 9, size = 1)) |> \n  tidyr::unnest(draws)\n\ndplyr::glimpse(d2_samples_b)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> Rows: 90,000\n#> Columns: 7\n#> $ p_grid2_b     <dbl> 0.564, 0.564, 0.564, 0.564, 0.564, 0.564, 0.564, 0.564, …\n#> $ prior2_b      <dbl> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,…\n#> $ likelihood2_b <dbl> 0.2240853, 0.2240853, 0.2240853, 0.2240853, 0.2240853, 0…\n#> $ posterior2_b  <dbl> 0.002240853, 0.002240853, 0.002240853, 0.002240853, 0.00…\n#> $ w             <dbl> 4, 4, 4, 4, 4, 4, 4, 4, 4, 7, 7, 7, 7, 7, 7, 7, 7, 7, 3,…\n#> $ iter          <int> 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3,…\n#> $ draws         <int> 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 0, 1,…\n```\n\n\n:::\n:::\n\n\n4.  Now we can use the `base:rle()`function to compute consecutive\n    length and number of switches:\n\n::: panel-tabset\n###### Length\n\n::: my-r-code\n::: my-r-code-header\n::: {#cnj-repl-fig-3.7-left}\nb: Replication of left panel of Figure 3.7\n:::\n:::\n\n::: my-r-code-container\n\n::: {.cell hash='03-sampling-the-imaginary_cache/html/fig-left-panel-3-7_1c9e69629016874648b71bde419aad17'}\n\n```{.r .cell-code}\nd2_samples_b |>\n  dplyr::group_by(iter) |> \n  dplyr::summarize(longest_run_length = base::rle(draws)$lengths |> \n              base::max()) |>\n  \n  ggplot2::ggplot(ggplot2::aes(x = longest_run_length)) +\n  ggplot2::geom_histogram(ggplot2::aes(fill = longest_run_length == 3),\n                 binwidth = 0.2, center = 0,\n                 color = \"white\", linewidth = 1/10) +\n  ggplot2::scale_fill_viridis_d(option = \"C\", end = .9) +\n  ggplot2::scale_x_continuous(\"longest run length\", breaks = 0:3 * 3) +\n  ggplot2::ylab(\"frequency\") +\n  ggplot2::coord_cartesian(xlim = c(0, 9)) +\n  ggplot2::theme_bw() +\n  ggplot2::theme(legend.position = \"none\",\n        panel.grid = ggplot2::element_blank()) \n```\n\n::: {.cell-output-display}\n![The length of the maximum run of water or land](03-sampling-the-imaginary_files/figure-html/fig-left-panel-3-7-1.png){#fig-left-panel-3-7 width=672}\n:::\n:::\n\n:::\n:::\n\n###### Switches\n\n::: my-r-code\n::: my-r-code-header\n<div>\n\nb: Replication of right panel of Figure 3.7\n\n</div>\n:::\n\n::: my-r-code-container\n\n::: {.cell hash='03-sampling-the-imaginary_cache/html/fig-right-panel-3-7_0a4e21bdb331cfe12421478e03edfb04'}\n\n```{.r .cell-code}\nd2_samples_b |>\n  dplyr::group_by(iter) |>\n  dplyr::summarize(number_of_switches = base::rle(draws)$lengths |>\n                     base::length()) |>\n  \n  ggplot2::ggplot(ggplot2::aes(x = number_of_switches)) +\n  ggplot2::geom_histogram(ggplot2::aes(fill = number_of_switches == 6),\n                 binwidth = 0.2, center = 0,\n                 color = \"white\", linewidth = 1/10) +\n  ggplot2::scale_fill_viridis_d(option = \"C\", end = .9) +\n  ggplot2::scale_x_continuous(\"number of switches\", breaks = 0:3 * 3) +\n  ggplot2::ylab(\"frequency\") +\n  ggplot2::coord_cartesian(xlim = c(0, 9)) +\n  ggplot2::theme_bw() +\n  ggplot2::theme(legend.position = \"none\",\n        panel.grid = ggplot2::element_blank())\n```\n\n::: {.cell-output-display}\n![The number of switches between water and land samples](03-sampling-the-imaginary_files/figure-html/fig-right-panel-3-7-1.png){#fig-right-panel-3-7 width=672}\n:::\n:::\n\n:::\n:::\n:::\n:::\n:::\n\n::: my-important\n::: my-important-header\nCheck model adequacy with alternative views of the same posterior\npredictive distribution\n:::\n\n::: my-important-container\nFor me there are two conclusion to draw from the section on model\nchecking:\n\n1.  It is possible and also important to look at the data generated by\n    the model from different angels.\n\n> \"Instead of considering the data as the model saw it, as a sum of\n> water samples, now we view the data as both the length of the maximum\n> run of water or land (left) and the number of switches between water\n> and land samples (right).\" ([McElreath, 2020, p.\n> 67](zotero://select/groups/5243560/items/NFUEVASQ))\n> ([pdf](zotero://open-pdf/groups/5243560/items/CPFRPHX8?page=86&annotation=W7II5H76))\n\n2.  To generate alternative views at the requires some ingenuity and an\n    evaluation if the model is adequate. For instance: 6 switches in 9\n    tosses in not consistent with the distribution of the longest runs.\n    There should be fewer switches.\n:::\n:::\n\n\n\n#### Let's practice with {**brms**}\n\nThe content of this section is more or less copied from Kurz without\nmuch knowledge of {**brms**}. The following code chunks are therefore my\nfirst acquaintance with the {**brms**} package and my reassurance that\nthe package installation did work and to test if I get the same results\nas Kurz.\n\n::: my-resource\n::: my-resource-header\nHow to use <a class='glossary' title='brms stands for Bayesina Regression Models using Stan. brms provides an interface to fit Bayesian generalized (non-)linear multivariate multilevel models using Stan. The formula syntax is very similar to that of the package lme4 to provide a familiar and simple interface for performing regression analyses. (brms website)'>brms</a>\n:::\n\n::: my-resource-container\nI still have to read [How to use\n{**brms**}](https://github.com/paul-buerkner/brms#how-to-use-brms) and\nthe many [packages vignettes](https://paul-buerkner.github.io/brms/) in\nthe help file or at the website.\n:::\n:::\n\n> With {**brms**}, we'll fit the primary model of $w=6$ and $n=9$ much\n> like we did at the end of @sec-chap02.\n\n::: my-r-code\n::: my-r-code-header\n::: {#cnj-b3.1}\nb: Fit model and compute posterior summary for `b_Intercept`, the\nprobability of a \"w\"\n:::\n:::\n\n::: my-r-code-container\n\n::: {.cell hash='03-sampling-the-imaginary_cache/html/brms-model-fit-b_7dec9ba0a7ce22eaa9660fc6bee9e3b6'}\n\n```{.r .cell-code}\nb3.1 <-\n  brms::brm(data = list(w = 6), \n      family = binomial(link = \"identity\"),\n      w | trials(9) ~ 0 + Intercept,\n      # this is a flat prior\n      brms::prior(beta(1, 1), class = b, lb = 0, ub = 1),\n      iter = 5000, warmup = 1000,\n      seed = 3,\n      file = \"fits/b03.01\")\n\nbrms::posterior_summary(b3.1)[\"b_Intercept\", ] |> \n  round(digits = 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>  Estimate Est.Error      Q2.5     Q97.5 \n#>      0.64      0.14      0.34      0.88\n```\n\n\n:::\n:::\n\n\n**Explication of the result**\n\n-   `Estimate` is the posterior mean,\n-   the two `Q` columns are the quantile-based 95% intervals,\n-   the `Est.Error` is the posterior standard deviation.\n\n:::\n:::\n\n::: callout-note\nI have already some experience with the beta distribution from my study\nof [Bayesian Statistics the Fun Way: Understanding Statistics and\nProbability With Star Wars, LEGO, and Rubber\nDucks](https://nostarch.com/learnbayes) by Will Kurt [@kurt2019]. See\nalso my [Quarto book\nnotes](https://bookdown.org/pbaumgartner/bayesian-fun/). There is more\nabout the beta distribution in @sec-chap12.\n\nBut I will still have to learn about the syntax of the first three\nlines. The rest of the model description is more or less\nself-explanatory.\n:::\n\n> Much like the way we used the `dplyr::slice_sample()` function to\n> simulate probability values, above, we can do so with the\n> `brms::fitted()` function. But we will have to specify\n> `scale = \"linear\"` in order to return results in the probability\n> metric. By default, `brms::fitted()` will return summary information.\n> Since we want actual simulation draws, we'll specify `summary = F`.\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-brms-sim-b}\nb: Simulation of probability values \n::::::\n:::\n::::{.my-r-code-container}\n\n\n::: {.cell hash='03-sampling-the-imaginary_cache/html/sim-prob-values-b_e4ecf4397eee4cc897ce9300046a36cc'}\n\n```{.r .cell-code}\nf <-\n  brms:::fitted.brmsfit(b3.1, \n         summary = F,\n         scale = \"linear\") |> \n  data.frame() |> \n  rlang::set_names(\"p\")\n\ndplyr::glimpse(f)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> Rows: 16,000\n#> Columns: 1\n#> $ p <dbl> 0.6318994, 0.8105015, 0.7677781, 0.7250286, 0.7265799, 0.7376768, 0.…\n```\n\n\n:::\n:::\n\n\n:::::{.my-watch-out}\n:::{.my-watch-out-header}\nHow to use [S3 methods](https://adv-r.hadley.nz/s3.html) without\nattached package?\n:::\n::::{.my-watch-out-container}\nI had problems with the following code chunk. See [my postings at Kurz's\nrepo](https://github.com/ASKurz/Statistical_Rethinking_with_brms_ggplot2_and_the_tidyverse_2_ed/issues/49).\n\n::::\n:::::\n\n::::\n:::::\n\n\nNow we can display the density and the posterior predictive distribution\n\n::: {.panel-tabset}\n###### Density\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-fig-brms-3-6-top-b}\nb: Model b3.1: Density and posterior predictive distribution\n::::::\n:::\n::::{.my-r-code-container}\n\n\n::: {.cell hash='03-sampling-the-imaginary_cache/html/fig-brms-3-6-top-b_a94d2bf53c95a7167e61022ca6672fd1'}\n\n```{.r .cell-code}\nf |> \n  ggplot2::ggplot(ggplot2::aes(x = p)) +\n  ggplot2::geom_density(fill = \"deepskyblue\", color = \"deepskyblue\") +\n  ggplot2::annotate(geom = \"text\", x = .08, y = 2.5,\n           label = \"Posterior probability\") +\n  ggplot2::scale_x_continuous(\"probability of water\",\n                     breaks = c(0, .5, 1),\n                     limits = 0:1) +\n  ggplot2::scale_y_continuous(NULL, breaks = NULL) +\n  ggplot2::theme(panel.grid = ggplot2::element_blank()) +\n  ggplot2::theme_bw()\n```\n\n::: {.cell-output-display}\n![Density plot of the fittet {brms} model](03-sampling-the-imaginary_files/figure-html/fig-brms-3-6-top-b-1.png){#fig-brms-3-6-top-b width=672}\n:::\n:::\n\n\nThe graphic should look like the top part of @fig-3-6.\n::::\n:::::\n\n\n\n###### Predictive\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-fig-brms-3-6-bottom-b}\nb: Posterior predictive distribution for model b3.1\n::::::\n:::\n::::{.my-r-code-container}\n\n\n::: {.cell hash='03-sampling-the-imaginary_cache/html/fig-brms-3-6-bottom-b_ebc1dc56f81ff3c71fbc89b6f0379780'}\n\n```{.r .cell-code}\nbase::set.seed(3)\nf <-\n  f |> \n  dplyr::mutate(w2 = stats::rbinom(dplyr::n(), size = 9,  prob = p))\n\n# the plot\nf |> \n  ggplot2::ggplot(ggplot2::aes(x = w2)) +\n  ggplot2::geom_histogram(binwidth = 1, center = 0, color = \"black\",\n                 fill = \"deepskyblue\", linewidth = 1/10) +\n  ggplot2::scale_x_continuous(\"number of water samples\", breaks = 0:3 * 3) +\n  ggplot2::scale_y_continuous(NULL, breaks = NULL, limits = c(0, 5000)) +\n  ggplot2::ggtitle(\"Posterior predictive distribution\") +\n#  ggplot2::coord_cartesian(xlim = c(0, 9)) +\n  ggplot2::theme(panel.grid = ggplot2::element_blank()) +\n  ggplot2::theme_bw()\n```\n\n::: {.cell-output-display}\n![Simulation to predict posterior distribution](03-sampling-the-imaginary_files/figure-html/fig-brms-3-6-bottom-b-1.png){#fig-brms-3-6-bottom-b width=672}\n:::\n:::\n\n\n\n> Much like we did with samples, we can use this distribution of\n> probabilities to predict histograms of $w$ counts. With those in hand,\n> we can make an analogue to the histogram in the bottom panel of Figure\n> 3.6 (copied here into the text as @fig-3-6)\n\n::::\n:::::\n\n\n:::\n\n\n## Practice\n\n### Easy\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-exercise-data-3.27}\n: Posterior distribution for the globe tossing example exercises\n::::::\n:::\n::::{.my-r-code-container}\n\n::: {.panel-tabset}\n\n###### Original\n\n\n\n\n\n::: {.cell hash='03-sampling-the-imaginary_cache/html/exercise-data-3.27a_c1beebfac575310ad5861cd9d15bbf0d'}\n\n```{.r .cell-code}\n## R code 3.27a for exercises  #######################\n\np_grid_3ea <- seq(from = 0, to = 1, length.out = 1000)\nprior_3ea <- rep(1, 1000)\nlikelihood_3ea <- dbinom(6, size = 9, prob = p_grid_3ea)\nposterior_3ea <- likelihood_3ea * prior_3ea\nposterior_3ea <- posterior_3ea / sum(posterior_3ea)\nset.seed(100)\nsamples_3ea <- sample(p_grid_3ea, prob = posterior_3ea, size = 1e4, replace = TRUE)\nhist(samples_3ea,\n     xlab = \"Probability\",\n     ylab = \"Frequency\",\n     main = \"Posterior distribution for the globe tossing example\")\n```\n\n::: {.cell-output-display}\n![](03-sampling-the-imaginary_files/figure-html/exercise-data-3.27a-1.png){width=672}\n:::\n:::\n\n\n\n###### Tidyverse\n\n\n::: {.cell hash='03-sampling-the-imaginary_cache/html/exercise-data-3.27b_0ec419e599c2aa9502a097321f191f14'}\n\n```{.r .cell-code}\n## R code 3.27b for exercises  #######################\n\ndf_3eb <- tibble::tibble(p_grid_3eb = base::seq(from = 0, to = 1, length.out = 1000),\n               prior_3eb = base::rep(1, 1000),\n               likelihood_3eb = stats::dbinom(6, size = 9, prob = p_grid_3eb),\n               posterior_3eb = likelihood_3eb * prior_3eb,\n               posterior_std_3eb = posterior_3eb / sum(posterior_3eb))\n\nbase::set.seed(100)\nsamples_3eb <- df_3eb |> \n  dplyr::slice_sample(n = 1e4, \n                      weight_by = posterior_std_3eb, replace = TRUE) |> \n  dplyr::rename(p_samples_3eb = p_grid_3eb)\n\nsamples_3eb |> \n  ggplot2::ggplot(ggplot2::aes(x = p_samples_3eb)) +\n  ggplot2::geom_histogram(bins = 20, fill = \"grey\", color = \"black\") +\n  ggplot2::theme_bw() +\n  ggplot2::labs(x = \"Propability\",\n                y = \"Frequency\",\n                title = \"Posterior distribution for the globe tossing example\")\n```\n\n::: {.cell-output-display}\n![](03-sampling-the-imaginary_files/figure-html/exercise-data-3.27b-1.png){width=672}\n:::\n:::\n\n\n\n\n:::\n\n**Original**: \n0.7137137, 0.3573574, 0.5985986, 0.7177177, 0.6296296, …\n\n**Tidyerse**: \n0.7137137, 0.3573574, 0.5985986, 0.7177177, 0.6296296, …\n\n::::\n:::::\n\n\n#### Exercises 3E1 - 3E7\n\n\n:::::{.my-exercise}\n:::{.my-exercise-header}\nExercises 3E1 - 3E7\n\n- **3E1.** How much posterior probability lies below $p = 0.2$? \n- **3E2.** How much posterior probability lies above $p = 0.8$? \n- **3E3.** How much posterior probability lies between $p = 0.2$ and $p = 0.8$? \n- **3E4.** $20\\%$ of the posterior probability lies below which value of $p$? \n- **3E5.** $20\\%$ of the posterior probability lies above which value of $p$? \n- **3E6.** Which values of $p$ contain the narrowest interval equal to $66\\%$ of the posterior probability? \n- **3E7.** Which values of $p$ contain $66\\%$ of the posterior probability, assuming equal posterior probability both below and above the interval?\n:::\n::::{.my-exercise-container}\n\n\n::: {.panel-tabset}\n\n###### Original\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-easy-03a}\na: Exercises 3E1 - 3E7 (Original)\n::::::\n:::\n::::{.my-r-code-container}\n\n\n::: {.cell hash='03-sampling-the-imaginary_cache/html/exercise-3ea_3b37e2ee884a6a0a3a927de2a9deaad5'}\n\n```{.r .cell-code}\n## exercises 3E1a - 3E7a ####################\n\nsum(samples_3ea < 0.2) / 1e4                            ## 3.7a\nsum(samples_3ea > 0.8) / 1e4                            ## 3.7a\nsum(samples_3ea > 0.2 & samples_3ea < 0.8) / 1e4        ## 3.8a\nquantile(samples_3ea, 0.2)                       ## 3.9a\nquantile(samples_3ea, 0.8)                       ## 3.10a\nrethinking::HPDI(samples_3ea, prob = 0.66)              ## 3.13a\nrethinking::PI(samples_3ea, prob = 0.66)                ## 3.12a1\n\n## same as above\n## quantile(samples_3ea, prob = c(.1667, .8333))    ## 3.12a2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 4e-04\n#> [1] 0.1116\n#> [1] 0.888\n#>       20% \n#> 0.5185185 \n#>       80% \n#> 0.7557558 \n#>     |0.66     0.66| \n#> 0.5085085 0.7737738 \n#>       17%       83% \n#> 0.5025025 0.7697698\n```\n\n\n:::\n:::\n\n\n***\n\n- **3E1.** 0.04% of the posterior probability lies below $p = 0.2$. \n- **3E2.** 11.16% of the posterior probability lies above $p = 0.8$. \n- **3E3.** 88.8% posterior probability lies between $p = 0.2$ and $p = 0.8$.\n- **3E4.** $20\\%$ of the posterior probability lies below $p =$ 0.519. \n- **3E5.** $20\\%$ of the posterior probability lies above $p =$ 0.756. \n- **3E6.** $66\\%$ of the narrowest interval lies between 0.509 and 0.774.\n- **3E7.** The interval between 0.503 and 0.77 contains $66\\%$ of the posterior probability, assuming equal posterior probability both below and above the interval.\n\n::::\n:::::\n\n\n###### Tidyverse\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-easy-03b}\nb: Exercises 3E1 - 3E7 (Tidyverse)\n::::::\n:::\n::::{.my-r-code-container}\n\n\n::: {.cell hash='03-sampling-the-imaginary_cache/html/exercise-3eb_631182051e376851288b3bdc69543aa6'}\n\n```{.r .cell-code}\n## exercises 3E1b - 3E7b ####################\n\n\n(e3b1 <- samples_3eb |> \n  dplyr::filter(p_samples_3eb < 0.2) |> \n  dplyr::summarize(sum = dplyr::n() / 1e4) |>\n  dplyr::pull())  \n                                                        ## 3.7b\n(e3b2 <- samples_3eb |> \n  dplyr::filter(p_samples_3eb > 0.8) |> \n  dplyr::summarize(sum = dplyr::n() / 1e4) |>            ## 3.7b\n  dplyr::pull())\n\n(e3b3 <- samples_3eb |> \n  dplyr::filter(p_samples_3eb > 0.2 & p_samples_3eb < 0.8) |> \n  dplyr::summarize(sum = dplyr::n() / 1e4) |>            ## 3.8b\n  dplyr::pull())\n\n(e3b4 <- stats::quantile(samples_3eb$p_samples_3eb, probs = .2))\n\n(e3b5 <- stats::quantile(samples_3eb$p_samples_3eb, probs = .8))\n\n(e3b6 <- tidybayes::mode_hdci(samples_3eb$p_samples_3eb, .width = .66))\n\n## tidybayes::mean_hdci(samples_3eb$p_samples_3eb, .width = .66)\n\n## same as above\n(e3b7 <- tidybayes::qi(samples_3eb$p_samples_3eb, .width = .66))\n\n\n### R Code 3.7b with alternative methods #########\n\n#base::sum(samples_3eb$p_samples_3eb < 0.2) / 1e4           ## 3.7b\n#\n# samples_3eb |> \n#   dplyr::summarize(sum = mean(p_samples_3eb > .8))       ## 3.7b\n# \n# samples_3eb |> \n#     dplyr::count(p_samples_3eb > .8) |> \n#     dplyr::mutate(probability = 1e4 / base::sum(1e4))   ## 3.7b\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 4e-04\n#> [1] 0.1116\n#> [1] 0.888\n#>       20% \n#> 0.5185185 \n#>       80% \n#> 0.7557558 \n#>           y      ymin      ymax .width .point .interval\n#> 1 0.6559935 0.5205205 0.7877878   0.66   mode      hdci\n#>           [,1]      [,2]\n#> [1,] 0.5025025 0.7697698\n```\n\n\n:::\n:::\n\n\n***\n\n- **3E1.** 0.04% of the posterior probability lies below $p = 0.2$. \n- **3E2.** 11.16% of the posterior probability lies above $p = 0.8$. \n- **3E3.** 88.8% posterior probability lies between $p = 0.2$ and $p = 0.8$.\n- **3E4.** $20\\%$ of the posterior probability lies below $p =$ 0.519. \n- **3E5.** $20\\%$ of the posterior probability lies above $p =$ 0.756. \n- **3E6.** $66\\%$ of the narrowest interval lies between 0.521 and 0.788.\n- **3E7.** The interval between 0.503 and 0.77 contains $66\\%$ of the posterior probability, assuming equal posterior probability both below and above the interval.\n\n\n:::::{.my-note}\n:::{.my-note-header}\n:::::: {#cor-3e3b}\n: Using `dplyr::between()`\n::::::\n:::\n::::{.my-note-container}\nI learned from Jake Thompson that I could have used `dplyr::between()` for the exercise 3E3: `mean(dplyr::between(p_samples_3eb$samples_3eb, 0.2, 0.8))` = 0.888\n::::\n:::::\n\n\n\n::::\n:::::\n\n:::::{.my-watch-out}\n:::{.my-watch-out-header}\nDifference between `rethinking::HPDI()` and `tidybayes::mode_hdci()`\n:::\n::::{.my-watch-out-container}\nThere is a small difference between `rethinking::HPDI()` (0.5085085 resp. 0.7737738) and `tidybayes::mode_hdci()` (0.5205205 and 0.7877878). \n::::\n:::::\n\n\n\n\n\n\n\n:::\n\n\n::::\n:::::\n\n### Middle\n\n#### 3M1 {#sec-e3m1}\n\n:::::{.my-exercise}\n:::{.my-exercise-header}\nExercise 3M1: Suppose the globe tossing data had turned out to be 8 water in 15 tosses. Construct the posterior distribution, using grid approximation. Use the same flat prior as before.\n:::\n::::{.my-exercise-container}\n\n::: {.panel-tabset}\n\n###### Original\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-3m1a}\n: Exercise 3M1a (Original)\n::::::\n:::\n::::{.my-r-code-container}\n\n\n::: {.cell hash='03-sampling-the-imaginary_cache/html/fig-exercise-3m1a_7408d49612f2f97db2121d290c15211f'}\n\n```{.r .cell-code}\np_grid_3m1a <- seq(from = 0, to = 1, length.out = 1000)\nprior_3m1a <- rep(1, 1000)\nlikelihood_3m1a <- stats::dbinom(8, size = 15, prob = p_grid_3m1a)\nposterior_3m1a <-  likelihood_3m1a * prior_3m1a\nposterior_std_3m1a <-  posterior_3m1a / sum(posterior_3m1a) \nplot(p_grid_3m1a, posterior_std_3m1a, type = \"l\", \n     xlab = \"Proportion of water (p)\",\n     ylab = \"Posterior density\")\ngrid(lty = 1)\n\nmap_3m1a <- p_grid_3m1a[which.max(posterior_std_3m1a)]\n```\n\n::: {.cell-output-display}\n![Posterior distribution for 8 'W' in 15 tosses (Original)](03-sampling-the-imaginary_files/figure-html/fig-exercise-3m1a-1.png){#fig-exercise-3m1a width=672}\n:::\n:::\n\n\nThe modus (<a class='glossary' title='In Bayesian statistics a Maximum A Posteriori probability or MAP is essentially the mode of posterior distribution. (CDS, p.272)'>MAP</a>) is at p = 0.534 with a posterior density of 0.00325.\n\n::::\n:::::\n\n###### Tidyverse\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-3m1a}\n: Exercise 3M1b (Tidyverse)\n::::::\n:::\n::::{.my-r-code-container}\n\n\n\n::: {.cell hash='03-sampling-the-imaginary_cache/html/fig-exercise-3m1b_16dced1ed184d9e36d14438337e6bc86'}\n\n```{.r .cell-code}\ndf_3m1b <- tibble::tibble(\n  p_grid_3m1b = base::seq(from = 0, to = 1, length.out = 1000),\n  prior_3m1b = base::rep(1, 1000),\n  likelihood_3m1b = stats::dbinom(x = 8, size = 15, prob = p_grid_3m1b),\n  posterior_3m1b =  likelihood_3m1b * prior_3m1b,\n  posterior_std_3m1b = posterior_3m1b / sum(posterior_3m1b)\n  ) \n\ndf_3m1b |> \n  ggplot2::ggplot(ggplot2::aes(x = p_grid_3m1b, y = posterior_std_3m1b)) +\n  ggplot2::geom_line() +\n  ggplot2::labs(x = \"Proportion of water (p)\",\n                y = \"Posterior density\") +\n  ggplot2::theme_bw()\n\nmap_3m1b <- df_3m1b |> \n  dplyr::arrange(dplyr::desc(posterior_std_3m1b)) |> \n  dplyr::summarize(dplyr::first(p_grid_3m1b)) |> \n  dplyr::pull(1)\n```\n\n::: {.cell-output-display}\n![Posterior distribution for 8 'W' in 15 tosses (Tidyverse)](03-sampling-the-imaginary_files/figure-html/fig-exercise-3m1b-1.png){#fig-exercise-3m1b width=672}\n:::\n:::\n\nThe modus (<a class='glossary' title='In Bayesian statistics a Maximum A Posteriori probability or MAP is essentially the mode of posterior distribution. (CDS, p.272)'>MAP</a>) is at p = 0.5335335 with a posterior density of 0.0032519.\n\n\n::::\n:::::\n\n\n\n:::\n\n::::\n:::::\n\n***\n\n#### 3M2\n\n:::::{.my-exercise}\n:::{.my-exercise-header}\nExercise 3M2: Draw $10,000$ samples from the grid approximation from above. Then use the samples to calculate the $90\\%$ and $99\\%$ HPDI for $p$.\n:::\n::::{.my-exercise-container}\n::: {.panel-tabset}\n\n###### Original\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-3m2a}\na: Exercise 3M2 (Original)\n::::::\n:::\n::::{.my-r-code-container}\n\n\n::: {.cell hash='03-sampling-the-imaginary_cache/html/fig-exercise-3m2a_efd32d92c44a1ed8744dc9be9b8e0914'}\n\n```{.r .cell-code}\n## 1e4 samples #############\nset.seed(42)\nsamples_3m2a <-  sample(x = p_grid_3m1a,\n                       prob = posterior_std_3m1a, \n                       size = 1e4,\n                       replace = TRUE)\n\n## Density with rethinking::dens() ########\nrethinking::dens(samples_3m2a, adj = 1)\n\n## Parameters #########\n(pi_3m2a_1 <- rethinking::PI(samples_3m2a, prob = .9))\n(pi_3m2a_2 <- rethinking::PI(samples_3m2a, prob = .99))\n(hpdi_3m2a_1 <- rethinking::HPDI(samples_3m2a, prob = .9))\n(hpdi_3m2a_2 <- rethinking::HPDI(samples_3m2a, prob = .99))\n(mean_3m2a <- mean(samples_3m2a))\n(median_3m2a <- median(samples_3m2a))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>        5%       95% \n#> 0.3323323 0.7207708 \n#>        1%      100% \n#> 0.2382382 0.8148148 \n#>      |0.9      0.9| \n#> 0.3393393 0.7267267 \n#>     |0.99     0.99| \n#> 0.2312312 0.8048048 \n#> [1] 0.5295147\n#> [1] 0.5305305\n```\n\n\n:::\n\n::: {.cell-output-display}\n![10,000 samples from the grid approximation 8 water with 15 tosses (Original)](03-sampling-the-imaginary_files/figure-html/fig-exercise-3m2a-1.png){#fig-exercise-3m2a width=672}\n:::\n:::\n\n\n- **Mean**:   0.53\n- **Median**: 0.531\n\n| Prior = 1   | Low                  | High                 | Diff                                    |\n|----------|----------------------|----------------------|-----------------------------------------|\n| PI .90   | 0.3323323   | 0.7207708   | 0.3884384     |\n| PI .99   | 0.2382382   | 0.8148148   | 0.3884384     |\n| HPDI .90 | 0.3393393 | 0.7267267 | 0.3873874 |\n| HPDI .99 | 0.2312312 | 0.8048048 | 0.5735736 |\n\n::::\n:::::\n\n\n\n###### Tidyverse\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-3m2b}\nb: Exercise 3M2 (Tidyverse)\n::::::\n:::\n::::{.my-r-code-container}\n\n\n::: {.cell hash='03-sampling-the-imaginary_cache/html/fig-exercise-3m2b_4a30d916795272a3cae20bbef3113261'}\n\n```{.r .cell-code}\n## 1e4 samples ##########\nbase::set.seed(42)\nsamples_3m2b <- df_3m1b |> \n  dplyr::slice_sample(n = 1e4, \n                      weight_by = posterior_std_3m1b, \n                      replace = TRUE) |> \n  dplyr::rename(p_samples_3m2b = p_grid_3m1b)  \n\n## Density with ggplot2\nsamples_3m2b |> \n  ggplot2::ggplot(ggplot2::aes(x = p_samples_3m2b)) +\n  ggplot2::geom_density(adjust = 1.0) + # 1.0 = default value\n  ggplot2::labs(x = \"N = 10000, Bandwith = 1.0\",\n                y = \"Density\") +\n  ggplot2::theme_bw()\n\n\n## Parameters ########\n(\n  param_3m2b <-  dplyr::bind_rows(\n    ggdist::mean_qi(samples_3m2b$p_samples_3m2b, .width = c(0.9, 0.99)),\n    ggdist::median_qi(samples_3m2b$p_samples_3m2b, .width = c(0.9, 0.99)),\n    ggdist::mode_qi(samples_3m2b$p_samples_3m2b, .width = c(0.9, 0.99)),\n    ggdist::mode_hdci(samples_3m2b$p_samples_3m2b, .width = c(0.9, 0.99)),\n    ggdist::mode_hdi(samples_3m2b$p_samples_3m2b, .width = c(0.9, 0.99))\n  )\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>            y      ymin      ymax .width .point .interval\n#> 1  0.5295147 0.3323323 0.7207708   0.90   mean        qi\n#> 2  0.5295147 0.2382382 0.8148148   0.99   mean        qi\n#> 3  0.5305305 0.3323323 0.7207708   0.90 median        qi\n#> 4  0.5305305 0.2382382 0.8148148   0.99 median        qi\n#> 5  0.5117147 0.3323323 0.7207708   0.90   mode        qi\n#> 6  0.5117147 0.2382382 0.8148148   0.99   mode        qi\n#> 7  0.5117147 0.3333333 0.7217217   0.90   mode      hdci\n#> 8  0.5117147 0.2312312 0.8048048   0.99   mode      hdci\n#> 9  0.5117147 0.3333333 0.7217217   0.90   mode       hdi\n#> 10 0.5117147 0.2312312 0.8048048   0.99   mode       hdi\n```\n\n\n:::\n\n::: {.cell-output-display}\n![10,000 samples from the grid approximation 8 water with 15 tosses (Tidyverse)](03-sampling-the-imaginary_files/figure-html/fig-exercise-3m2b-1.png){#fig-exercise-3m2b width=672}\n:::\n:::\n\n\n\n::::\n:::::\n\n\n:::\n::::\n:::::\n\n***\n\n#### 3M3\n\n:::::{.my-exercise}\n:::{.my-exercise-header}\n\nExercise 3M3: Construct a posterior predictive check for this model and data. This means simulate the distribution of samples, averaging over the posterior uncertainty in $p$. What is the probability of observing 8 water in 15 tosses?\n\n:::\n::::{.my-exercise-container}\n\nIn the following set of tabs \"Original\" is abbreviated with \"O\" and Tidyverse with \"T\".\n\n::: {.panel-tabset}\n###### Data (O)\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-3m3a-data}\na: Exercise 3M3 -- Data (Original)\n::::::\n:::\n::::{.my-r-code-container}\n\n\n\n::: {.cell hash='03-sampling-the-imaginary_cache/html/exercise-data-3m3a_1987825921e9c8e16fbbdc30b7881d93'}\n\n```{.r .cell-code}\nbase::set.seed(42)\n\n## R code 3.23a #############################\ndummy_3m3a <- stats::rbinom(1e4, size = 15, prob = samples_3m2a)\nas.data.frame(table(dummy_3m3a))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>    dummy_3m3a Freq\n#> 1           0    3\n#> 2           1   45\n#> 3           2   99\n#> 4           3  289\n#> 5           4  540\n#> 6           5  829\n#> 7           6 1134\n#> 8           7 1421\n#> 9           8 1419\n#> 10          9 1356\n#> 11         10 1195\n#> 12         11  817\n#> 13         12  483\n#> 14         13  280\n#> 15         14   74\n#> 16         15   16\n```\n\n\n:::\n:::\n\n::::\n:::::\n\n###### Plot (O)\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-3m3a-plot}\na: Exercise 3M3 -- Histogram (Original)\n::::::\n:::\n::::{.my-r-code-container}\n\n\n::: {.cell hash='03-sampling-the-imaginary_cache/html/exercise-plot-3m3a_dc082ae92d70f267d6a1cf8ef3ea66e4'}\n\n```{.r .cell-code}\nrethinking::simplehist(dummy_3m3a, xlab = \"Dummy water count\")\n```\n\n::: {.cell-output-display}\n![](03-sampling-the-imaginary_files/figure-html/exercise-plot-3m3a-1.png){width=672}\n:::\n:::\n\n\n::::\n:::::\n\n###### Result (O)\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-3m3a-result}\na: Exercise 3M3 -- Result (Original)\n::::::\n:::\n::::{.my-r-code-container}\n\n\n::: {.cell hash='03-sampling-the-imaginary_cache/html/exercise-result-3m3a_fc2ee828688205abc5fa962994fda81d'}\n\n```{.r .cell-code}\n(\n  mean_dummy_3m3a <- mean(dummy_3m3a == 8)\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 0.1419\n```\n\n\n:::\n:::\n\n::::\n:::::\n\n\nThe probability of observing 8 water in 15 tosses = 14.19%.\n\n\n###### Data (T)\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-3m3b-data}\nb: Exercise 3M3 -- Data (Tidyverse)\n::::::\n:::\n::::{.my-r-code-container}\n\n\n\n::: {.cell hash='03-sampling-the-imaginary_cache/html/exercise-data-3m3b_8a478964277de5e3e38232673135cc85'}\n\n```{.r .cell-code}\nbase::set.seed(42)\n\n## R code 3.23b #############################\n\nsamples_3m2b <- samples_3m2b |> \n  dplyr::mutate(dummy_3m3b = stats::rbinom(1e4, size = 15, prob = p_samples_3m2b))\n  \nsamples_3m2b |> \n  dplyr::group_by(dummy_3m3b) |> \n  dplyr::summarize(dummy_cnt = dplyr::n())\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> # A tibble: 16 × 2\n#>    dummy_3m3b dummy_cnt\n#>         <int>     <int>\n#>  1          0         3\n#>  2          1        45\n#>  3          2        99\n#>  4          3       289\n#>  5          4       540\n#>  6          5       829\n#>  7          6      1134\n#>  8          7      1421\n#>  9          8      1419\n#> 10          9      1356\n#> 11         10      1195\n#> 12         11       817\n#> 13         12       483\n#> 14         13       280\n#> 15         14        74\n#> 16         15        16\n```\n\n\n:::\n:::\n\n::::\n:::::\n\n###### Plot (T)\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-3m3b-plot}\nb: Exercise 3M3 -- Histogram (Tidyverse)\n::::::\n:::\n::::{.my-r-code-container}\n\n\n::: {.cell hash='03-sampling-the-imaginary_cache/html/fig-exercise-plot-3m3b_3703066a6de2d08dbda5da5edf07b246'}\n\n```{.r .cell-code}\nsamples_3m2b |> \n  ggplot2::ggplot(ggplot2::aes(x = dummy_3m3b)) +\n  ggplot2::geom_histogram(bins = 16, fill = \"grey\", color = \"black\") +\n  ggplot2::theme_bw() +\n  ggplot2::labs(x = \"Dummy water count\",\n                y = \"Frequnecy\")\n```\n\n::: {.cell-output-display}\n![Posterior predictive check for 8 water with 15 tosses](03-sampling-the-imaginary_files/figure-html/fig-exercise-plot-3m3b-1.png){#fig-exercise-plot-3m3b width=672}\n:::\n:::\n\n\n::::\n:::::\n\n###### Result (T)\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-3m3b-result}\nb: Exercise 3M3 -- Result (Tidyverse)\n::::::\n:::\n::::{.my-r-code-container}\n\n\n::: {.cell hash='03-sampling-the-imaginary_cache/html/exercise-result-3m3b_f2b95e16b18856251ce8da2499b082cb'}\n\n```{.r .cell-code}\n(\n  mean_dummy_3m3b <- samples_3m2b |> \n  dplyr::summarize(mean(dummy_3m3b == 8)) |> \n  dplyr::pull()\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 0.1419\n```\n\n\n:::\n:::\n\n\nThe probability of observing 8 water in 15 tosses = 14.19%.\n\n\n::::\n:::::\n\n\n:::\n\n::::\n:::::\n\n***\n\n#### 3M4\n\n:::::{.my-exercise}\n:::{.my-exercise-header}\nExercise 3M4: Using the posterior distribution constructed from the new (8/15) data, now calculate the probability of observing 6 water in 9 tosses.\n:::\n::::{.my-exercise-container}\n\nThere are two possible approaches for the solution:\n\n- **S1**: Random generation of the binomial distribution with the probability of the sampling distribution.\n- **S2**: Computing the density for 6/9 but with the posterior distribution from 8/15 as prior.\n\n::: {.panel-tabset}\n\n###### Original S1\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-3m4a1}\na: Exercise 3M4 (Original: Method S1)\n::::::\n:::\n::::{.my-r-code-container}\n\n::: {.cell hash='03-sampling-the-imaginary_cache/html/exercise-3m4a1_df7b23f6d6105bd48727c67c2bb28c2f'}\n\n```{.r .cell-code}\nset.seed(100)\nsamples_3m4a <- rbinom(1e4, size = 9, prob = samples_3m2a)\nmean(samples_3m4a == 6)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 0.1765\n```\n\n\n:::\n:::\n\n\n\n\n::::\n:::::\n\n###### Original S2 \n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-3m4a2}\na: Exercise 3M4 (Original: Method S2)\n::::::\n:::\n::::{.my-r-code-container}\n\n\n::: {.cell hash='03-sampling-the-imaginary_cache/html/unnamed-chunk-97_1d782df36b8d887ad2ad40f30daf83dd'}\n\n```{.r .cell-code}\n#|label: exercise-3m4a2\n\nlikelihood_6of9_3m4a <-  stats::dbinom(6, size = 9, prob = p_grid_3m1a)\nprior_6of9_3m4a <-  posterior_std_3m1a\n(\n  posterior_6of9_3m4a <- sum(likelihood_6of9_3m4a * prior_6of9_3m4a)\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 0.1763898\n```\n\n\n:::\n:::\n\n\n\n::::\n:::::\n\n\n\n###### Tidyverse S1\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-3m4b}\nb: Exercise 3M4 (Tidyverse: Method S1)\n::::::\n:::\n::::{.my-r-code-container}\n\n::: {.cell hash='03-sampling-the-imaginary_cache/html/exercise-3m41b_9cfcff9b4b049bcfb66f733d253e5726'}\n\n```{.r .cell-code}\nset.seed(100)\nsamples_3m2b |> \n  dplyr::mutate(\n    p_6of9_3m4b = stats::rbinom(1e4, size = 9, prob = p_samples_3m2b)\n    ) |> \n  dplyr::summarize(sum = base::mean(p_6of9_3m4b == 6)) |> \n  dplyr::pull()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 0.1765\n```\n\n\n:::\n:::\n\n\n\n\n::::\n:::::\n\n###### Tidyverse M2\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-3m4b}\nb: Exercise 3M4 (Tidyverse Method S2)\n::::::\n:::\n::::{.my-r-code-container}\n\n::: {.cell hash='03-sampling-the-imaginary_cache/html/exercise-3m42b_ba0a5c08cae9148dde69aad15df7ac96'}\n\n```{.r .cell-code}\ndf_3m1b |> \n  dplyr::mutate(\n    likelihood_6of9_3m4b = stats::dbinom(6, size = 9, prob = p_grid_3m1b),\n    prior_6of9_3m4b = posterior_std_3m1b) |> \n  dplyr::summarize(sum = base::sum(likelihood_6of9_3m4b * prior_6of9_3m4b)) |> \n  dplyr::pull()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 0.1763898\n```\n\n\n:::\n:::\n\n\n\n\n::::\n:::::\n\n\n:::\n\n::::\n:::::\n\n***\n\n#### 3M5\n\n:::::{.my-exercise}\n:::{.my-exercise-header}\nExercise 3M5: Start over at Exercise 3M1 (@sec-e3m1), but now use a prior that is zero below $p = 0.5$ and a constant above $p = 0.5$. This corresponds to prior information that a majority of the Earth’s surface is water. Repeat each problem above and compare the inferences. What difference does the better prior make? If it helps, compare inferences (using both priors) to the true value $p = 0.7$.\n:::\n::::{.my-exercise-container}\n\n::: {.panel-tabset}\n\n###### 3M5.1a\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-3m5a-1}\na: Exercise 3M5: Posterior Distribution (~ 3M1: Original)\n::::::\n:::\n::::{.my-r-code-container}\n\n\n::: {.cell hash='03-sampling-the-imaginary_cache/html/fig-exercise-3m5a-1_eb46d6a1fe848b6f2500a1491b88124b'}\n\n```{.r .cell-code}\n## repr 3M1a ###########\np_grid_3m5a <- seq(from = 0, to = 1, length.out = 1000)\nprior_3m5a <- ifelse(p_grid_3m5a < 0.5, 0, 1)\nlikelihood_3m5a <- stats::dbinom(8, size = 15, prob = p_grid_3m5a)\nposterior_3m5a <-  likelihood_3m5a * prior_3m5a\nposterior_std_3m5a <-  posterior_3m5a / sum(posterior_3m5a) \nplot(p_grid_3m5a, posterior_std_3m5a, type = \"l\", lty = \"dashed\",\n     xlab = \"Proportion of water (p)\",\n     ylab = \"Posterior density\")\nlines(p_grid_3m1a, posterior_std_3m1a)\nabline(v = .7, col = \"red\")\ngrid(lty = 1)\n```\n\n::: {.cell-output-display}\n![Posterior distribution for 8 'W' in 15 tosses with prior < 0.5 = 0 otherwise prior = 1 (Original)](03-sampling-the-imaginary_files/figure-html/fig-exercise-3m5a-1-1.png){#fig-exercise-3m5a-1 width=672}\n:::\n:::\n\n\nCompared with the true value of $0.7$ the new prior ($0$ under $p = 0.5$, otherwise $p = 1$) is better, but there is still a big difference between the true value and the mode of the probability density.\n\n::::\n:::::\n\n###### 3M5.2a\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-3m5a-2}\na: Exercise 3M5.2: HPDI of 90% from 1e4 samples (~3M2: Original)\n::::::\n:::\n::::{.my-r-code-container}\n\n\n::: {.cell hash='03-sampling-the-imaginary_cache/html/exercise-3m5a-2_db41fdd957d3de5e21a126cf19c48b8c'}\n\n```{.r .cell-code}\n## repr 3M2a #############\nset.seed(42)\nsamples_3m5a <- sample(x = p_grid_3m5a, \n                      size = 1e4, \n                      replace = TRUE, \n                      prob = posterior_std_3m5a\n                      )\nhpdi_3m5a <- rethinking::HPDI(samples_3m5a, .9)\n\nmax_3m2a <- max(posterior_std_3m1a)\nmax_3m5a <- max(posterior_std_3m5a)\n```\n:::\n\n\n| Prior | Low                | High               | Diff                                | Max Density  |\n|-------|--------------------|--------------------|-------------------------------------|--------------|\n| 1     | 0.3393393 | 0.7267267 | 0.3873874 | 0.0032519 |\n| 0/1   | 0.5005005 | 0.7117117 | 0.2112112 | 0.0054363 |\n\nThe HPDI interval is smaller with the the new prior $p < .5 = 0 \\operatorname{and} p >= .5 = 1$ than with a constant prior of $1$. The new prior is better as it gives more precise information.\n\nThe maximum posterior density of the new prior $0/1$ is higher than the maximum with the prior of $1$. Values of $p < 0.5$ are no longer taking up posterior density because they are $0$. This can also be seen in @fig-exercise-3m5a-1.\n::::\n:::::\n\n###### 3M5.3a\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-3m5a-3}\na: Exercise 3M5.3: Posterior predictive check (~3M3: Original)\n::::::\n:::\n::::{.my-r-code-container}\n\n\n::: {.cell hash='03-sampling-the-imaginary_cache/html/exercise-3m5a-3-4_6ee97f2fbc0fe3f84f51141fc33f757e'}\n\n```{.r .cell-code}\n## repr 3M3a ##############\nset.seed(42)\ndummy_3m5a_1 <- rbinom(1e4, 15, samples_3m5a)\nmean_3m5a_1 <- mean(dummy_3m5a_1 == 8)\n\n## repr 3M4a ##############\nset.seed(42)\ndummy_3m5a_2 <- rbinom(1e4, 9, samples_3m5a)\nmean_3m5a_2 <- mean(dummy_3m5a_2 == 6)\n\n## compare with p = 0.7 ##############\nset.seed(42)\ndummy_3m5a_3 <- rbinom(1e4, 15, 0.7)\nmean_3m5a_3 <- mean(dummy_3m5a_3 == 8)\n\nset.seed(42)\ndummy_3m5a_4 <- rbinom(1e4, 9, 0.7)\nmean_3m5a_4 <- mean(dummy_3m5a_4 == 6)\n```\n:::\n\n\n| Name      | Mean of 15/08   | Mean of 09/06   |\n|-----------|-----------------|-----------------|\n| Samples   | 0.1516 | 0.2401 |\n| Value 0.7 | 0.0822 | 0.265 |\n\nThe mean of the samples of 6 water observations with 9 tosses are higher than 8 water with 15 tosses. This represents the fact that the real value of 0.7 is nearer with 6/9 = 0.667 than with 8/15 = 0.533. Also note that a predictive check with the real value of $0.7$ shows a very small mean value with 15/8 but a much higher mean with 9/6.\n\n::::\n:::::\n\n###### 3M5.1b\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-3m5b-1}\nb: Exercise 3M5: Posterior Distribution (~ 3M1: Tidyverse)\n::::::\n:::\n::::{.my-r-code-container}\n\n\n\n::: {.cell hash='03-sampling-the-imaginary_cache/html/fig-exercise-3m5b-1_300dc28d53265bf2c66003d3fbdf6022'}\n\n```{.r .cell-code}\n## repr 3M1b ##############\ndf_3m5b <- tibble::tibble(\n  p_grid_3m5b = base::seq(from = 0, to = 1, length.out = 1000),\n  prior_3m5b = base::ifelse(p_grid_3m5b < 0.5, 0, 1),\n  likelihood_3m5b = stats::dbinom(x = 8, size = 15, prob = p_grid_3m5b),\n  posterior_3m5b =  likelihood_3m5b * prior_3m5b,\n  posterior_std_3m5b = posterior_3m5b / sum(posterior_3m5b)\n  )\n\nggplot2::ggplot() +\nggplot2::geom_line(data = df_3m5b,\n                mapping = ggplot2::aes(x = p_grid_3m5b, y = posterior_std_3m5b,\n                                       linetype = \"ifelse(p < 0.5, 0, 1)\")) +\nggplot2::geom_line(data = df_3m1b,\n                mapping = ggplot2::aes(x = p_grid_3m1b, y = posterior_std_3m1b,\n                                       linetype = \"1\")) +\nggplot2::scale_linetype_manual(\"Prior:\", \n                        values = c(\"solid\", \"dashed\")) +\nggplot2::geom_vline(xintercept = .7, color = \"red\") +\nggplot2::labs(x = \"Proportion of water (p)\",\n              y = \"Posterior density\") +\nggplot2::theme_bw()\n```\n\n::: {.cell-output-display}\n![Posterior distribution for 8 'W' in 15 tosses with prior < 0.5 = 0 otherwise prior = 1 (Tidyverse)](03-sampling-the-imaginary_files/figure-html/fig-exercise-3m5b-1-1.png){#fig-exercise-3m5b-1 width=672}\n:::\n:::\n\n\n\nCompared with the true value of $0.7$ the new prior ($0$ under $p = 0.5$, otherwise $p = 1$) is better, but there is still a big difference between the true value and the mode of the probability density.\n::::\n:::::\n\n###### 3M5.2b\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-3m5b-2}\nb: Exercise 3M5.2: HPDI of 90% from 1e4 samples (~3M2: Tidyverse)\n::::::\n:::\n::::{.my-r-code-container}\n\n\n\n::: {.cell hash='03-sampling-the-imaginary_cache/html/exercise-3m5b-2_daf99fb2cc530c1b99e5be6245c78432'}\n\n```{.r .cell-code}\n## repr 3M2b ##############\nset.seed(42)\nsamples_3m5b <- df_3m5b |> \n  dplyr::slice_sample(n = 1e4,\n                      weight_by = posterior_std_3m5b,\n                      replace = TRUE) |> \n  dplyr::rename(p_samples_3m5b = p_grid_3m5b)\n\n\nhpdi_3m2b <- rethinking::HPDI(samples_3m2b$p_samples_3m2b, .9)\nhpdi_3m5b <- rethinking::HPDI(samples_3m5b$p_samples_3m5b, .9)\n\nmax_3m2b <- max(df_3m1b$posterior_std_3m1b)\nmax_3m5b <- max(df_3m5b$posterior_std_3m5b)\n```\n:::\n\n\n| Prior | Low                | High               | Diff                                | Max Density  |\n|-------|--------------------|--------------------|-------------------------------------|--------------|\n| 1     | 0.3393393 | 0.7267267 | 0.3873874 | 0.0032519 |\n| 0/1   | 0.5005005 | 0.7117117 | 0.2112112 | 0.0054363 |\n\nThe HPDI interval is smaller with the the new prior $p < .5 = 0 \\operatorname{and} p >= .5 = 1$ than with a constant prior of $1$. The new prior is better as it gives more precise information.\n\nThe maximum posterior density of the new prior $0/1$ is higher than the maximum with the prior of $1$. Values of $p < 0.5$ are no longer taking up posterior density because they are $0$. This can also be seen in @fig-exercise-3m5b-1.\n\n\n\n::::\n:::::\n\n###### 3M5.3b\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-3m5b-3}\nb: Exercise 3M5.3: Posterior predictive check (~3M3: Tidyverse)\n::::::\n:::\n::::{.my-r-code-container}\n\n\n\n::: {.cell hash='03-sampling-the-imaginary_cache/html/exercise-3m5b-3-4_7463d4fe6b26c32052f9673ed0e9f9c3'}\n\n```{.r .cell-code}\n## repr 3M3b ##############\nset.seed(42)\ndummy_3m5b_1 <- rbinom(1e4, 15, samples_3m5b$p_samples_3m5b)\nmean_3m5b_1 <- mean(dummy_3m5b_1 == 8)\n\n## repr 3M4b ##############\nset.seed(42)\ndummy_3m5b_2 <- rbinom(1e4, 9, samples_3m5b$p_samples_3m5b)\nmean_3m5b_2 <- mean(dummy_3m5b_2 == 6)\n\n## compare with p = 0.7 ##############\nset.seed(42)\ndummy_3m5b_3 <- rbinom(1e4, 15, 0.7)\nmean_3m5b_3 <- mean(dummy_3m5b_3 == 8)\n\nset.seed(42)\ndummy_3m5b_4 <- rbinom(1e4, 9, 0.7)\nmean_3m5b_4 <- mean(dummy_3m5b_4 == 6)\n```\n:::\n\n\n| Name      | Mean of 15/08   | Mean of 09/06   |\n|-----------|-----------------|-----------------|\n| Samples   | 0.1516 | 0.2401 |\n| Value 0.7 | 0.0822 | 0.265 |\n\nThe mean of the samples of 6 water observations with 9 tosses are higher than 8 water with 15 tosses. This represents the fact that the real value of 0.7 is nearer with 6/9 = 0.667 than with 8/15 = 0.533. Also note that a predictive check with the real value of $0.7$ shows a very small mean value with 15/8 but a much higher mean with 9/6.\n\n::::\n:::::\n\n\n:::\n\n\n\n::::\n:::::\n\n***\n\n#### 3M6\n\n:::::{.my-exercise}\n:::{.my-exercise-header}\nExercise 3M6: Suppose you want to estimate the Earth’s proportion of water very precisely. Specifically, you want the 99% percentile interval of the posterior distribution of $p$ to be only $0.05$ wide. This means the distance between the upper and lower bound of the interval should be $0.05$. \n\n- **N tosses**: How many times will you have to toss the globe to do this?\n- **Width**: How influences the sample size the difference between samples?\n\n\n:::\n::::{.my-exercise-container}\n\n::: {.panel-tabset}\n###### N tosses (O)\n\n\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-3m6a-1}\na: Exercise 3M6-1: How many times will you have to toss the globe to get a $0.05$ wide interval with $PI = .99$?  (Original)\n::::::\n:::\n::::{.my-r-code-container}\n\nAlthough McElreath states explicitly that he won't require an exact answer but rather wants to see the chosen approach ([Winter 2019 Homework](https://github.com/rmcelreath/statrethinking_winter2019/blob/master/homework/week01.pdf)) I was curious about the figure and how to program this process. It turned out that the chosen `set.seed()` number has effects how many times one has to toss the globe.\n\n\n\n\n\n::: {.cell hash='03-sampling-the-imaginary_cache/html/exercise-3m6a-1_484a43df77ad4f0d6c8cd9c5098f17c2'}\n\n```{.r .cell-code}\npi99_3m6a <- function(N, seed) {\n  set.seed(seed)\n  p_true <-  0.7\n  W <- rbinom(1, size = N, prob = p_true)\n  p_grid_3m6a <- seq(from = 0, to = 1, length.out = 1000)\n  prior_3m6a <- rep(1, 1000)\n  likelihood_3m6a <- dbinom(W, size = N, prob = p_grid_3m6a)\n  posterior_3m6a <- likelihood_3m6a * prior_3m6a\n  posterior_std_3m6a <-  posterior_3m6a / sum(posterior_3m6a)\n  \n  samples_3m6a <-\n    sample(p_grid_3m6a,\n           prob = posterior_std_3m6a,\n           size = 1e4,\n           replace = TRUE)\n  rethinking::PI(samples_3m6a, 0.99)\n}\n\n\ntictoc::tic()\nN = 1\nmy_seed = c(3, 42, 100, 150)\ns = ''\n\nfor (i in 1:length(my_seed)) {\n  PI99 <- pi99_3m6a(N, my_seed[i])\n  while (as.numeric(PI99[2] - PI99[1] > 0.05)) {\n    N <- N + 1\n    PI99 <- pi99_3m6a(N, my_seed[i])\n  }\n  s[i] <- glue::glue('With set.seed({my_seed[i]}) we need to toss the globe {N} times.\\n')\n  N = 1\n}\ns\ntictoc::toc()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"With set.seed(3) we need to toss the globe 2102 times.\"  \n#> [2] \"With set.seed(42) we need to toss the globe 2208 times.\" \n#> [3] \"With set.seed(100) we need to toss the globe 2304 times.\"\n#> [4] \"With set.seed(150) we need to toss the globe 2115 times.\"\n#> 8.309 sec elapsed\n```\n\n\n:::\n:::\n\n\n\n::::\n:::::\n\n###### Width (O)\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-3m6a-2}\na: Exercise 3M6-2: Demonstrate the variation of the interval width with different number of simulations (Original)\n::::::\n:::\n::::{.my-r-code-container}\n\n::: {.cell hash='03-sampling-the-imaginary_cache/html/exercise-3m6a-2_d0ab6748f51b6972bbf0bdcf1d63e563'}\n\n```{.r .cell-code}\nf_3m6a <- function(N) {\n  p_true <-  0.7\n  W <- rbinom(1, size = N, prob = p_true)\n  p_grid_3m6a <- seq(from = 0, to = 1, length.out = 1000)\n  prior_3m6a <- rep(1, 1000)\n  likelihood_3m6a <- dbinom(W, size = N, prob = p_grid_3m6a)\n  posterior_3m6a <- likelihood_3m6a * prior_3m6a\n  posterior_std_3m6a <-  posterior_3m6a / sum(posterior_3m6a)\n  \n  samples_3m6a <-\n    sample(p_grid_3m6a,\n           prob = posterior_std_3m6a,\n           size = 1e4,\n           replace = TRUE)\n  pi_99_3m6a <-  rethinking::PI(samples_3m6a, 0.99)\n  as.numeric(pi_99_3m6a[2] - pi_99_3m6a[1])\n}\n\n\nNlist <- c(20, 50, 100, 200, 500, 1000, 2000) \nNlist <- rep(Nlist, each = 100) \nwidth <- sapply(Nlist, f_3m6a) \nplot(Nlist, width) \nabline(h = 0.05, col = \"red\")\n```\n\n::: {.cell-output-display}\n![](03-sampling-the-imaginary_files/figure-html/exercise-3m6a-2-1.png){width=672}\n:::\n:::\n\n\nThe difference between samples shrinks as the sample size increases.\n\n> What are we looking at in this plot? The horizontal is sample size. The points are individual interval widths, one for each simulation. The red line is drawn at a width of $0.05$. Looks like we need more than $2000$ tosses of the globe to get the interval to be that precise.\n>\n> The above is a general feature of learning from data: The greatest returns on learning come early on. Each additional observation contributes less and less. So it takes very much effort to progressively reduce our uncertainty. So if your application requires a very precise estimate, be prepared to collect a lot of data. Or to change your approach. ([Solution, Week-01, Winter 2019](https://github.com/rmcelreath/statrethinking_winter2019/blob/master/homework/week01_solutions.pdf))\n\n::::\n:::::\n\n###### N tosses (T)\n\n\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-3m6b-1}\nb: Exercise 3M6-1: How many times will you have to toss the globe to get a $0.05$ wide interval with $PI = .99$?  (Tidyverse)\n::::::\n:::\n::::{.my-r-code-container}\n\nBecause of the slow performance of manipulating whole data frame, I am going to use here just one `set.seed()` function. This is only to show that we get the same result as in the first loop of @cnj-3m6a-1.\n\n\n\n::: {.cell hash='03-sampling-the-imaginary_cache/html/exercise-3m6b-1_de0e4a19a0d473ce1bae59cfbe2733d2'}\n\n```{.r .cell-code}\npi99_3m6b <- function(N, seed) {\n  base::set.seed(seed)\n  p_true <-  0.7\n  W <- stats::rbinom(1, size = N, prob = p_true)\n  df_3m6b <-  tibble::tibble(p_grid_3m6b = \n                            base::seq(from = 0, to = 1, length.out = 1000)) |> \n    dplyr::mutate(prior_3m6b = base::rep(1, 1000),\n           likelihood_3m6b = stats::dbinom(W, size = N, prob = p_grid_3m6b),\n           posterior_3m6b = likelihood_3m6b * prior_3m6b,\n           posterior_std_3m6b = posterior_3m6b / sum(posterior_3m6b))\n  \n  samples_3m6b <- df_3m6b |> \n    dplyr::slice_sample(n = 1e4,\n                        weight_by = posterior_std_3m6b,\n                        replace = TRUE)\n  \n  rethinking::PI(samples_3m6b$p_grid_3m6b, 0.99)\n}\n\ntictoc::tic()\nN = 1\nmy_seed = 3 ## just one loop!\ns = ''\n\nfor (i in 1:length(my_seed)) {\n  PI99_3m6b <- pi99_3m6b(N, my_seed[i])\n  while (as.numeric(PI99_3m6b[2] - PI99_3m6b[1] > 0.05)) {\n    N <- N + 1\n    PI99_3m6b <- pi99_3m6b(N, my_seed[i])\n  }\n  s[i] <- glue::glue('With set.seed({my_seed[i]}) we need to toss the globe {N} times.\\n')\n  N = 1\n}\ns\ntictoc::toc()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"With set.seed(3) we need to toss the globe 2102 times.\"\n#> 35.169 sec elapsed\n```\n\n\n:::\n:::\n\nCompare the execution time of just one set.seed() calculation with four in @cnj-3m6a-1. Using data frames turns out about 16(!) times slower the computation with vectors. (Already just one set.seed() computation with tibbles is 4 times slower than the processing time of 4 set.seed() loops with base R vectors.)\n\n::::\n:::::\n\n###### Width (T)\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-3m6b-2}\nb: Exercise 3M6-2: Demonstrate the variation of the interval width with different number of simulations (Tidyverse)\n::::::\n:::\n::::{.my-r-code-container}\n\n::: {.cell hash='03-sampling-the-imaginary_cache/html/exercise-3m6b-2_6ed10364f8119d1931a1c0bab4017151'}\n\n```{.r .cell-code}\nf_3m6b <- function(N) {\n  p_true <-  0.7\n  W <- stats::rbinom(1, size = N, prob = p_true)\n  df_3m6b <-  tibble::tibble(p_grid_3m6b = \n                            base::seq(from = 0, to = 1, length.out = 1000)) |> \n    dplyr::mutate(prior_3m6b = base::rep(1, 1000),\n           likelihood_3m6b = stats::dbinom(W, size = N, prob = p_grid_3m6b),\n           posterior_3m6b = likelihood_3m6b * prior_3m6b,\n           posterior_std_3m6b = posterior_3m6b / sum(posterior_3m6b))\n  \n  samples_3m6b <- df_3m6b |> \n    dplyr::slice_sample(n = 1e4,\n                        weight_by = posterior_std_3m6b,\n                        replace = TRUE)\n  pi_99_3m6b <-  rethinking::PI(samples_3m6b$p_grid_3m6b, 0.99)\n  as.numeric(pi_99_3m6b[2] - pi_99_3m6b[1])\n}\n\n\nNlist_3m6b <- c(20, 50, 100, 200, 500, 1000, 2000) \n\n\ndf_3m6b_2 <- \n  tibble::tibble(Nlist_3m6b = base::rep(Nlist_3m6b, each = 100)) |> \n  dplyr::mutate(width_3m6b = purrr::map_dbl(Nlist_3m6b, f_3m6b))\n\ndf_3m6b_2 |> \n  ggplot2::ggplot(ggplot2::aes(x = Nlist_3m6b,\n                             y = width_3m6b)) +\n  ggplot2::geom_point(alpha = 1/10) +\n  ggplot2::labs(x = \"Number of samples\",\n                y = \"Width of PI = 0.99\") +\n  ggplot2::geom_hline(yintercept = .05, color = \"red\") +\n  ggplot2::theme_bw()\n```\n\n::: {.cell-output-display}\n![](03-sampling-the-imaginary_files/figure-html/exercise-3m6b-2-1.png){width=672}\n:::\n:::\n\n\nThe difference between samples shrinks as the sample size increases.\n\n> What are we looking at in this plot? The horizontal is sample size. The points are individual interval widths, one for each simulation. The red line is drawn at a width of $0.05$. Looks like we need more than $2000$ tosses of the globe to get the interval to be that precise.\n>\n> The above is a general feature of learning from data: The greatest returns on learning come early on. Each additional observation contributes less and less. So it takes very much effort to progressively reduce our uncertainty. So if your application requires a very precise estimate, be prepared to collect a lot of data. Or to change your approach. ([Solution, Week-01, Winter 2019](https://github.com/rmcelreath/statrethinking_winter2019/blob/master/homework/week01_solutions.pdf))\n\n::::\n:::::\n\n:::\n\n::::\n:::::\n\n***\n\n\n### Hard\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-3h1-5}\n: Reported first and second born children in 100 two-child families\n::::::\n:::\n::::{.my-r-code-container}\n\n::: {.cell hash='03-sampling-the-imaginary_cache/html/exercise-3h1-5_8d423ae0925fd9af78d5b590d07aeaa6'}\n\n```{.r .cell-code}\n## R code 3.28 ###############\nbirth1 <- c(\n  1, 0, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1,\n  1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1,\n  0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 0, 1, 1, 0,\n  1, 0, 1, 1, 1, 0, 1, 1, 1, 1\n)\n\nbirth2 <- c(\n  0, 1, 0, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 1, 0,\n  1, 1, 1, 0, 1, 0, 0, 1, 1, 1, 1, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 1, 1,\n  0, 0, 0, 1, 1, 1, 0, 0, 0, 0\n)\n\n\n## R code 3.30 ###############\nn_boys <- sum(birth1) + sum(birth2)\n```\n:::\n\n200 Births of these are boys:\n\n- 1st born: 51\n- 2nd born: 60, \n- total: 111\n::::\n:::::\n\n#### 3H1\n\n:::::{.my-exercise}\n:::{.my-exercise-header}\nExercise 3H1: Using grid approximation, compute the posterior distribution for the probability of a birth being a boy. Assume a uniform prior probability. Which parameter value maximizes the posterior probability?\n:::\n::::{.my-exercise-container}\n\n::: {.panel-tabset}\n###### Boys (Original)\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-3H1a}\na: Posterior distribution for the probability of a birth being a boy (Original)\n::::::\n:::\n::::{.my-r-code-container}\n\n\n::: {.cell hash='03-sampling-the-imaginary_cache/html/fig-exercise-3h1a_73941458d2cb0f63e4ecc71df5615127'}\n\n```{.r .cell-code}\np_grid_3h1a <- seq(from = 0,\n                   to = 1,\n                   length.out = 1e3)\nprior_3h1a <- rep(0.5, 1e3)\nlikelihood_3h1a <- dbinom(x = sum(birth1) + sum(birth2),\n                          size = 200,\n                          prob = p_grid_3h1a)\nposterior_3h1a <-  prior_3h1a * likelihood_3h1a\nposterior_std_3h1a <- posterior_3h1a / sum(posterior_3h1a)\nplot(p_grid_3h1a, posterior_std_3h1a, type = \"l\")\nmap_3h1a <- p_grid_3h1a[which.max(posterior_std_3h1a)]\n```\n\n::: {.cell-output-display}\n![Posterior distribution of boys rate probability (Original)](03-sampling-the-imaginary_files/figure-html/fig-exercise-3h1a-1.png){#fig-exercise-3h1a width=672}\n:::\n:::\n\n\nThe mode or <a class='glossary' title='In Bayesian statistics a Maximum A Posteriori probability or MAP is essentially the mode of posterior distribution. (CDS, p.272)'>MAP</a> is at 0.555, e.g. the birth ratio for boys is 55.5%.\n\n::::\n:::::\n\n###### Boys (Tidyverse)\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-3h1b}\nb: Posterior distribution for the probability of a birth being a boy (Tidyverse)\n::::::\n:::\n::::{.my-r-code-container}\n\n\n::: {.cell hash='03-sampling-the-imaginary_cache/html/fig-exercise-3h1b_d6f022cb10987a4f258c846e61b3df62'}\n\n```{.r .cell-code}\ndf_3h1b <- tibble::tibble(p_grid_3h1b = base::seq(\n                   from = 0,\n                   to = 1,\n                   length.out = 1e3)) |> \n    dplyr::mutate(prior_3h1b = base::rep(0.5, 1e3),\n           likelihood_3h1b = stats::dbinom(\n                          x = base::sum(birth1) + base::sum(birth2),\n                          size = 200,\n                          prob = p_grid_3h1b),\n           posterior_3h1b = prior_3h1b * likelihood_3h1b,\n           posterior_std_3h1b = posterior_3h1b / sum(posterior_3h1b))\n\nmap_3h1b <- df_3h1b |> \n  dplyr::arrange(dplyr::desc(posterior_std_3h1b)) |> \n  dplyr::summarize(dplyr::first(p_grid_3h1b)) |> \n  dplyr::pull(1)\n\ndf_3h1b |> \n  ggplot2::ggplot(ggplot2::aes(x = p_grid_3h1b,\n                               y = posterior_std_3h1b)) +\n  ggplot2::geom_line() +\n  ggplot2::geom_vline(xintercept = map_3h1b, color = \"red\") +\n  ggplot2::labs(x = \"Ratio of boy births\",\n                y = \"Posterior distribution\") +\n  ggplot2::theme_bw()\n```\n\n::: {.cell-output-display}\n![Posterior distribution of boys rate probability (Tidyverse)](03-sampling-the-imaginary_files/figure-html/fig-exercise-3h1b-1.png){#fig-exercise-3h1b width=672}\n:::\n:::\n\n\nThe mode or <a class='glossary' title='In Bayesian statistics a Maximum A Posteriori probability or MAP is essentially the mode of posterior distribution. (CDS, p.272)'>MAP</a> is at 0.555, e.g. the birth ratio for boys is 55.5%.\n\n:::::{.my-note}\n:::{.my-note-header}\nNote: {*tidybayes*} point intervals needs samples\n:::\n::::{.my-note-container}\n\nI computed the mode by arranging the data frame with the highest value at the top. This is exactly the same value as in the book version. Another Base R solution would be `df_3h1b$p_grid_3h1b[which.max(df_3h1b$posterior_std_3h1b)]` = 55.4554555%.\n\nI tried to calculate the mode also with the {**tidybayes**} package. But all mode values from this package (`mode_qi()`, `mode_hdci()`, `mode_hdi()` and `Mode())` result in smaller values, for instance `tidybayes::Mode(samples_3m2b$p_samples_3m2b)` = 51.2%. \n\nAfter many trials and exerpiments I came to the conclusion that above mentioned functions of the {**tidybayes**} package work only with generated samples. Therefore I do not have to address two columns as with the `which.max()` (one outside and one inside the square brackets) and I have to supply vectors with the above mentioned family of function form the {**tidybayes**} package.\n\nFurthermore I noticed that all point_intervals without `mode_`, `median_` and `mean_` in front of the `qi`, `ll`, `ul`, `hdi`, `hdci` is not in {**tidybayes**} but in the accompanying package {**ggdist**} and need therefore as prefix `ggdist::`. Furthermore these functions needs numerical vectors and can't therfore used with the pipe.\n\n::::\n:::::\n\n\n\n\n\n\n::::\n:::::\n\n\n\n\n:::\n\n\n\n\n::::\n:::::\n\n***\n\n\n\n#### 3H2\n\n:::::{.my-exercise}\n:::{.my-exercise-header}\nExercise 3H2: Using the `sample()` function, draw $10,000$ random parameter values from the posterior distribution you calculated above. Use these samples to estimate the $50\\%$, $89\\%$, and $97\\%$ highest posterior density intervals.\n:::\n::::{.my-exercise-container}\n\n::: {.panel-tabset}\n###### Sample (Original)\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-3h2a}\na: Draw $10,000$ random parameter values from the posterior distribution you calculated above (Original)\n::::::\n:::\n::::{.my-r-code-container}\n\n\n::: {.cell hash='03-sampling-the-imaginary_cache/html/fig-exercise-3h2a_62703c1cd7f24feb85862d479cd232cf'}\n\n```{.r .cell-code}\nset.seed(100)\nsamples_3h2a <- sample(x = p_grid_3h1a,\n                       size = 1e4,\n                       replace = TRUE,\n                       prob = posterior_std_3h1a)\nrethinking::HPDI(samples_3h2a, c(.5, .89, .97))\n\nmap_3h2a <- rethinking::chainmode(samples_3h2a, adj = 1)\n\nrethinking::dens(samples_3h2a, adj = 1)\nabline(v = map_3h2a, col = \"red\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>     |0.97     |0.89      |0.5      0.5|     0.89|     0.97| \n#> 0.4824825 0.4994995 0.5265265 0.5725726 0.6076076 0.6296296\n```\n\n\n:::\n\n::: {.cell-output-display}\n![10.000 samples from the posterior distribution of the birth data (Original)](03-sampling-the-imaginary_files/figure-html/fig-exercise-3h2a-1.png){#fig-exercise-3h2a width=672}\n:::\n:::\n\n\nThe red line is the density mode (0.555) calculated with `rethinking::chainmode()`.\n\n::::\n:::::\n\n###### Sample (Tidyverse)\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-3h2b}\nb: Draw $10,000$ random parameter values from the posterior distribution you calculated above (Tidyverse)\n::::::\n:::\n::::{.my-r-code-container}\n\n::: {.cell hash='03-sampling-the-imaginary_cache/html/fig-exercise-3h2b_c234b48dcb34f0dddbdb1dfcb123215d'}\n\n```{.r .cell-code}\nset.seed(100)\nsamples_3h2b <-  df_3h1b |> \n  dplyr::slice_sample(n = 1e4,\n                      replace = TRUE,\n                      weight_by = posterior_std_3h1b)\n(\n  map_3h2b <- samples_3h2b |> \n    tidybayes::mode_hdi(p_grid_3h1b, .width = c(.5, .89, .97)) \n)\n\nsamples_3h2b |> \n  ggplot2::ggplot(ggplot2::aes(x = p_grid_3h1b)) +\n  ggplot2::geom_density() +\n  ggplot2::geom_vline(xintercept = map_3h2b[[1, 1]], color = \"red\") +\n  ggplot2::labs(x = \"Ratio of boy births\",\n                y = \"Samples from the posterior distribution\") +\n  ggplot2::theme_bw()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> # A tibble: 3 × 6\n#>   p_grid_3h1b .lower .upper .width .point .interval\n#>         <dbl>  <dbl>  <dbl>  <dbl> <chr>  <chr>    \n#> 1       0.555  0.531  0.577   0.5  mode   hdi      \n#> 2       0.555  0.504  0.613   0.89 mode   hdi      \n#> 3       0.555  0.483  0.632   0.97 mode   hdi\n```\n\n\n:::\n\n::: {.cell-output-display}\n![10.000 samples from the posterior distribution of the birth data (Tidyverse)](03-sampling-the-imaginary_files/figure-html/fig-exercise-3h2b-1.png){#fig-exercise-3h2b width=672}\n:::\n:::\n\n\nThe red line is the density mode (0.555) calculated with `tidybayes::mode_hdi()` and also displayed in the column `p_grid_3h1b`.\n\n::::\n:::::\n\n\n\n\n\n:::\n\n::::\n:::::\n\n\n\n\n***\n\n#### 3H3\n\n:::::{.my-exercise}\n:::{.my-exercise-header}\nExercise 3H3: Use `rbinom()` to simulate $10,000$ replicates of $200$ births. You should end up with $10,000$ numbers, each one a count of boys out of $200$ births. Compare the distribution of predicted numbers of boys to the actual count in the data ($111$ boys out of $200$ births). There are many good ways to visualize the simulations, but the `dens()`  command (part of the {**rethinking**} package) is probably the easiest way in this case. Does it look like the model fits the data well? That is, does the distribution of predictions include the actual observation as a central, likely outcome?\n:::\n::::{.my-exercise-container}\n\n::: {.panel-tabset}\n###### 3H3a \n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-3h3a}\na: Posterior predictive distribution with 10,000 replicates of 200 births (Original)\n::::::\n:::\n::::{.my-r-code-container}\n\n\n\n::: {.cell hash='03-sampling-the-imaginary_cache/html/fig-exercise-3h3a_c355d6b30eb303aca6217f7a6c95859e'}\n\n```{.r .cell-code}\nset.seed(100)\ndummy_data_3h3a <-  rbinom(n = 1e4,\n                           size = 200,\n                           prob = samples_3h2a)\nhead(dummy_data_3h3a, 10)\n\nrethinking::dens(dummy_data_3h3a, \n                 adj = 1)\nabline(v = sum(birth1 + birth2), col = \"red\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>  [1] 105 124  98 102  94  96  98 107 101 108\n```\n\n\n:::\n\n::: {.cell-output-display}\n![Create posterior predictive distribution with 10,000 replicates of 200 births (Original)](03-sampling-the-imaginary_files/figure-html/fig-exercise-3h3a-1.png){#fig-exercise-3h3a width=672}\n:::\n:::\n\n\nThe model appears to fit well, because the observed value of 111 boys is in the middle of the <a class='glossary' title='An approach to assessing model fit. It is the distribution for future predicted data based on the data you have already seen. Measures of discrepancy between the estimated model and the data are constructed and their posterior predictive distribution compared to the discrepancy observed for the dataset. (CDS, p. 334)'>posterior predictive distribution</a> which has a mean of 110.7847 and a median of 111.\n\n::::\n:::::\n\n\n###### 3H3b\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-3h3b}\nb: Posterior predictive distribution with 10,000 replicates of 200 births (Tidyverse)\n::::::\n:::\n::::{.my-r-code-container}\n\n\n::: {.cell hash='03-sampling-the-imaginary_cache/html/fig-exercise-3h3b_4658c2cb6900b28dd402d89e72a359a3'}\n\n```{.r .cell-code}\nset.seed(100)\ndummy_data_3h3b <-  stats::rbinom(n = 1e4,\n                           size = 200,\n                           prob = samples_3h2b$p_grid_3h1b\n                           )\nutils::head(dummy_data_3h3b, 10)\n\nggplot2::ggplot() +\n  ggdist::stat_slabinterval(ggplot2::aes(x = dummy_data_3h3b),\n                            .width = c(0.66, 0.89), color = \"red\",\n                            slab_fill = \"grey\", slab_color = \"black\",\n                            density = \"bounded\") +\n  ggplot2::geom_vline(\n    ggplot2::aes(xintercept = n_boys), linetype = \"dashed\", color = \"red\") +\n  ggplot2::labs(x = \"Number of Boys\", y = \"Density\") +\n  ggplot2::theme_bw()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>  [1] 105 124  98 102  94  96  98 107 101 108\n```\n\n\n:::\n\n::: {.cell-output-display}\n![Create posterior predictive distribution with 10,000 replicates of 200 births (Tidyverse)](03-sampling-the-imaginary_files/figure-html/fig-exercise-3h3b-1.png){#fig-exercise-3h3b width=672}\n:::\n:::\n\n\nI have used the graphic function from the {**ggdist**}\n resp. {**tidybayes**} package. I learned about this familiy of functions from the [solution by Jake Thompson](https://sr2-solutions.wjakethompson.com/bayesian-inference#chapter-3). \n \nThe model appears to fit well, because the observed value of 111 boys is in the middle of the <a class='glossary' title='An approach to assessing model fit. It is the distribution for future predicted data based on the data you have already seen. Measures of discrepancy between the estimated model and the data are constructed and their posterior predictive distribution compared to the discrepancy observed for the dataset. (CDS, p. 334)'>posterior predictive distribution</a> which has a mean of 110.7847 and a median of 111.\n\n::::\n:::::\n\n:::\n\n\n::::\n:::::\n\n***\n\n#### 3H4\n\n:::::{.my-exercise}\n:::{.my-exercise-header}\nExercise 3H4: Now compare $10,000$ counts of boys from $100$ simulated first borns only to the number of boys in the first births, `birth1`. How does the model look in this light?\n:::\n::::{.my-exercise-container}\n\n::: {.panel-tabset}\n\n###### 3H4a\n\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-3h4a}\na: Compare $10,000$ counts of boys from $100$ simulated first borns (Original)\n::::::\n:::\n::::{.my-r-code-container}\n\n\n::: {.cell hash='03-sampling-the-imaginary_cache/html/fig-exercise-3h4a_f48dffab6835e16f5834354eb9d811a0'}\n\n```{.r .cell-code}\nset.seed(100)\ndummy_data_3h4a <-  rbinom(n = 1e4,\n                           size = 100,\n                           prob = samples_3h2a)\n\nutils::head(dummy_data_3h4a, 10)\nmap_3h4a <- rethinking::chainmode(dummy_data_3h4a, adj = 1)\n\nrethinking::dens(dummy_data_3h4a, adj = 0.7)\nabline(v = sum(birth1), col = \"blue\")\nabline(v = map_3h4a, col = \"red\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>  [1] 51 60 59 48 56 49 50 52 46 62\n```\n\n\n:::\n\n::: {.cell-output-display}\n![Compare 10,000 counts of boys from 100 simulated first borns (Original)](03-sampling-the-imaginary_files/figure-html/fig-exercise-3h4a-1.png){#fig-exercise-3h4a width=672}\n:::\n:::\n\n\nObserved first born boys: 51\n\nSimulation of first born boys:\n\n- Mean: 55.3639\n- Median: 55\n- Mode: 54.961\n\nWith the <a class='glossary' title='An approach to assessing model fit. It is the distribution for future predicted data based on the data you have already seen. Measures of discrepancy between the estimated model and the data are constructed and their posterior predictive distribution compared to the discrepancy observed for the dataset. (CDS, p. 334)'>posterior predictive distribution</a> for the first born boys the model does not appears to fit well, because the observed value of 51 boys (blue line) is not in the middle of the distribution.\n\n::::\n:::::\n\n\n###### 3H4b\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-3h4b}\nb: Compare $10,000$ counts of boys from $100$ simulated first borns (Tidyverse)\n::::::\n:::\n::::{.my-r-code-container}\n\n\n::: {.cell hash='03-sampling-the-imaginary_cache/html/fig-exercise-3h4b_13dbb9c574d4f2a46b510e6c10a9d56a'}\n\n```{.r .cell-code}\nset.seed(100)\ndummy_data_3h4b <-  stats::rbinom(n = 1e4,\n                           size = 100,\n                           prob = samples_3h2b$p_grid_3h1b\n                           )\nutils::head(dummy_data_3h4b, 10)\n\nmap_3h4b <- tidybayes::Mode(dummy_data_3h4b)\n\nggplot2::ggplot() +\n  ggdist::stat_slabinterval(ggplot2::aes(x = dummy_data_3h4b),\n                            .width = c(0.66, 0.89), color = \"red\",\n                            slab_fill = \"grey\", slab_color = \"black\",\n                            density = \"bounded\") +\n  ggplot2::geom_vline(\n    ggplot2::aes(xintercept = sum(birth1)), linetype = \"dashed\", color = \"blue\") +\n  ggplot2::geom_vline(\n    ggplot2::aes(xintercept = map_3h4b), linetype = \"dashed\", color = \"red\") +\n  ggplot2::labs(x = \"Number of 1st born boys\", y = \"Density\") +\n  ggplot2::theme_bw()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>  [1] 51 60 59 48 56 49 50 52 46 62\n```\n\n\n:::\n\n::: {.cell-output-display}\n![Compare 10,000 counts of boys from 100 simulated first borns (Tidyverse)](03-sampling-the-imaginary_files/figure-html/fig-exercise-3h4b-1.png){#fig-exercise-3h4b width=672}\n:::\n:::\n\n\nObserved first born boys: 51\n\nSimulation of first born boys:\n\n- Mean: 55.3639\n- Median: 55\n- Mode: 55\n\nWith the <a class='glossary' title='An approach to assessing model fit. It is the distribution for future predicted data based on the data you have already seen. Measures of discrepancy between the estimated model and the data are constructed and their posterior predictive distribution compared to the discrepancy observed for the dataset. (CDS, p. 334)'>posterior predictive distribution</a> for the first born boys the model does not appears so well as for all boys in @cnj-3h3b, because the observed value of 51 boys (blue line) is not in the middle of the distribution. However, it does not appear to be a large discrepancy, as the observed value is still within the middle 66% interval.\n\n\n::::\n:::::\n\n\n:::\n\n\n::::\n:::::\n\n***\n\n#### 3H5\n\n:::::{.my-exercise}\n:::{.my-exercise-header}\nExercise 3H5: The model assumes that sex of first and second births are independent. To check this assumption, focus now on second births that followed female first borns. Compare 10,000 simulated counts of boys to only those second births that followed girls. To do this correctly, you need to count the number of first borns who were girls and simulate that many births, 10,000 times. Compare the counts of boys in your simulations to the actual observed count of boys following girls. How does the model look in this light? Any guesses what is going on in these data?\n:::\n::::{.my-exercise-container}\n\n::: {.panel-tabset}\n###### 3H5a\n\n\n\n\n\n::: {.cell hash='03-sampling-the-imaginary_cache/html/fig-exercise-3h5a_064979de2255a9481f18abe1177655a5'}\n\n```{.r .cell-code}\ndf_birth_3h5a <- as.data.frame(cbind(birth1, birth2))\ndf_birth_3h5a <- subset(df_birth_3h5a, birth1 == 0)\n\nn_1st_girls_3h5a <- 100 - sum(birth1)\nn_2nd_boys_3h5a <- sum(df_birth_3h5a$birth1) + sum(df_birth_3h5a$birth2)\n\np_grid_3h5a <- seq(from = 0,\n                   to = 1,\n                   length.out = 1e3)\nprior_3h5a <- rep(0.5, 1e3)\nlikelihood_3h5a <- dbinom(x = n_2nd_boys_3h5a,\n                              size = n_1st_girls_3h5a,\n                              prob = p_grid_3h5a)\nposterior_3h5a <-  prior_3h5a * likelihood_3h5a\nposterior_std_3h5a <- posterior_3h5a / sum(posterior_3h5a)\n\nset.seed(100)\ndummy_data_3h5a <-  rbinom(n = 1e4,\n                           size = n_1st_girls_3h5a,\n                           prob = samples_3h2a)\nrethinking::dens(dummy_data_3h5a, \n                 adj = 1,\n                 xlab = \"Number of 2nd born boys that follow a 1st born girl\")\nabline(v = n_2nd_boys_3h5a, col = \"blue\")\n```\n\n::: {.cell-output-display}\n![Second births of boys that followed female first borns (Original)](03-sampling-the-imaginary_files/figure-html/fig-exercise-3h5a-1.png){#fig-exercise-3h5a width=672}\n:::\n:::\n\nThe model predicts 27 2nd born boys that follow a 1st born girl. But we have observed 39 boys. Our model underestimates the number of 2nd born boys so that our assumption that births are independent must be challenged.\n\n###### 3H5b\n\n\n::: {.cell hash='03-sampling-the-imaginary_cache/html/fig-exercise-3h5b_ff34a5cf6b09c01cfd305536d5c5284c'}\n\n```{.r .cell-code}\nn_1st_girls_3h5b <- 100 - sum(birth1)\nn_2nd_boys_3h5b <- sum(birth2[which(birth1 == 0)])\n\n\nset.seed(100)\ndummy_data_3h5b <- rbinom(1e4, size = n_1st_girls_3h5b, \n            prob = samples_3h2b$p_grid_3h1b)\n\nmap_3h5b <-  tidybayes::Mode(dummy_data_3h5b)\n\nggplot2::ggplot() +\n  ggdist::stat_slabinterval(ggplot2::aes(x = dummy_data_3h5b),\n                            .width = c(0.66, 0.89), color = \"red\",\n                            slab_fill = \"grey\", slab_color = \"black\",\n                            density = \"bounded\") +\n  ggplot2::geom_vline(\n    ggplot2::aes(xintercept = n_2nd_boys_3h5b), linetype = \"dashed\", color = \"blue\") +\n  ggplot2::geom_vline(\n    ggplot2::aes(xintercept = map_3h5b), linetype = \"dashed\", color = \"red\") +\n  ggplot2::labs(x = \"Number of 2nd born boys that follow a 1st born girl\", \n       y = \"Density\") +\n  ggplot2::theme_bw()\n```\n\n::: {.cell-output-display}\n![Second births of boys that followed female first borns (Tidyverse)](03-sampling-the-imaginary_files/figure-html/fig-exercise-3h5b-1.png){#fig-exercise-3h5b width=672}\n:::\n:::\n\n\nThe model predicts 27 2nd born boys that follow a 1st born girl. But we have observed 39 boys. Our model underestimates the number of 2nd born boys so that our assumption that births are independent appears to be violated. We have generally more 2nd born boys (60% versus 51%) but especially more 2nd born boys when the first born was a girl (79.59%).\n\n\n:::\n\n\n::::\n:::::\n\n## Session info\n\n\n::: {.cell hash='03-sampling-the-imaginary_cache/html/session-info_cb59a4a54b76de31d871c8ab9ede1f4d'}\n\n```{.r .cell-code}\nutils::sessionInfo()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> R version 4.3.2 (2023-10-31)\n#> Platform: x86_64-apple-darwin20 (64-bit)\n#> Running under: macOS Sonoma 14.1.1\n#> \n#> Matrix products: default\n#> BLAS:   /Library/Frameworks/R.framework/Versions/4.3-x86_64/Resources/lib/libRblas.0.dylib \n#> LAPACK: /Library/Frameworks/R.framework/Versions/4.3-x86_64/Resources/lib/libRlapack.dylib;  LAPACK version 3.11.0\n#> \n#> locale:\n#> [1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8\n#> \n#> time zone: Europe/Vienna\n#> tzcode source: internal\n#> \n#> attached base packages:\n#> [1] stats     graphics  grDevices utils     datasets  methods   base     \n#> \n#> other attached packages:\n#>  [1] brms_2.20.4         Rcpp_1.0.11         patchwork_1.1.3    \n#>  [4] lubridate_1.9.3     forcats_1.0.0       stringr_1.5.1      \n#>  [7] dplyr_1.1.4         purrr_1.0.2         readr_2.1.4        \n#> [10] tidyr_1.3.0         tibble_3.2.1        ggplot2_3.4.4      \n#> [13] tidyverse_2.0.0     glossary_1.0.0.9000\n#> \n#> loaded via a namespace (and not attached):\n#>   [1] svUnit_1.0.6         shinythemes_1.2.0    splines_4.3.2       \n#>   [4] later_1.3.1          cellranger_1.1.0     xts_0.13.1          \n#>   [7] rpart_4.1.21         lifecycle_1.0.4      StanHeaders_2.26.28 \n#>  [10] processx_3.8.2       lattice_0.22-5       MASS_7.3-60         \n#>  [13] insight_0.19.6       crosstalk_1.2.0      ggdist_3.3.0        \n#>  [16] backports_1.4.1      magrittr_2.0.3       rmarkdown_2.25      \n#>  [19] yaml_2.3.7           httpuv_1.6.12        skimr_2.1.5         \n#>  [22] pkgbuild_1.4.2       gld_2.6.6            multcomp_1.4-25     \n#>  [25] abind_1.4-5          expm_0.999-7         tidybayes_3.0.6     \n#>  [28] TH.data_1.1-2        tensorA_0.36.2       sandwich_3.0-2      \n#>  [31] rmutil_1.1.10        inline_0.3.19        spatial_7.3-17      \n#>  [34] bridgesampling_1.1-2 commonmark_1.9.0     codetools_0.2-19    \n#>  [37] DT_0.30              xml2_1.3.5           tidyselect_1.2.0    \n#>  [40] shape_1.4.6          bayesplot_1.10.0     farver_2.1.1        \n#>  [43] stable_1.1.6         matrixStats_1.1.0    stats4_4.3.2        \n#>  [46] base64enc_0.1-3      jsonlite_1.8.7       e1071_1.7-13        \n#>  [49] ellipsis_0.3.2       survival_3.5-7       emmeans_1.8.9       \n#>  [52] tools_4.3.2          DescTools_0.99.50    glue_1.6.2          \n#>  [55] gridExtra_2.3        xfun_0.41            cmdstanr_0.5.3      \n#>  [58] distributional_0.3.2 loo_2.6.0            withr_2.5.2         \n#>  [61] timeSeries_4031.107  fastmap_1.1.1        boot_1.3-28.1       \n#>  [64] fansi_1.0.5          shinyjs_2.1.0        callr_3.7.3         \n#>  [67] digest_0.6.33        timechange_0.2.0     R6_2.5.1            \n#>  [70] mime_0.12            estimability_1.4.1   colorspace_2.1-0    \n#>  [73] gtools_3.9.4         markdown_1.11        threejs_0.3.3       \n#>  [76] modeest_2.4.0        utf8_1.2.4           generics_0.1.3      \n#>  [79] data.table_1.14.8    class_7.3-22         httr_1.4.7          \n#>  [82] prettyunits_1.2.0    htmlwidgets_1.6.2    pkgconfig_2.0.3     \n#>  [85] dygraphs_1.1.1.6     gtable_0.3.4         Exact_3.2           \n#>  [88] timeDate_4022.108    htmltools_0.5.7      clue_0.3-65         \n#>  [91] scales_1.2.1         rethinking_2.40      lmom_3.0            \n#>  [94] posterior_1.5.0      knitr_1.45           rstudioapi_0.15.0   \n#>  [97] tzdb_0.4.0           reshape2_1.4.4       statip_0.2.3        \n#> [100] coda_0.19-4          checkmate_2.3.0      nlme_3.1-163        \n#> [103] curl_5.1.0           repr_1.1.6           proxy_0.4-27        \n#> [106] zoo_1.8-12           rootSolve_1.8.2.4    parallel_4.3.2      \n#> [109] miniUI_0.1.1.1       fBasics_4032.96      pillar_1.9.0        \n#> [112] grid_4.3.2           vctrs_0.6.4          shinystan_2.6.0     \n#> [115] promises_1.2.1       arrayhelpers_1.1-0   xtable_1.8-4        \n#> [118] cluster_2.1.4        evaluate_0.23        mvtnorm_1.2-3       \n#> [121] cli_3.6.1            compiler_4.3.2       rlang_1.1.2         \n#> [124] crayon_1.5.2         rstantools_2.3.1.1   rversions_2.1.2     \n#> [127] labeling_0.4.3       ps_1.7.5             plyr_1.8.9          \n#> [130] stringi_1.8.1        rstan_2.32.3         viridisLite_0.4.2   \n#> [133] QuickJSR_1.0.7       munsell_0.5.0        colourpicker_1.3.0  \n#> [136] bayestestR_0.13.1    Brobdingnag_1.2-9    V8_4.4.0            \n#> [139] Matrix_1.6-3         hms_1.1.3            stabledist_0.7-1    \n#> [142] shiny_1.8.0          igraph_1.5.1         RcppParallel_5.1.7  \n#> [145] readxl_1.4.3\n```\n\n\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}