# Sampling the Imaginary {#sec-chap03}

:::::{.my-objectives}
:::{.my-objectives-header}
Learning Objectives:
:::
::::{.my-objectives-container}

This chapter teaches the basic skills for working with samples from the
posterior distribution. We'll begin to use samples to summarize and
simulate model output. The skills learned here will apply to every
problem in the remainder of the book, even though the details of the
models and how the samples are produced will vary.

The chapter exploits the fact that people are better in counts than in
probabilities. We will take the probability distributions from the
previous chapter and sampling from them to produce counts.
::::
:::::

```{r}
#| label: setup

library(tidyverse)
```

## Vampire Example {.unnumbered}

### ORIGINAL {.unnumbered}

:::::{.my-definition}
:::{.my-definition-header}
:::::: {#def-chap-03-1}
: Probability Notation
::::::
:::
::::{.my-definition-container}
As a repetition and to get a better understanding of the following formulae in this section I read a very [basic introduction into probability notation]((https://www.mathsisfun.com/data/probability-events-conditional.html))

$P(A)$ means "**Probability Of Event A**".

:::::{.my-example}
:::{.my-example-header}
Probability of an Event
:::
::::{.my-example-container}
What is the probability of $2$ after throwing a dice?
$$P(A) = \frac{1}{6}$$
::::
:::::

$P(B \mid A)$ means "**Probability of Event B given A**". 

This is a conditional probability. After event $A$ has happened, what is the probability of $B$? If the events are independent from each other than the changes do not influence each other. 

:::::{.my-example}
:::{.my-example-header}
Independent Conditional Events
:::
::::{.my-example-container}

The probability to throw $2$ in a second dice throw are still $P(B \mid A) = \frac{1}{6}$. If the events are dependent of each other then "Probability of event A and event B equals the probability of event A times the probability of event B given event A."

$$
P(A \space and\space B) = P(A) \times P(B \mid A)
$$


::::
:::::

:::::{.my-example}
:::{.my-example-header}
Dependent Conditional Events
:::
::::{.my-example-container}
    
Typical example is removing marble from a bag without replacement. Let's take a red marble from a bag of $5$ red and $5$ blue marbles without replacement. Here the probability of a red marble (in the second draw) given the probability of a red marble (in the first draw) is

$$
\frac{5}{10} \times \frac{4}{9} = \frac{2}{9}
$$

::::
:::::
::::
:::::


#### a) Medical Test Scenario with Bayes theorem {.unnumbered}

> “suppose there is a blood test that correctly detects vampirism 95% of the time. In more precise and mathematical notation, $Pr(\text{positive test result} \mid vampire) = 0.95$. It’s a very accurate test, nearly always catching real vampires. It also make mistakes, though, in the form of false positives. One percent of the time, it incorrectly diagnoses normal people as vampires, $Pr(\text{positive test result}|mortal) = 0.01$. The final bit of information we are told is that vampires are rather rare, being only $0.1\%$ of the population, implying $Pr(vampire) = 0.001$. Suppose now that someone tests positive for vampirism. What’s the probability that he or she is a bloodsucking immortal?” ([McElreath, 2020, p. 49](zotero://select/groups/5243560/items/NFUEVASQ)) ([pdf](zotero://open-pdf/groups/5243560/items/CPFRPHX8?page=68&annotation=W9MU6VCZ))

> “The correct approach is just to use Bayes’ theorem to invert the probability, to compute $Pr(vampire|positive)$. The calculation can be presented as:

$$
\begin{align*}
Pr(vampire\mid positive) = \frac{Pr(positive\mid vampire) Pr(vampire)}{Pr(positive)}\\
\text{where Pr(positive) is the average probability of a positive test result, that is,}\\ Pr(positive) = Pr(positive \mid vampire) Pr(vampire) \\
+ Pr(positive \mid mortal) 1 − Pr(vampire)
\end{align*}
$$ {#eq-vampire}
” ([McElreath, 2020, p. 49](zotero://select/groups/5243560/items/NFUEVASQ)) ([pdf](zotero://open-pdf/groups/5243560/items/CPFRPHX8?page=68&annotation=X4KD33AT))


:::::{.my-r-code}
:::{.my-r-code-header}
:::::: {#cnj-vampire-bayes-a}
a: Performing vampire calculation with `r glossary("Bayes’ theorem")` in Base R
::::::
:::
::::{.my-r-code-container}

```{r}
#| label: vampire-bayes-a

## R code 3.1a Vampire ##################
Pr_Positive_Vampire_a <- 0.95
Pr_Positive_Mortal_a <- 0.01
Pr_Vampire_a <- 0.001
Pr_Positive_a <- Pr_Positive_Vampire_a * Pr_Vampire_a +
  Pr_Positive_Mortal_a * (1 - Pr_Vampire_a)

( 
  Pr_Vampire_Positive_a <- Pr_Positive_Vampire_a * Pr_Vampire_a / Pr_Positive_a
)

```

::::
:::::


There is only an `r Pr_Vampire_Positive_a`% chance that the suspect is actually a vampire.

> “Most people find this result counterintuitive. And it’s a very important result, because it mimics the structure of many realistic testing contexts, such as HIV and DNA testing, criminal profiling, and even statistical significance testing (see the Rethinking box at the end of this section). Whenever the condition of interest is very rare, having a test that finds all the true cases is still no guarantee that a positive result carries much information at all. The reason is that most positive results are false positives, even when all the true positives are detected correctly” ([McElreath, 2020, p. 49](zotero://select/groups/5243560/items/NFUEVASQ)) ([pdf](zotero://open-pdf/groups/5243560/items/CPFRPHX8?page=68&annotation=CMMR49PQ))

#### b) Medical test scenario with natural frequencies {.unnumbered}

> “There is a way to present the same problem that does make it more intuitive” ([McElreath, 2020, p. 50](zotero://select/groups/5243560/items/NFUEVASQ)) ([pdf](zotero://open-pdf/groups/5243560/items/CPFRPHX8?page=69&annotation=2DWF7729))

```         
(1)  In a population of 100,000 people, 100 of them are vampires.
(2)  Of the 100 who are vampires, 95 of them will test positive for vampirism.
(3)  Of the 99,900 mortals, 999 of them will test positive for vampirism.
```

There are 999 + 95 = `r 999 + 95` people tested positive. But from these
people only 95 / (999 + 95) = `r (95 / (999 + 95)) * 100` % are actually
vampires.

Or with a slightly different wording it is still easier to
understand: 

1. We can just count up the number of people who test positive: $95 + 999 = 1094$. 
2. Out of these $1094$ positive tests, $95$ of them are real vampires, so that implies:

$$
Pr(positive \mid vampire) = \frac{95}{1094}
$$


:::::{.my-r-code}
:::{.my-r-code-header}
:::::: {#cnj-vampire-frequencies-a}
a: Performing vampire calculation with frequencies in Base R
::::::
:::
::::{.my-r-code-container}
```{r}
#| label: vampire-frequencies-a


pr_vampire_a2 <-  100 / 100000
pr_positive_vampire_a2 <-  95 / 100
pr_positive_mortal_a2  <-  999 / 99900
pr_positive_a2 <-  95 + 999

(
  pr_vampire_positive_a2 <-  
    pr_positive_vampire_a2 * 100 / pr_positive_a2
)

```

::::
:::::



> “The second presentation of the problem, using counts rather than probabilities, is often called the frequency format or natural frequencies. Why a frequency format helps people intuit the correct approach remains contentious. Some people think that human psychology naturally works better when it receives information in the form a person in a natural environment would receive it. In the real world, we encounter counts only. No one has ever seen a probability, the thinking goes. But everyone sees counts (“frequencies”) in their daily lives.” ([McElreath, 2020, p. 50](zotero://select/groups/5243560/items/NFUEVASQ)) ([pdf](zotero://open-pdf/groups/5243560/items/CPFRPHX8?page=69&annotation=G26ZTDUZ))


> “many scientists are uncomfortable with integral calculus, even though they have strong and valid intuitions about how to summarize data. Working with samples transforms a problem in calculus into a problem in data summary, into a frequency format problem. An integral in a typical Bayesian context is just the total probability in some interval. That can be a challenging calculus problem. But once you have samples from the probability distribution, it’s just a matter of counting values in the interval. An empirical attack on the posterior allows the scientist to ask and answer more questions about the model, without relying upon a captive mathematician. For this reason, it is easier and more intuitive to work with samples from the posterior, than to work with probabilities and integrals directly.” ([McElreath, 2020, p. 51](zotero://select/groups/5243560/items/NFUEVASQ)) ([pdf](zotero://open-pdf/groups/5243560/items/CPFRPHX8?page=70&annotation=M7I2DV3C))

### TIDYVERSE {.unnumbered}

#### a) Medical Test Scenario with Bayes theorem {.unnumbered}


:::::{.my-important}
:::{.my-important-header}
Vectors in Base R are tibble columns in tidyverse
:::
::::{.my-important-container}
Whenever there is a calculation with vectors the pendant in tidyverse mode is to generate columns in a tibble with `tibble::tibble()` or if there is already a data frame with `dplyr::mutate()` and to do the appropriate calculation with these columns.

The following @cnj-vampire-bayes-a transformed the Base R calculation @cnj-vampire-bayes-b into a computation using the tidyverse approach.
::::
:::::

:::::{.my-r-code}
:::{.my-r-code-header}
:::::: {#cnj-vampire-bayes-b}
b: Performing the calculation using Bayes’ theorem with tidyverse approach in R
::::::
:::
::::{.my-r-code-container}

```{r}
#| label: vampire-bayes-b

## R code 3.1b Vampire ##########

tibble::tibble(pr_positive_vampire_b = .95,
       pr_positive_mortal_b  = .01,
       pr_vampire_b          = .001) |> 
  dplyr::mutate(pr_positive_b = pr_positive_vampire_b * pr_vampire_b
         + pr_positive_mortal_b * (1 - pr_vampire_b)) |> 
  dplyr::mutate(pr_vampire_positive_b = 
           pr_positive_vampire_b * pr_vampire_b / pr_positive_b) |> 
  dplyr::glimpse()
```

::::
:::::


#### b) Medical test scenario with natural frequencies {.unnumbered}

:::::{.my-r-code}
:::{.my-r-code-header}
:::::: {#cnj-vampire-frequencies-b}
b: Performing the calculation using frequencies with tidyverse approach in R
::::::
:::
::::{.my-r-code-container}

```{r}
#| label: vampire-frequencies-b

tibble::tibble(pr_vampire_b2          = 100 / 100000,
       pr_positive_vampire_b2 = 95 / 100,
       pr_positive_mortal_b2  = 999 / 99900)  |>  
  dplyr::mutate(pr_positive_b2 = 95 + 999) |> 
  dplyr::mutate(pr_vampire_positive_b2 = 
                  pr_positive_vampire_b2 * 100 / pr_positive_b2) |> 
  dplyr::glimpse()

```

::::
:::::


## Sampling from a grid-approximate posterior {#sec-chap-03-sampling-grid}

### ORIGINAL

Before we are going to draw samples from the posterior distribution we
need to compute the distribution similar as we had done in the globe tossing example.

> “Here’s a reminder for how to compute the posterior for the globe tossing model, using grid approximation. Remember, the posterior here means the probability of p conditional on the data.” ([McElreath, 2020, p. 52](zotero://select/groups/5243560/items/NFUEVASQ)) ([pdf](zotero://open-pdf/groups/5243560/items/CPFRPHX8?page=71&annotation=KKQLR3FL))

:::::{.my-r-code}
:::{.my-r-code-header}
:::::: {#cnj-grid-globe-tossing-a}
a: Generate the posterior distribution form the globe-tossing example (Base R)
::::::
:::
::::{.my-r-code-container}

```{r}
#| label: grid-globe-tossing-a

### R code 3.2a Grid Globe ##########################
# change prob_b to prior
# change prob_data to likelihood
# added variables: n_grid_a, n_success_a, n_trials_a

n_grid_a <- 1000L # number of grid points
n_success_a <- 6L # observed water
n_trials_a <-  9L # number of trials


p_grid_a <- seq(from = 0, to = 1, length.out = n_grid_a)
prior_a <- rep(1, n_grid_a) # = prior, = uniform distribution, 1000 times 1
likelihood_a <- 
  dbinom(n_success_a, size = n_trials_a, prob = p_grid_a) # = likelihood
posterior_a <- likelihood_a * prior_a
posterior_a <- posterior_a / sum(posterior_a)
```

::::
:::::

> “Now we wish to draw 10,000 samples from this posterior. Imagine the posterior is a bucket full of parameter values, numbers such as $0.1, 0.7, 0.5, 1,$ etc. Within the bucket, each value exists in proportion to its posterior probability, such that values near the peak are much more common than those in the tails. We’re going to scoop out 10,000 values from the bucket. Provided the bucket is well mixed, the resulting samples will have the same proportions as the exact posterior density. Therefore the individual values of $p$ will appear in our samples in proportion to the posterior plausibility of each value.” ([McElreath, 2020, p. 52](zotero://select/groups/5243560/items/NFUEVASQ)) ([pdf](zotero://open-pdf/groups/5243560/items/CPFRPHX8?page=71&annotation=GS5GCASA))


:::::{.my-r-code}
:::{.my-r-code-header}
:::::: {#cnj-sample-globe-tossing}
a: Draw 1000 samples from the posterior distribution (Base R)
::::::
:::
::::{.my-r-code-container}

```{r}
#| label: sample-globe-tossing-a

n_samples_a <- 1e4

set.seed(3) # for reproducibility

## R code 3.3a Sample Globe ##########################################
samples_a <- sample(p_grid_a, 
                    prob = posterior_a, # from previous code chunk
                    size = n_samples_a, replace = TRUE)
```

::::
:::::

The probability of each value is given by `posterior_a`, which we computed with @cnj-grid-globe-tossing-a.

:::::{.my-note}
:::{.my-note-header}
:::::: {#cor-excursion-a}
: Details for a better understanding and comparison with the tidyverse version
::::::
:::
::::{.my-note-container}

To compare with the tidyverse version, I collected the three vectors with `base::cbind()` into a matrix and displayed the first six lines with `utils::head()`. Additionally I
also displayed the first 10 values of `samples_a` vector.

:::::{.my-r-code}
:::{.my-r-code-header}
:::::: {#cnj-excursion-a}
a: Excursion for better comparison (Base R)
::::::
:::
::::{.my-r-code-container}

```{r}
#| label: excursion_a

# display grid results to compare with variant b
d_a <- cbind(p_grid_a, prior_a, likelihood_a, posterior_a) 
head(d_a, 10)

# display sample results to compare with variant b
head(samples_a, 10)
```


::::
:::::


::::
:::::

:::::{.my-r-code}
:::{.my-r-code-header}
:::::: {#cnj-globe-glossing-scatterplot-a}
a: Scatterplot of the drawn samples (Base R)
::::::
:::
::::{.my-r-code-container}

```{r}
#| label: fig-globe-tossing-scatterplot-a
#| fig-cap: "Scatterplot of the drawn samples (Base R)"

## R code 3.4a Globe Scatterplot #############
plot(samples_a)
```

::::
:::::


> In fig-globe-glossing-plot-a “it’s as if you are flying over the posterior distribution, looking down on it. There are many more samples from the dense region near 0.6 and very few samples below 0.25. On the right, the plot shows the density estimate computed from these samples.” ([McElreath, 2020, p. 53](zotero://select/groups/5243560/items/NFUEVASQ)) ([pdf](zotero://open-pdf/groups/5243560/items/CPFRPHX8?page=72&annotation=4WVLNZBT))


:::::{.my-r-code}
:::{.my-r-code-header}
:::::: {#cnj-globe-tossing-density-plot-a}
a: Density estimate of the drawn samples (Rethinking)
::::::
:::
::::{.my-r-code-container}

```{r}
#| label: fig-globe-tossing-density-plot-a
#| fig-cap: "Density estimate of the drawn samples (Rethinking)"

## R code 3.5a Globe Density plot #############
rethinking::dens(samples_a)
```


::::
:::::


### TIDYVERSE

:::::{.my-r-code}
:::{.my-r-code-header}
:::::: {#cnj-grid-globe-tossing-b}
b: Generate the posterior distribution form the globe-tossing example (Tidyverse)
::::::
:::
::::{.my-r-code-container}

```{r}
#| label: grid-globe-tossing-b


## R code 3.2b Grid Globe #####################

# how many grid points would you like?
n_grid_b <- 1000L
n_success_b <- 6L
n_trials_b  <- 9L

(
  d_b <-
  tibble::tibble(p_grid_b = seq(from = 0, to = 1, length.out = n_grid_b),
         prior_b  = 1) |>  # flat uniform prior, vector 1L recycling
  dplyr::mutate(likelihood_b = 
                  dbinom(n_success_b, size = n_trials_b, prob = p_grid_b)) |> 
  dplyr::mutate(posterior_b = 
                  (likelihood_b * prior_b) / sum(likelihood_b * prior_b))
)

```


::::
:::::

:::::{.my-watch-out}
:::{.my-watch-out-header}
Variable names changed
:::
::::{.my-watch-out-container}
I have changed McElreath's variable name `prob_p` and `prob_data` as `prior_x` and
`likelihood_x`, where `x` stands for `a` (Base R) or `b` (Tidyverse).

To see the difference between grid and samples I will add "\_sample" to all the other variable names.
::::
:::::

:::::{.my-r-code}
:::{.my-r-code-header}
:::::: {#cnj-sample-globe-tossing-b}
b: Draw 1000 samples from the posterior distribution (Tidyverse)
::::::
:::
::::{.my-r-code-container}

```{r}
#| label: sample-globe-tossing-b


## R code 3.3b Sample Globe #####################
# how many samples would you like?
n_samples_b <- 1e4

# make it reproducible
set.seed(3)

df_samples_b <-
  d_b |> 
    dplyr::slice_sample(n = n_samples_b, weight_by = posterior_b, replace = T)

( 
  df_samples_b <- df_samples_b |>
      dplyr::rename(samples_b = p_grid_b,
             likelihood_samples_b = likelihood_b,
             prior_samples_b = prior_b,
             posterior_samples_b = posterior_b)
)


identical(samples_a, df_samples_b$samples_b)
```


::::
:::::

The column `samples_b` is identical with vector `samples_a`, because I have used in both sampling processes `set.seed(3)`, so that I (and you) could reproduce the data. 


There are different possibilities to display data frames respectively tibbles:

1. You can use the internal print facility of tibbles. It shows only the first ten rows and all columns that fit on the screen. You see an example in @cnj-sample-globe-tossing-b.
2. With the `utils::str()` function you will get a result with shorter figures that is better adapted to a small screen.
3. Another alternative is the tidyverse approach of `dplyr::glimpse()`.
4. With `skimr::skim()` you will get a compact summary of all data.


:::::{.my-r-code}
:::{.my-r-code-header}
:::::: {#cnj-excursion-b}
b: Excursion: Printing varieties for better comparison (Tidyverse)
::::::
:::
::::{.my-r-code-container}

```{r}
#| label: excursion-b
#| results: hold

glue::glue('USING THE str() FUNCTION:')
utils::str(df_samples_b)
glue::glue('#####################################################\n\n')
glue::glue('USING THE dplyr::glimpse() FUNCTION:')
dplyr::glimpse(df_samples_b)
glue::glue('#####################################################\n\n')
glue::glue('USING THE skimr::skim() FUNCTION:')
skimr::skim(df_samples_b)
```

::::
:::::


We can plot the left panel of Figure 3.1 from the book with `ggplot2::geom_point()`. But before we do, we'll need to add a variable numbering the samples. This is necessary as the x-parameter of the plot.

:::::{.my-r-code}
:::{.my-r-code-header}
:::::: {#cnj-globe-tossing-scatterplot-b}
b: Scatterplot of the drawn samples (Tidyverse)
::::::
:::
::::{.my-r-code-container}

```{r}
#| label: fig-globe-tossing-scatterplot-b
#| fig-cap: "Scatterplot of the drawn samples (Tidyverse)"


## R code 3.4b Globe Scatterplot ########################
df_samples_b |> 
  dplyr::mutate(sample_number = 1:dplyr::n()) |> 
  
  ggplot2::ggplot(ggplot2::aes(x = sample_number, y = samples_b)) +
  ggplot2::geom_point(alpha = 1/10) +
  ggplot2::scale_y_continuous("proportion of water (p)", limits = c(0, 1)) +
  ggplot2::xlab("sample number") +
  ggplot2::theme_bw()

```


::::
:::::


If you hover over this link from @fig-globe-tossing-scatterplot-a you can compare the Base R version with the tidyverse result.

Instead of the `rethinking::dens()` we'll plot the density in the right panel of the books Figure 3.1 with `ggplot2::geom_density()`.

:::::{.my-r-code}
:::{.my-r-code-header}
:::::: {#cnj-globe-tossing-densitiy-plot-b1}
b: Density estimate of the drawn samples with 1e4 grid points (Tidyverse)
::::::
:::
::::{.my-r-code-container}

```{r}
#| label: fig-globe-tossing-density-plot-b1
#| fig-cap: "Density estimate of the drawn samples with 1e4 grid points (Tidyverse)"

## R code 3.5b(1) Globe Density ###########################
df_samples_b |> 
  ggplot2::ggplot(ggplot2::aes(x = samples_b)) +
  ggplot2::geom_density(fill = "grey") +
  ggplot2::scale_x_continuous("proportion of water (p)", limits = c(0, 1)) +
  ggplot2::theme_bw()

```

::::
:::::


Compare this somewhat smoother tidyverse plot with @fig-globe-tossing-density-plot-a.

> “You can see that the estimated density is very similar to ideal posterior you computed via grid approximation. If you draw even more samples, maybe 1e5 or 1e6, the density estimate will get more and more similar to the ideal.” ([McElreath, 2020, p. 53](zotero://select/groups/5243560/items/NFUEVASQ)) ([pdf](zotero://open-pdf/groups/5243560/items/CPFRPHX8?page=72&annotation=EXBQWX2M))
 
Here's what it looks like with `1e6`.
 
:::::{.my-r-code}
:::{.my-r-code-header}
:::::: {#cnj-ID-text}
b: Density estimate of the drawn samples with 1e6 grid points (Tidyverse)
::::::
:::
::::{.my-r-code-container}

```{r}
#| label: fig-globe-tossing-density-plot-b2
#| fig-cap: "Density estimate of the drawn samples with 1e6 grid points (Tidyverse)"

set.seed(3)

## R code 3.5b(2) Globe Density ###########################
d_b |> 
  dplyr::slice_sample(n = 1e6, weight_by = posterior_b, replace = T) |>
  
  ggplot2::ggplot(ggplot2::aes(x = p_grid_b)) +
  ggplot2::geom_density(fill = "grey") +
  ggplot2::scale_x_continuous("proportion of water (p)", limits = c(0, 1)) +
  ggplot2::theme_bw()

```


::::
:::::

## Sampling to Summarize {#sec-sampling-to-summarize}

All we have done so far is crudely replicate the posterior density we
had already computed in the previous chapter. Now it is time to use
these samples to describe and understand the posterior.

The description to understand the posterior can be divided into three inquiries:

1.  Questions about intervals of *defined boundaries*. See @sec-chap-03-defined-boundaries.
2.  Questions about intervals of *defined probability mass*. See @sec-chap-03-probability-mass.
3.  Questions about *point estimates*. See: @sec-chap-03-point-estimates.

### Intervals of Defined Boundaries {#sec-chap-03-defined-boundaries}

#### ORIGINAL

##### Grid-approximate Posterior

For instance: What is the probability that the proportion of water is
less than 0.5?

> “Using the grid-approximate posterior, you can just add up all of the probabilities, where the corresponding parameter value is less than 0.5:” ([McElreath, 2020, p. 53](zotero://select/groups/5243560/items/NFUEVASQ)) ([pdf](zotero://open-pdf/groups/5243560/items/CPFRPHX8?page=72&annotation=Z7XSZ6WT))

:::::{.my-r-code}
:::{.my-r-code-header}
:::::: {#cnj-grid-posterior-a}
a: Define boundaries using the grid-approximate posterior (Base R)
::::::
:::
::::{.my-r-code-container}

```{r}
#| label: grid-posterior-a

## R code 3.6a Grid Posterior Boundary ##############################
# add up posterior probability where p < 0.5
sum(posterior_a[p_grid_a < 0.5])
```

::::
:::::


About 17% of the posterior probability is below 0.5. 

##### Samples from the Posterior

But this easy calculation based on grid approximation is often not
practical when there are more parameters. In this case you can draw samples from the posterior. But this approach requires a different calculation:


> “This approach does generalize to complex models with many parameters, and so you can use it everywhere. All you have to do is similarly add up all of the samples below 0.5, but also // divide the resulting count by the total number of samples. In other words, find the frequency of parameter values below 0.5” (McElreath, 2020, p. 53/54)” ([McElreath, 2020, p. 53](zotero://select/groups/5243560/items/NFUEVASQ)) ([pdf](zotero://open-pdf/groups/5243560/items/CPFRPHX8?page=72&annotation=SMQ6B78K))

:::::{.my-r-code}
:::{.my-r-code-header}
:::::: {#cnj-sample-boundary-a}
a: Compute posterior probability below 0.5 using the sampling approach (Base R)
::::::
:::
::::{.my-r-code-container}

```{r}
#| label: sample-boundary-a

## R code 3.7a Sample Boundary #############################
(p_boundary_a <- sum(samples_a < 0.5) / 1e4)
```


::::
:::::

:::::{.my-watch-out}
:::{.my-watch-out-header}
Different values with samples from the posterior
:::
::::{.my-watch-out-container}
In comparison with the value of the posterior probability below 0.5 in the book of 0.1726 the result in `r p_boundary_a` from @cnj-sample-boundary-a is quite different. 

The reason for the difference is that you can't get the same values in a
sampling processes. This is the nature of randomness. And McElreath did
not include the `set.seed()` function for (exact) reproducibility. 
::::
:::::

Using the same approach, you can ask how much posterior probability lies
between 0.5 and 0.75:

:::::{.my-r-code}
:::{.my-r-code-header}
:::::: {#cnj-sample-interval-a}
a: Compute posterior probability between 0.5 and 0.75 using the sampling approach (Base R)
::::::
:::
::::{.my-r-code-container}

```{r}
#| label: sample-interval-a

## R code 3.8a Sample Interval #############################
(p_boundary_a8 <- sum(samples_a > 0.5 & samples_a < 0.75) / 1e4)
```

::::
:::::



#### TIDYVERSE

##### Grid-approximate Posterior

> To get the proportion of water less than some value of `p_grid_b`
> within the {**tidyverse}**, you might first `filter()` by that value
> and then take the `sum()` within `summarise()`. ([Kurz](https://bookdown.org/content/4857/sampling-the-imaginary.html#intervals-of-defined-boundaries.))

:::::{.my-r-code}
:::{.my-r-code-header}
:::::: {#cnj-grid-boundary-b}
b: Compute posterior probability below 0.5 using the grid approach (Tidyverse)
::::::
:::
::::{.my-r-code-container}

```{r}
#| label: grid-boundary-b

## R code 3.6b Grid Boundary ######################
# add up posterior probability where p < 0.5
d_b |> dplyr::filter(p_grid_b < 0.5) |> 
    dplyr::summarize(sum = base::sum(posterior_b))

```

::::
:::::


##### Samples from the Posterior

Kurz offers several methods to calculate the posterior probability below 0.5: 

1. **Method**: `filter()` & `n()` within `summarize()`
2. **Method**: `count()` followed by `mutate()`
3. **Method**: Logical condition within `mean()`

:::::{.my-r-code}
:::{.my-r-code-header}
:::::: {#cnj-sample-boundary}
b: Compute posterior probability below 0.5 using the sampling approach with different methods (Tidyverse)
::::::
:::
::::{.my-r-code-container}
```{r}
#| label: sample-boundary-b
#| results: hold

# add up all posterior probabilities of samples under .5
## R code 3.7b Sample Boundary #########################

###### Method (1) #######
method_1 <- 
  df_samples_b |> 
      dplyr::filter(samples_b < .5) |> 
      dplyr::summarize(sum = dplyr::n() / n_samples_b)

glue::glue('Method 1:\n')
method_1
glue::glue('##################################################\n\n')

###### Method (2) #######
method_2 <- 
  df_samples_b |> 
    dplyr::count(samples_b < .5) |> 
    dplyr::mutate(probability = n_samples_b / base::sum(n_samples_b))

glue::glue('Method 2:\n')
method_2
glue::glue('##################################################\n\n')

###### Method (3) #######
method_3 <- 
  df_samples_b |> 
      dplyr::summarize(sum = mean(samples_b < .5))

glue::glue('Method 3:\n')
method_3


```

::::
:::::


To determine the posterior probability between 0.5 and 0.75, you can use
`&` within `filter()`. Just multiply that result by 100 to get the value
in percent.

:::::{.my-r-code}
:::{.my-r-code-header}
:::::: {#cnj-sample-interval-b}
b: Compute posterior probability between 0.5 and 0.75 using the sampling approach (Tidyverse)
::::::
:::
::::{.my-r-code-container}

```{r}
#| label: sample-interval-b

## R code 3.8b Sample Interval ##############
df_samples_b |> 
    dplyr::filter(samples_b > .5 & samples_b < .75) |> 
    dplyr::summarize(sum = dplyr::n() / n_samples_b)

```


::::
:::::

And, of course, you can do this calculation with the other methods as well.



To produce the top part of Figure 3.2 of the book we apply following code lines:

:::::{.my-r-code}
:::{.my-r-code-header}
:::::: {#cnj-fig-upper-part-3-2}
b: Posterior distribution produced with {**tidyverse**} approach
::::::
:::
::::{.my-r-code-container}

```{r}
#| label: fig-upper-part-3.2-b
#| fig-cap: "Upper part of SR2 Figure 3.2: Intervals of defined boundaries produced with {**tidyverse**} tools: Left: The blue area is the posterior probability below a parameter value of 0.5. Right: The posterior probability between 0.5 and 0.75."

## R Code Fig 3.2 Upper Part #############
# upper left panel
p1 <-
  df_samples_b  |>  
  ggplot2::ggplot(ggplot2::aes(x = samples_b, y = posterior_samples_b)) +
  ggplot2::geom_line() +
  ggplot2::geom_area(data = df_samples_b  |>  
         dplyr::filter(samples_b < .5), fill = "deepskyblue") +
  ggplot2::labs(x = "proportion of water (p)", y = "density")  +
  ggplot2::theme_bw()

# upper right panel
p2 <- 
  df_samples_b  |>  
  ggplot2::ggplot(ggplot2::aes(x = samples_b, y = posterior_samples_b)) +
  ggplot2::geom_line() +
  ggplot2::geom_area(data = df_samples_b  |>  
         dplyr::filter(samples_b > .5 & samples_b < .75), fill = "deepskyblue") +
  ggplot2::labs(x = "proportion of water (p)", y = "density") +
  ggplot2::theme_bw()

library(patchwork)
p1 + p2
```


::::
:::::

### Intervals of Defined Probability Mass {#sec-chap-03-probability-mass}

#### ORIGINAL

##### Quantiles

:::::{.my-definition}
:::{.my-definition-header}
:::::: {#def-probability-mass-intervals}
: Several Terms for Intervals of Defined Probability Mass
::::::
:::
::::{.my-definition-container}
- `r glossary("Confidence Interval")`: Term chiefly used in frequentist statistics.
- `r glossary("Credible Interval")`: Term chiefly in Bayesian statistics.
- `r glossary("Compatibility Interval")`: Term preferably used by Richard McElreath.

The abbreviation for all three versions of probability mass intervals is "CI".

McElreath tries to avoid the semantic of "confidence" or "credibility" because

> “What the interval indicates is a range of parameter values compatible with the model and data. The model and data themselves may not inspire confidence, in which case the interval will not either.” ([McElreath, 2020, p. 54](zotero://select/groups/5243560/items/NFUEVASQ)) ([pdf](zotero://open-pdf/groups/5243560/items/CPFRPHX8?page=73&annotation=BHMW5CJ4))



::::
:::::

The values of these intervals can be found easier with by using samples from the posterior than by using a grid approximation.

> “Suppose for example you want to know the boundaries of the lower $80\%$ posterior probability. You know this interval starts at $p = 0$. To find out where it stops, think of the samples as data and ask where the $80th$ percentile lies:” ([McElreath, 2020, p. 54](zotero://select/groups/5243560/items/NFUEVASQ)) ([pdf](zotero://open-pdf/groups/5243560/items/CPFRPHX8?page=73&annotation=3SA8YJWX))


:::::{.my-r-code}
:::{.my-r-code-header}
:::::: {#cnj-quantiles-a}
a: Compute posterior probability intervals lower $80\%$ and from 10th to 90th percentile
::::::
:::
::::{.my-r-code-container}

```{r}
#| label: quantiles-a

## R code 3.9a Quantile 0.8 #######################
q8 <- quantile(samples_a, 0.8)

## R code 3.10a PI = Quantile 0.1-0.9 ###################
q1_9 <- quantile(samples_a, c(0.1, 0.9))

```

- Lower $80\%$ = `r q8`
- Between $10\%$ = `r q1_9[1]` and $90\%$ = `r q1_9[2]`
::::
:::::

##### Percentile Interval (PI)

The second calculation returns the middle 80% of the distribution

> “Intervals of this sort, which assign equal probability mass to each tail, are very common in the scientific literature. We’ll call them `r glossary("percentile", "percentile intervals")`  (PI). These intervals do a good job of communicating the shape of a distribution, as long as the distribution isn’t too asymmetrical. But in terms of supporting inferences about which parameters are consistent with the data, they are not perfect.” ([McElreath, 2020, p. 55](zotero://select/groups/5243560/items/NFUEVASQ)) ([pdf](zotero://open-pdf/groups/5243560/items/CPFRPHX8?page=74&annotation=5GPNVTUH))

But they do not work well with highly skewed data. See @fig-skewed-dist-a where the posterior is consistent with observing three waters in three tosses and a uniform (flat) prior.

:::::{.my-r-code}
:::{.my-r-code-header}
:::::: {#cnj-fig-skewed-dist-a}
a: Skewed posterior distribution observing three waters in three tosses and a uniform (flat) prior (Base R)
::::::
:::
::::{.my-r-code-container}

```{r}
#| label: fig-skewed-dist-a
#| fig-cap: "Skewed posterior distribution observing three waters in three tosses and a uniform (flat) prior. It is highly skewed, having its maximum value at the boundary where p equals 1."

## R code 3.11a Skewed data #####################
p_grid_skewed_a <- seq(from = 0, to = 1, length.out = 1000)
prior_skewed_a <- rep(1, 1000)
likelihood_skewed_a <- dbinom(3, size = 3, prob = p_grid_skewed_a)
posterior_skewed_a <- likelihood_skewed_a * prior_skewed_a
posterior_skewed_a <- posterior_skewed_a / sum(posterior_skewed_a)

set.seed(3) # added to make sampling distribution reproducible (pb)
samples_skewed_a <- sample(p_grid_skewed_a, 
             size = 1e4, replace = TRUE, prob = posterior_skewed_a)

# added to show the skewed posterior distribution (pb)
rethinking::dens(samples_skewed_a)
```

::::
:::::


> “[The `r glossary("percentile", "percentile interval")`] assigns 25% of the probability mass above and below the interval. So it provides the central 50% probability. But in this example, it ends up excluding the most probable parameter values, near p = 1. So in terms of describing the shape of the posterior distribution—which is really all these intervals are asked to do—the percentile interval can be misleading.” ([McElreath, 2020, p. 56](zotero://select/groups/5243560/items/NFUEVASQ)) ([pdf](zotero://open-pdf/groups/5243560/items/CPFRPHX8?page=75&annotation=96JZPRGW))

`rethinking::PI()` is just a shorthand for the base R `stats::quantile()` function.

:::::{.my-r-code}
:::{.my-r-code-header}
:::::: {#cnj-pi-a1}
a: Computing the Percentile Interval (PI)
::::::
:::
::::{.my-r-code-container}

```{r}
#| label: pi-a1

## R code 3.12a(1) PI ############################
rethinking::PI(samples_skewed_a, prob = 0.5)
```

::::
:::::

:::::{.my-procedure}
:::{.my-procedure-header}
:::::: {#prp-pi-a1}
: Probability mass (PI) `prob = 0.6` equals the interval between $20-80\%$
::::::
:::
::::{.my-procedure-container}

`rethinking::PI()` is just a shorthand for the base R `stats::quantile()` function. Instead of providing the interval explicitly (for instance $20-80\%$) we just say that we want the central $60\%$ = PI of `prob = 0.6`. 

`rethinking::PI()` simplifies the following three steps:

1. We divide always the percentage assigned to the `prob` value by 2: 60% / 2 = 30$ 
2. We subtract, respectively add this value to 50: 50% - 30% = 20% and 50% + 30% = 80% 
3. The result is the probability mass between 20-80%.
::::
:::::

:::::{.my-r-code}
:::{.my-r-code-header}
:::::: {#cnj-pi-a2}
a: Compute PI between $20-80\%$ (Rethinking and Base R)
::::::
:::
::::{.my-r-code-container}

```{r}
#| label: pi-a2
#| results: hold

## R code 3.12a(2) PI ############################

glue::glue('Central Propbability Mass calculated with rethinking::PI()\n')
rethinking::PI(samples_skewed_a, prob = 0.6)
glue::glue('########################################################\n\n')
glue::glue('Central Propbability Mass calculated with stats::quantile()\n')
quantile(samples_skewed_a, prob = c(.20, .80))
```

::::
:::::

##### Highest Posterior Density Interval (HPDI)

To include the most probable parameter value, the modus or `r glossary("MAP")` we should calculate the `r glossary("HPDI")`:

> “The HPDI is the narrowest interval containing the specified probability mass. If you think about it, there must be an infinite number of posterior intervals // with the same mass. But if you want an interval that best represents the parameter values most consistent with the data, then you want the densest of these intervals. That’s what the HPDI is.” (McElreath, 2020, p. 56/57)

:::::{.my-r-code}
:::{.my-r-code-header}
:::::: {#cnj-hpdi-a}
a: Compute Highest Posterior Density Interval (HPDI) (Rethinking / Base R)
::::::
:::
::::{.my-r-code-container}

```{r}
#| label: rethinking-HPDI-a

## R code 3.13a HPDI ###############################
rethinking::HPDI(samples_skewed_a, prob = 0.5)
```


::::
:::::

:::::{.my-note}
:::{.my-note-header}
:::::: {#cor-pi-hpdo}
: HPDI versus PI
::::::
:::
::::{.my-note-container}
**Advantages of HPDI**

1. HPDI captures the parameters with highest posterior probability
2. HPDI is noticeably narrower than PI. In our example `r round(rethinking::HPDI(samples_skewed_a, prob = 0.5)[[2]] - rethinking::HPDI(samples_skewed_a, prob = 0.5)[[1]], 3)` versus `r `round(rethinking::PI(samples_skewed_a, prob = 0.5)[[2]] - rethinking::PI(samples_skewed_a, prob = 0.5)[[1]], 3)`.

But this is only valid if we have a very skewed distribution. 

**Disadvantages of HPDI**

1. HPDI is more computationally intensive than PI
2. HPDI is sensitive of the number of samples drawn (= greater simulation variance)
3. HPDI is more difficult to understand

**Remember, the entire posterior distribution is the Bayesian estimate**

> “Overall, if the choice of interval type makes a big difference, then you shouldn’t be using intervals to summarize the posterior. Remember, the entire posterior distribution is the Bayesian 'estimate.' It summarizes the relative plausibilities of each possible value of the parameter. Intervals of the distribution are just helpful for summarizing it. If choice of interval leads to different inferences, then you’d be better off just plotting the entire posterior distribution.” ([McElreath, 2020, p. 58](zotero://select/groups/5243560/items/NFUEVASQ)) ([pdf](zotero://open-pdf/groups/5243560/items/CPFRPHX8?page=77&annotation=XGHNSWCG))

::::
:::::

“[I]n most cases, these two types of interval are very similar.58 They only look so different in this case because the posterior distribution is highly skewed.” ([McElreath, 2020, p. 57](zotero://select/groups/5243560/items/NFUEVASQ)) ([pdf](zotero://open-pdf/groups/5243560/items/CPFRPHX8?page=76&annotation=FQPNEVHV))n 

:::::{.my-r-code}
:::{.my-r-code-header}
:::::: {#cnj-pi-hpdi-symmetric-dist-a}
a: Compare PI and HPDI of symmetric distributions: Six 'Water', 9 tosses
::::::
:::
::::{.my-r-code-container}

```{r}
#| label: pi-hpdi-symmetric-dist-a

pi8a <- rethinking::PI(samples_a, prob = 0.8)
hpdi8a <- rethinking::HPDI(samples_a, prob = 0.8)

pi95a <- rethinking::PI(samples_a, prob = 0.95)
hpdi95a <- rethinking::HPDI(samples_a, prob = 0.95)
```

- PI 80% = `r pi8a` versus HPDI 80% = `r hpdi8a`.
- PI 95% = `r pi95a` versus HPDI 95% = `r hpdi95a`.

::::
:::::

The 95% interval in frequentist statistics is just a convention, there are no analytical reasons why you should choose exactly this interval. But convenience is not a serious
criterion. So what to do instead?


:::::{.my-tip}
:::{.my-tip-header}
Instead of 95% intervals use the widest interval that excludes the value you want to report or provide a series of nested intervals
:::
::::{.my-tip-container}

> “If you are trying to say that an interval doesn’t include some value, then you might use the widest interval that excludes the value. Often, all compatibility intervals do is communicate the shape of a distribution. In that case, a series of nested intervals may be more useful than any one interval. For example, why not present 67%, 89%, and 97% intervals, along with the median? Why these values? No reason. They are prime numbers, which makes them easy to remember. But all that matters is they be spaced enough to illustrate the shape of the posterior. And these values avoid 95%, since conventional 95% intervals encourage many readers to conduct unconscious hypothesis tests.” ([McElreath, 2020, p. 56](zotero://select/groups/5243560/items/NFUEVASQ)) ([pdf](zotero://open-pdf/groups/5243560/items/CPFRPHX8?page=75&annotation=TG2LCZAG))

::::
:::::

:::::{.my-note}
:::{.my-note-header}
Boundaries versus Probability Mass Intervals
:::
::::{.my-note-container}

**Boundaries**: 

- We ask for a **probability of frequencies**.
- Result is a **percentage of probability**.
- Boundaries are grounded on the **probability (`prob`) values ($0-1$)**.

**Probability Mass**: 

- We ask for a specified **amount of posterior probability**.
- Result is the probability value of the **percentage of frequencies** we looked for.
- Probability Mass is grounded on the **percentage of probabilities ($0-100\%$)**.

::::
:::::

#### TIDYVERSE

##### Quantiles

Kurz offers again different methods --- this time to calculate probability mass:

1. **Method**: Since we saved our `samples_b` samples within the `df_samples_b`
tibble, we'll have to index with `$` within `stats::quantile()`.
2. **Method**: For an alternative approach, we could `dplyr::select()` the `samples_b`
vector, extract it from the tibble with `dplyr::pull()`, and then pump
it into `stats::quantile()`.

  > `pull()` is similar to `$`. It's mostly useful because it looks a
  > little nicer in pipes, it also works with remote data frames, and it
  > can optionally name the output. ([`dplyr::pull()` help file "Extract a single column"](https://dplyr.tidyverse.org/reference/pull.html))

3. **Method**: We might also use `stats::quantile()` within `dplyr::summarize()`.

:::::{.my-r-code}
:::{.my-r-code-header}
:::::: {#cnj-quantiles-b1}
b: Compute posterior probability mass intervals of $80\%$ with different methods
::::::
:::
::::{.my-r-code-container}

```{r}
#| label: quantiles-b1
#| results: hold


## R code 3.9b Quantile 0.8 diff. approaches   #######################
###### Method (1) #######
method_1 <- q80 <- 
  quantile(df_samples_b$samples_b, probs = .8)

glue::glue('Method 1:\n')
method_1
glue::glue('##################################################\n\n')

###### Method (2) #######
method_2 <- 
  df_samples_b |> 
    dplyr::pull(samples_b) |> 
    quantile(probs = .8)

glue::glue('Method 2:\n')
method_2
glue::glue('##################################################\n\n')

###### Method (3) #######
method_3 <- 
  df_samples_b |> 
    dplyr::summarize(q80_2 = quantile(samples_b, probs = .8))

glue::glue('Method 3:\n')
method_3

```


::::
:::::



##### Percentile Interval (PI)

Here's the `summarize()` approach with two probabilities returning the `r glossary("percentile", "percentile interval")`  (PI).

:::::{.my-r-code}
:::{.my-r-code-header}
:::::: {#cnj-pi-b1}
b: Compute probability mass of 80% with summarize method
::::::
:::
::::{.my-r-code-container}

```{r}
#| label: pi-b1

## R code 3.10b(1) PI = Quantile 0.1-0.9 ###################
df_samples_b |> 
    dplyr::summarize(q10 = quantile(samples_b, probs = .1),
              q90 = quantile(samples_b, probs = .9))
    

```
::::
:::::


Kurz refers also to a now deprecated calculation using the vector feature of R to summarize different quantiles with one line. 

***
```
samples_b |> dplyr::summarize(q10_90 = quantile(samples_b, probs = c(.1, .9)))
```
***

This produces nowadays the following warning message:

::: {.callout-warning}
Warning: Returning more (or less) than 1 row per `summarise()` group was deprecated in dplyr 1.1.0.

Please use `reframe()` instead.

When switching from `summarise()` to `reframe()`, remember that `reframe()` always returns an ungrouped data frame and adjust accordingly.
:::

Therefore I am going to change `dplyr::summarize()` to `dplyr::reframe()`.

:::::{.my-r-code}
:::{.my-r-code-header}
:::::: {#cnj-reframe}
b: Using `dplyr::reframe()` to compute probability mass intervals of 80%
::::::
:::
::::{.my-r-code-container}

```{r}
#| label: quantile-reframe

## R code 3.10b(2) PI = Quantile 0.1-0.9 ###################
df_samples_b |> 
    dplyr::reframe(q10_90 = quantile(samples_b, probs = c(.1, .9)))
```

:::::{.my-note}
:::{.my-note-header}
:::::: {#cor-reframe}
: Excursion: Using `dplyr::reframe()` and friends
::::::
:::
::::{.my-note-container}
From the help file of `dplyr::reframe()`:

> While `summarise()` requires that each argument returns a single
> value, and `mutate()` requires that each argument returns the same
> number of rows as the input, `reframe()` is a more general workhorse
> with no requirements on the number of rows returned per group.
>
> `reframe()` creates a new data frame by applying functions to columns
> of an existing data frame. It is most similar to `summarise()`, with
> two big differences:
>
> -   `reframe()` can return an arbitrary number of rows per group,
>     while `summarise()` reduces each group down to a single row.
> -   `reframe()` always returns an ungrouped data frame, while
>     `summarise()` might return a grouped or rowwise data frame,
>     depending on the scenario.
>
> We expect that you'll use `summarise()` much more often than
> `reframe()`, but `reframe()` can be particularly helpful when you need
> to apply a complex function that doesn't return a single summary
> value.

See also the appropriate [section in the blog
post](https://www.tidyverse.org/blog/2023/02/dplyr-1-1-0-pick-reframe-arrange/#reframe)
about changes in {**dplyr**} 1.1.0. The name `reframe()` is in
accordance with `tibble::enframe()` and `tibble::deframe()`:

-   `enframe()`: Takes a vector, returns a data frame
-   `deframe()`: Takes a data frame, returns a vector
-   `reframe()`: Takes a data frame, returns a data frame

::::
:::::

::::
:::::



> The functions of the tidyverse approach typically returns a data
> frame. But sometimes you just want your values in a numeric vector for
> the sake of quick indexing. In that case, base R `stats::quantile()`
> shines: (Kurz in the section: [Intervals of defined mass](https://bookdown.org/content/4857/sampling-the-imaginary.html#intervals-of-defined-mass.))

:::::{.my-r-code}
:::{.my-r-code-header}
:::::: {#cnj-pi-b2}
b: Using `stats::quantile()` to get a vector of a probability mass calculation
::::::
:::
::::{.my-r-code-container}

```{r}
#| label: pi-b2

## R code 3.12b(1) PI = Quantile 0.1-0.9#############################
(q10_q90 = quantile(df_samples_b$samples_b, probs = c(.1, .9)))

```
This is the same method as in R base with the difference that we are working with tibbles and need therefore to use the `$` operator.


::::
:::::


To produce the bottom part of Figure 3.2 of the book we apply following code lines.

:::::{.my-r-code}
:::{.my-r-code-header}
:::::: {#cnj-fig-lower-part-3-2b}
b: Plots of defined mass intervals lower of 80% and the middle 80%
::::::
:::
::::{.my-r-code-container}

```{r}
#| label: fig-lower-part-3-2b
#| fig-cap: "Lower part of SR2 Figure 3.2: Intervals of defined mass produced with {**tidyverse**} tools: Left: Lower 80% posterior probability exists below a parameter value of about 0.75. Right: Middle 80% posterior probability lies between the 10% and 90% quantiles."

## R Code Fig 3.2b Lower Part #############
p1 <-
  df_samples_b |> 
  ggplot2::ggplot(ggplot2::aes(x = samples_b, y = posterior_samples_b)) +
  ggplot2::geom_line() +
  ggplot2::geom_area(data = df_samples_b |> 
                dplyr::filter(samples_b < q80), fill = "deepskyblue") +
  ggplot2::annotate(geom = "text",
           x = .25, y = .0025,
           label = "lower 80%") +
  ggplot2::labs(x = "proportion of water (p)",
       y = "density") +
  ggplot2::theme_bw()

# upper right panel
p2 <- 
  df_samples_b |> 
  ggplot2::ggplot(ggplot2::aes(x = samples_b, y = posterior_samples_b)) +
  ggplot2::geom_line() +
  ggplot2::geom_area(data = df_samples_b |> 
            dplyr::filter(samples_b > q10_q90[[1]] & 
                    samples_b < q10_q90[[2]]), fill = "deepskyblue") +
  ggplot2::annotate(geom = "text",
           x = .25, y = .0025,
           label = "middle 80%") +
  ggplot2::labs(x = "proportion of water (p)",
       y = "density") +
  ggplot2::theme_bw()

library(patchwork)
p1 + p2

```


::::
:::::


Again we will demonstrate the misleading character of `r glossary("Percentile", "Percentile Intervals")` (PIs) with a very skewed distribution.

We've already defined `p_grid_b` and `prior_b` within `d_b`, above. Here
we'll reuse them and create a new tibble by updating all the columns
with the skewed parameters of three 'Water' in three tosses.

To see the difference how the skewed distribution is different to the
Figure 3.2 lower part, I will draw the appropriate figure here myself.

:::::{.my-r-code}
:::{.my-r-code-header}
:::::: {#cnj-fig-skewed-dist-b}
b: Skewed posterior distribution observing three waters in three tosses and a uniform (flat) prior (Tidyverse)
::::::
:::
::::{.my-r-code-container}

```{r}
#| label: fig-skewed-dist-b
#| fig-cap: "Skewed posterior distribution observing three waters in three tosses and a uniform (flat) prior. The distribution is highly skewed, having its maximum value where p equals 1."
#| fig-width: 4
#| figh-height: 5
#| out-width: "50%"
#| fig-align: "center"


## R code 3.11b Skewed data #########################
# here we update the `dbinom()` parameters 
# for values for a skewed distribution
# assuming three trials results in 3 W (Water)

n_samples_skewed_b <- 1e4
n_success_skewed_b <- 3
n_trials_skewed_b  <- 3

# update `d_b` to d_skewed_b
d_skewed_b <-
  d_b |> 
    dplyr::mutate(likelihood_skewed_b = 
        dbinom(n_success_skewed_b,
           size = n_trials_skewed_b, prob = p_grid_b)) |> 
    dplyr::mutate(posterior_skewed_b  = 
          (likelihood_skewed_b * prior_b) / 
          sum(likelihood_skewed_b * prior_b))

# make the next part reproducible
set.seed(3)

# here's our new samples tibble
samples_skewed_b <- 
    d_skewed_b |> 
    dplyr::slice_sample(n = n_samples_skewed_b, 
        weight_by = posterior_skewed_b, replace = T) |> 
    dplyr::rename(p_skewed_b = p_grid_b,
           prior_skewed_b = prior_b)


# added to see the skewed distribution
samples_skewed_b |>  
  ggplot2::ggplot( ggplot2::aes(x = p_skewed_b, y = posterior_skewed_b)) +
  ggplot2::geom_line() +
  ggplot2::theme_bw()
```
::::
:::::

To see how the skewed distribution is different to the book’s
Figure 3.2 lower part, I will draw the appropriate figure here.

:::::{.my-r-code}
:::{.my-r-code-header}
:::::: {#cnj-fig-prob-mass-skewed-dist}
b: Lower 80% and middle 80% of probability mass intervals in the skewed distribution 
::::::
:::
::::{.my-r-code-container}
```{r}
#| label: fig-prob-mass-skewed-dist
#| fig-cap: "Probability mass intervals in a skewed distribution. Left: Lower 80%. right: Middle 80% = 80% Percentile Interval (PI)"



## R code 3.12b(2) PI < 80 & middle 80% #############################
p1 <-
  samples_skewed_b |> 
  ggplot2::ggplot(ggplot2::aes(x = p_skewed_b, y = posterior_skewed_b)) +
  ggplot2::geom_line() +
  ggplot2::geom_area(data = samples_skewed_b |> 
      dplyr::filter(p_skewed_b < q80), fill = "deepskyblue") +
  ggplot2::annotate(geom = "text",
           x = .25, y = .0025,
           label = "lower 80%") +
  ggplot2::labs(x = "proportion of water (p)",
       y = "density") +
  ggplot2::theme_bw()

# upper right panel
p2 <- 
  samples_skewed_b |> 
  ggplot2::ggplot(ggplot2::aes(x = p_skewed_b, y = posterior_skewed_b)) +
  ggplot2::geom_line() +
  ggplot2::geom_area(data = samples_skewed_b |> 
      dplyr::filter(p_skewed_b > q10_q90[[1]] & 
                    p_skewed_b < q10_q90[[2]]), fill = "deepskyblue") +
  ggplot2::annotate(geom = "text",
           x = .25, y = .0025,
           label = "middle 80%") +
  ggplot2::labs(x = "proportion of water (p)",
       y = "density") +
  ggplot2::theme_bw()

library(patchwork)
p1 + p2
```


::::
:::::


##### Introducing tidybayes {.unnumbered}

:::::{.my-resource}
:::{.my-resource-header}
Introducing the {**tidybayes**} package by Matthew Kay
:::
::::{.my-resource-container}
The [{**tidybayes**}](https://mjskay.github.io/tidybayes/) package by [Matthew Kay](https://www.mjskay.com/) offers an array of convenience functions for summarizing Bayesian models. 

> {**tidybayes**} is an R package that aims to make it easy to integrate
> popular Bayesian modeling methods into a tidy data + ggplot workflow.
> It builds on top of (and re-exports) several functions for visualizing
> uncertainty from its sister package,
> [{**ggdist**}](https://mjskay.github.io/ggdist/).

- For an introduction using {**tidybayes**} with {**brms**} see
[Extracting and visualizing tidy draws from {**brms**}
models](https://mjskay.github.io/tidybayes/articles/tidy-brms.html). 

- For a general introduction (not confined to {**brms**}) see [Using tidy data with Bayesian models](https://mjskay.github.io/tidybayes/articles/tidybayes.html) but read also the start page [tidybayes: Bayesian analysis + tidy data + geoms](https://mjskay.github.io/tidybayes/) of the package documentation.

- Besides supporting many types of models there is an additional {**tidybayes.rethinking**} package [available on GitHub](https://mjskay.github.io/tidybayes.rethinking/) that extends {**tidybayes**} to work with the {**rethinking**} package. I think this package is a new development because Kurz didn't mention it. (As far as I know, because at the moment I have read his [version 0.40](https://bookdown.org/content/4857/) only until chapter 4.)

For the following parts the section on [Point Summaries and
Intervals](https://mjskay.github.io/tidybayes/articles/tidy-brms.html#point-summaries-and-intervals)
and the reference on [Point and interval summaries for tidy data frames
of draws from
distributions](https://mjskay.github.io/ggdist/reference/point_interval.html)
are especially important.

The mentioned vignettes above are long articles I haven't read yet. I plan to do this in the next future but for now I am concentrating and trusting on Kurz’ text to apply and explain the most important function parallel to McElreath book chapters.

::::
:::::


:::::{.my-watch-out}
:::{.my-watch-out-header}
Many function names used by Kurz do not apply anymore
:::
::::{.my-watch-out-container}
I had difficulties to use Kurz's functions because there was an
[overhaul in the naming
scheme](https://mjskay.github.io/tidybayes/reference/tidybayes-deprecated.html)
of {**tidybayes**} version 1.0 and a deprecation of horizontal shortcut
geoms and stats in {**tidybayes**} 2.1. Because {**tidybayes**}
integrates function of the sister package {**ggdist**} the [function
descriptions and references of
{**ggdist**}](https://mjskay.github.io/ggdist/reference/index.html) are
also important to consult. For instance all the function on [point and interval summaries](https://mjskay.github.io/ggdist/reference/point_interval.html) are now documented in {**ggdist**}.

There is a systematic change of the function names: The `h` (for 'horizontal') in parameter name of the point estimate was removed. For instance: Instead of median_qih, median_hdih and median_hdcih it is now `tidybayes::median_qi()`, `tidybayes::median_hdi()` and `tidybayes::median_hdci()`. Similar with point_inverhalh, mean_* and mode_*.

***

There is another adaption compared to the Kurz’ version: I can't reproduce the codes with his  `samples` (my `samples_b`) data frame, because the data has changed values recently to the skewed sampling version. To get the same results as Kurz I have to use
in my naming scheme the `skewed` version.
::::
:::::


> The {**tidybayes**} package contains a [family of
functions](https://mjskay.github.io/tidybayes/articles/tidy-brms.html#point-summaries-and-intervals)
that make it easy to summarize a distribution with a measure of central
tendency accompanied by intervals. With `tidybayes::median_qi()`, we
will ask for the median and quantile-based intervals --- just like we've
been doing with `stats::quantile()`. ([Kurz](https://bookdown.org/content/4857/sampling-the-imaginary.html#intervals-of-defined-mass.))


:::::{.my-r-code}
:::{.my-r-code-header}
:::::: {#cnj-median-qi}
: Computing the median quantile interval with {**tidybayes**}
::::::
:::
::::{.my-r-code-container}

```{r}
#| label: median-quantile-interval

tidybayes::median_qi(samples_skewed_b$p_skewed_b, .width = .5)
```


> Note how the `.width` argument within `tidybayes::median_qi()` worked
the same way the `prob` argument did within `rethinking::PI()`. With
`.width = .5`, we indicated we wanted a quantile-based 50% interval,
which was returned in the `ymin` and `ymax` columns.

::::
:::::


:::::{.my-note}
:::{.my-note-header}
:::::: {#cor-point-interval-summaries}
: Point and interval summaries for tidy data frames of draws from distributions
::::::
:::
::::{.my-note-container}

The `qi` in `tidybayes::median_qi()` stands for "quantile interval". The explanation of this function family (`median_qi()`, `mean_qi()` and `mode_qi()`) is now documented in the {**ggdist**} package. 

> The `qi`-variants is the short form of the function family of `tidybayes::point_interval(..., .point = median, .interval = qi)`. 
>
> There are several point intervals that {**tidybayes**} respectively {**ggdist**} computes: 
> 
> - **qi** yields the quantile interval (also known as the percentile interval or equi-tailed interval) as a 1x2 matrix.
> - **hdi** yields the highest-density interval(s) (also known as the highest posterior density interval). Note: If the distribution is multimodal, hdi may return multiple intervals for each probability level (these will be spread over rows). You may wish to use hdci (below) instead if you want a single highest-density interval, with the caveat that when the distribution is multimodal hdci is not a highest-density interval.
> - **hdci** yields the highest-density continuous interval, also known as the shortest probability interval. Note: If the distribution is multimodal, this may not actually be the highest-density interval (there may be a higher-density discontinuous interval, which can be found using hdi).
> - **ll and ul** yield lower limits and upper limits, respectively (where the opposite limit is set to either Inf or -Inf). ([ggdist reference](https://mjskay.github.io/ggdist/reference/point_interval.html))
::::
:::::


> The {**tidybayes**} framework makes it easy to request multiple types of
intervals. In the following code chunk we'll request 50%, 80%, and 99%
intervals.

:::::{.my-r-code}
:::{.my-r-code-header}
:::::: {#cnj-multiple-intervals-b}
b: Requesting multiple type of intervals with {**tidybayes**}
::::::
:::
::::{.my-r-code-container}

```{r}
#| label: multiple-intervals-b

## R code 3.12b(3) different PIs ##############
tidybayes::median_qi(samples_skewed_b$p_skewed_b, .width = c(.5, .8, .99))

```


> The .width column in the output indexed which line presented which
> interval. The value in the y column remained constant across rows.
> That's because that column listed the measure of central tendency, the
> median in this case.
::::
:::::

##### Highest Posterior Density Interval (HPDI)

> Now let's use the `rethinking::HPDI()` function to return 50% highest
> posterior density intervals (HPDIs).

:::::{.my-r-code}
:::{.my-r-code-header}
:::::: {#cnj-rethinking-hpdi-b}
b: Compute Highest Posterior Density Interval (HPDI) (Rethinking / Tidyverse)
::::::
:::
::::{.my-r-code-container}

```{r}
#| label: rethinking-HPDI-b

## R code 3.13b(1) HPDI ###############################
rethinking::HPDI(samples_skewed_b$p_skewed_b, prob = .5)
```


::::
:::::


> The reason I introduce {**tidybayes**} now is that the functions of
> the {**brms**} package only support percentile-based intervals of the
> type we computed with `quantile()` and `median_qi()`. But
> {**tidybayes**} also supports HPDIs.

:::::{.my-watch-out}
:::{.my-watch-out-header}
: Two Version for Highest Density Intervals
:::
::::{.my-watch-out-container}
As already mentioned in @cor-point-interval-summaries there is `hdi`and `hcdi`. Both functions produce the same result in unimodal distributions. 

But in the case of an extreme skewed distribution like our data frame with the observation of 3 'Water' with 3 tosses the `tidybayes::hdi()` functions generates an error.

> Error in quantile.default(dist_y, probs = 1 - .width) :  
> missing values and NaN's not allowed if 'na.rm' is FALSE

My error message with `hdi``` is in contrast to Kurz’ version where this function seems to work. BTW: I got the same error message providing the vector `samples_skewed_a` from the Base R version.

::::
:::::


:::::{.my-r-code}
:::{.my-r-code-header}
:::::: {#cnj-tidyverse-HPDI-b}
: High Density Intervals with {**tidybayes**}
::::::
:::
::::{.my-r-code-container}

::: {.panel-tabset}

###### 6 W, n=9


```{r}
#| label: tidyverse-HPDI-b1
#| results: hold

## R code 3.13b(2a) HPDI 6 Water, 9 tosses #####################
tidybayes::mode_hdi(df_samples_b$samples_b, .width = .5)
tidybayes::mode_hdci(df_samples_b$samples_b, .width = .5)
```


###### 3 W, n=3

```{r}
#| label: tidyverse-HPDI-b2

## R code 3.13b(2b) HPDI 3 Water, 3 tosses #####################
# tidybayes::mode_hdi(samples_skewed_b$p_skewed_b, .width = .5) # generates error
tidybayes::mode_hdci(samples_skewed_b$p_skewed_b, .width = .5)
```

:::


::::
:::::


In contrast to @cnj-multiple-intervals-b and @cnj-rethinking-hpdi-b we used this time the mode as the measure of central tendency. With this
family of {**tidybayes**} functions, you specify the measure of central
tendency in the prefix (i.e., mean, median, or mode) and then the type
of interval you'd like (i.e., `qi()` or `hdci()`).

If all you want are the intervals without the measure of central
tendency or all that other technical information, {**tidybayes**} also
offers the handy `qi()` and `hdi()` functions.

:::::{.my-r-code}
:::{.my-r-code-header}
:::::: {#cnj-pi-4}
: Numbered R Code Title
::::::
:::
::::{.my-r-code-container}
Here include code lines
::::
:::::


```{r}
#| label: pi-4

## R code 3.12b4 PI 0.5 ##############################
tidybayes::qi(samples_skewed_b$p_skewed_b, .width = .5)
```


We have now all necessary skills to plot book’s Figure 3.3:

:::::{.my-r-code}
:::{.my-r-code-header}
:::::: {#cnj-fig-pi-hpdi}
b: Plot the difference between percentile interval (PI) and highest posterior density  intervals (HPDI)
::::::
:::
::::{.my-r-code-container}

```{r}
#| label: fig-pi-hpdi
#| fig-cap: "Reproduction of Figure 3.3 (p.57): The difference between percentile and highest posterior density compatibility intervals. The posterior density here corresponds to a flat prior and observing three water samples in three total tosses of the globe. Left: 50% percentile interval. This interval assigns equal mass (25%) to both the left and right tail. As a result, it omits the most probable parameter value, where p equals 1. Right: 50% highest posterior density interval, HPDI. This interval finds the narrowest region with 50% of the posterior probability. Such a region always includes the most probable parameter value."


## R code Figure 3.3 #######################
# left panel
p1 <-
  samples_skewed_b |> 
  ggplot2::ggplot(ggplot2::aes(x = p_skewed_b, y = posterior_skewed_b)) +
  # check out our sweet `qi()` indexing
  ggplot2::geom_area(data = samples_skewed_b |> 
              dplyr::filter(p_skewed_b >
                tidybayes::qi(samples_skewed_b$p_skewed_b, .width = .5)[1] & 
                     p_skewed_b <
                tidybayes::qi(samples_skewed_b$p_skewed_b, .width = .5)[2]),
                fill = "deepskyblue") +
  ggplot2::geom_line() +
  ggplot2::labs(subtitle = "50% Percentile Interval",
       x = "proportion of water (p)",
       y = "density") +
  ggplot2::theme_bw()

# right panel
p2 <-
  samples_skewed_b |> 
  ggplot2::ggplot(ggplot2::aes(x = p_skewed_b, y = posterior_skewed_b)) +
  ggplot2::geom_area(data = samples_skewed_b |> 
              dplyr::filter(p_skewed_b > 
                 tidybayes::hdci(samples_skewed_b$p_skewed_b, .width = .5)[1] & 
                       p_skewed_b < 
                 tidybayes::hdci(samples_skewed_b$p_skewed_b, .width = .5)[2]),
                 fill = "deepskyblue") +
  ggplot2::geom_line() +
  ggplot2::labs(subtitle = "50% HPDI",
       x = "proportion of water (p)",
       y = "density") +
  ggplot2::theme_bw()

# combine!
library(patchwork)
p1 | p2
```


::::
:::::

Comparing the two panels of the plot you can see that in contrast to the
50% HPDI the 50% of PI does not include the highest probability value.

:::::{.my-watch-out}
:::{.my-watch-out-header}
{**magrittr**} and native R pipe
:::
::::{.my-watch-out-container}
Kurz uses the {**magrittr**} paipe whereas I am using the native R pipe. These two pipes are not in every aspect equivalent. One difference is the dot (`.`) syntax, "since the dot syntax is a feature of {**magrittr**} and not of base R." ([Understanding the native R pipe](https://ivelasq.rbind.io/blog/understanding-the-r-pipe/#how-the-native-r-pipe-works)).

The native pipe is available starting with R 4.1.0. It is constructed
with `|` followed by `>` resulting in the symbol `|>` to differentiate
it from the {**magrittr**} pipe (`%>%`). To understand the details of the
differences of `|>` and the native R pipe `|>` read this elaborated
[blog article by Isabella
Velásquez](https://ivelasq.rbind.io/blog/understanding-the-r-pipe/index.html),
an employee of [Posit](https://posit.co/) (formerly RStudio).

So the following trick does not work with the native R pipe: 

> In the geom_area() line for the HPDI plot, did you notice how we
> replaced `data = samples_skewed_b` with `data = .`? When using the
> pipe (i.e., `%>%`), you can use the `.` as a placeholder for the
> original data object. It's an odd and handy trick to know about.

Therefore I had to replace the dot with the name of the data frame.

Learn more of the [pipe function `%>%` of the {**magrittr**}
package](https://magrittr.tidyverse.org/reference/pipe.html) and about
the [base R native forward pipe
operator](https://stat.ethz.ch/R-manual/R-devel/library/base/html/pipeOp.html).

::::
:::::



PI and HPDI are only different if you have a very skewed
distribution. This means that in unimodal somewhat normal distribution `hdi` and `hdci` are exactly the same and pretty similar to `qi` calculation. In skewed distribution they differ.
assertion:


:::::{.my-r-code}
:::{.my-r-code-header}
:::::: {#cnj-tidyverse-HPDI-b}
b: High Density Intervals with {**tidybayes**}
::::::
:::
::::{.my-r-code-container}

::: {.panel-tabset}

###### 6 W, n=9


```{r}
#| label: tidyverse-PI-HPDI-b1
#| results: hold

## R code 3.13b(2a) HPDI 6 Water, 9 tosses #####################
tidybayes::mode_hdi(df_samples_b$samples_b, .width = .5)
tidybayes::mode_hdci(df_samples_b$samples_b, .width = .5)
tidybayes::mode_qi(df_samples_b$samples_b, .width = .5)
```


###### 3 W, n=3

```{r}
#| label: tidyverse-PI-HPDI-b2
#| results: hold

## R code 3.13b(2b) HPDI 3 Water, 3 tosses #####################
# tidybayes::mode_hdi(samples_skewed_b$p_skewed_b, .width = .5) # generates error
tidybayes::mode_hdci(samples_skewed_b$p_skewed_b, .width = .5)
tidybayes::mode_qi(samples_skewed_b$p_skewed_b, .width = .5)
```

:::


::::
:::::


Because of the disadvantages of `r glossary("HPDI")` (more computationally intensive,
greater simulation variance and harder to understand)  Kurz will primarily
stick to the PI-based intervals. And he will not use the 5.5% and 94.5% `r glossary("quantile", "quantiles")` that are `r glossary("percentile", "percentile intervals")` boundaries, corresponding to an 89% `r glossary("compatibility interval")` but stick to the 95% standard (frequentist) `r glossary("confidence interval")`. 

### Point Estimates {#sec-chap-03-point-estimates}

#### ORIGINAL


##### Measures of Central Tendency

> “Given the entire posterior distribution, what value should you report? This seems like an innocent question, but it is difficult to answer. The Bayesian parameter estimate is precisely the entire posterior distribution, which is not a single number, but instead a function that maps each unique parameter value onto a plausibility value. So really the most important thing to note is that you don’t have to choose a point estimate. It’s hardly ever necessary and often harmful. It discards information.” ([McElreath, 2020, p. 58](zotero://select/groups/5243560/items/NFUEVASQ)) ([pdf](zotero://open-pdf/groups/5243560/items/CPFRPHX8?page=77&annotation=EVCFUS3F))


But whenever you have to do it, you must choose between mean, median and MAP (= the parameter value with highest posterior probability, a *maximum a posteriori*, essentially the "peak" or mode of the posterior distribution. 

In the very skewed globe tossing example where we observed 3 waters out of 3 tosses they are all different.

:::::{.my-r-code}
:::{.my-r-code-header}
:::::: {#cnj-point-estimates-a}
a: Compute MAP, median and mean
::::::
:::
::::{.my-r-code-container}
```{r}
#| label: point-estimates-a


## R code 3.14a MAP (from grid) ###############
map_skewed_a_1 <- p_grid_skewed_a[which.max(posterior_skewed_a)]

## R code 3.15a MAP from posterior samples ################
map_skewed_a_2 <- rethinking::chainmode(samples_skewed_a, adj = 0.01)

## R code 3.16a mean and median #############
mean_skewed_a <- mean(samples_skewed_a)
median_skewed_a <- median(samples_skewed_a)
```

**Results:**

- MAP with `which.max()` = `r map_skewed_a_1`
- MAP with `rethinking::chainmode()` = `r map_skewed_a_2`
- Mean: `r mean_skewed_a`
- Median: `r median_skewed_a`

::::
:::::

:::::{.my-watch-out}
:::{.my-watch-out-header}
Difference between MAP and mode calculation?
:::
::::{.my-watch-out-container}
I have observed small differences between the MAP calculation in @cnj-point-estimates-a and the mode calculation of other packages. I wonder why all these other methods give  0.95/0.96 whereas the MAP calculation results in 0.99/1.0.

One explanation I could think is that the mode is defined by the *maximum frequency* of observations, whereas the MAP is calculated from the *maximum of the weighted probability frequency *.

But I am not sure. One thing I can say with some certainty is that MAP seems [a complicated theoretical construct](https://web.stanford.edu/class/archive/cs/cs109/cs109.1216/lectures/22_map.pdf) and a [difficult computational procedure](https://machinelearningmastery.com/maximum-a-posteriori-estimation/).

:::::{.my-r-code}
:::{.my-r-code-header}
:::::: {#cnj-map-mode}
a: Compare MAP and mode calculation of different packages
::::::
:::
::::{.my-r-code-container}
```{r}
#| label: different-modes
#| warning: false

m_skewed_1 <- modeest::mlv(samples_skewed_a, method = "mfv")
m_skewed_2 <- DescTools::Mode(samples_skewed_a)
m_skewed_3 <- bayestestR::map_estimate(samples_skewed_a)
```

Results of mode calculation with several packages:

- `modeest::mlv()`: `r m_skewed_1`
- `DescTools::Mode()`: `r m_skewed_2`
- `bayestestR::map_estimate()`: `r m_skewed_3`
::::
:::::


::::
:::::

The graphical representation as shown in Figure 3.4 will be calculated
in the tidyverse version of this section. See: @fig-left-panel-3-4-skewed-b for
the left panel and @fig-minimum-loss2-b for the right panel of Figure
3.4.

##### Loss function to support particular decisions

“One principled way to go beyond using the entire posterior as the estimate is to choose a `r glossary("loss function")`.” ([McElreath, 2020, p. 59](zotero://select/groups/5243560/items/NFUEVASQ)) ([pdf](zotero://open-pdf/groups/5243560/items/CPFRPHX8?page=78&annotation=42KE9FFZ))

:::::{.my-important}
:::{.my-important-header}
Different loss functions imply different point estimates. ([McElreath, 2020, p. 59](zotero://select/groups/5243560/items/NFUEVASQ)) ([pdf](zotero://open-pdf/groups/5243560/items/CPFRPHX8?page=78&annotation=3X2FI82B))
:::

:::::

> “Here’s an example to help us work through the procedure. Suppose I offer you a bet. Tell me which value of p, the proportion of water on the Earth, you think is correct. I will pay you $\$100$, if you get it exactly right. But I will subtract money from your gain, proportional to the distance of your decision from the correct value. Precisely, your loss is proportional to the absolute value of $d − p$, where $d$ is your decision and $p$ is the correct answer. We could change the precise dollar values involved, without changing the important aspects of this // problem. What matters is that the loss is proportional to the distance of your decision from the true value. Now once you have the posterior distribution in hand, how should you use it to maximize your expected winnings? It turns out that the parameter value that maximizes expected winnings (minimizes expected loss) is the median of the posterior distribution.” ([McElreath, 2020, p. 59/60](zotero://select/groups/5243560/items/NFUEVASQ)) ([pdf](zotero://open-pdf/groups/5243560/items/CPFRPHX8?page=79&annotation=59IS3PFL))


> “Calculating expected loss for any given decision means using the posterior to average over our uncertainty in the true value. Of course we don’t know the true value, in most cases. But if we are going to use our model’s information about the parameter, that means using the entire posterior distribution. So suppose we decide $p = 0.5$ will be our decision.” ([McElreath, 2020, p. 60](zotero://select/groups/5243560/items/NFUEVASQ)) ([pdf](zotero://open-pdf/groups/5243560/items/CPFRPHX8?page=79&annotation=UTEYE7VX)).


:::::{.my-r-code}
:::{.my-r-code-header}
:::::: {#cnj-expected-loss-a}
a: Calculated expected loss for $p = 0.5$
::::::
:::
::::{.my-r-code-container}

```{r}
#| label: expected-loss-a

## R code 3.17a weighted average loss ##################
loss_avg_a <- sum(posterior_skewed_a * abs(0.5 - p_grid_skewed_a))

## R code 3.18a for every possible value #############################
loss_a <- sapply(p_grid_skewed_a, 
     function(d) sum(posterior_skewed_a * abs(d - p_grid_skewed_a)))

## R code 3.19a minimized loss value #############################
loss_min_a <- p_grid_skewed_a[which.min(loss_a)]
```

**Results:**

- Weighted average loss value = `r loss_avg_a`.
- parameter value that minimizes the loss = `r loss_min_a`. This is the posterior median that we already have calculated in @cnj-point-estimates-a. Because of sampling variation it is not identical but pretty close (`r median_skewed_a` versus `r loss_min_a`).

::::
:::::

:::::{.my-important}
:::{.my-important-header}
Learnings: Point estimates
:::
::::{.my-important-container}

> “In order to decide upon a *point estimate*, a single-value summary of the posterior distribution, we need to pick a loss function. Different loss functions nominate different point estimates. The two most common examples are the absolute loss as above, which leads to the median as the point estimate, and the quadratic loss $(d − p)^{2}$, which leads to the posterior mean (`mean(samples_a)`) as the point estimate. When the posterior distribution is symmetrical and normal-looking, then the median and mean converge to the same point, which relaxes some anxiety we might have about choosing a loss function. For the original globe tossing data (6 waters in 9 tosses), for example, the mean and median are barely different.” ([McElreath, 2020, p. 60](zotero://select/groups/5243560/items/NFUEVASQ)) ([pdf](zotero://open-pdf/groups/5243560/items/CPFRPHX8?page=79&annotation=JHGI3FVY))

> “Usually, research scientists don’t think about loss functions. And so any point estimate like the mean or MAP that they may report isn’t intended to support any particular decision, but rather to describe the shape of the posterior. You might argue that the decision to make is whether or not to accept an hypothesis. But the challenge then is to say what the relevant costs and benefits would be, in terms of the knowledge gained or lost. Usually it’s better to communicate as much as you can about the posterior distribution, as well as the data and the model itself, so that others can build upon your work. Premature decisions to accept or reject hypotheses can cost lives.” ([McElreath, 2020, p. 61](zotero://select/groups/5243560/items/NFUEVASQ)) ([pdf](zotero://open-pdf/groups/5243560/items/CPFRPHX8?page=80&annotation=6GVPUF4Z))
::::
:::::


#### TIDYVERSE

##### Measures of Central Tendency

If we sort the posterior values of `d_skewed_b` (three tosses with three `W`) from highest to lowest values then the first row (= the maximum value of `posterior_skewed_b`) will give us the MAP as the corresponding `p_grid_b` value. Additionally the {**tidybayes**} has other options to compute the MAP. To calculate mean and median we will use the Base R functions. In the following code chunk I have collected all these different calculations.

:::::{.my-r-code}
:::{.my-r-code-header}
:::::: {#cnj-point-estimates-b}
b: Compute MAP, median and mean
::::::
:::
::::{.my-r-code-container}

```{r}
#| label: point-estimates-b
#| results: hold

## R code 3.14b MAP (from grid) ###############################
glue::glue('MAP computed with dplyr::arrange(dplyr::desc())\n')
map_skewed_b <- d_skewed_b |> 
  dplyr::arrange(dplyr::desc(posterior_skewed_b)) 

map_skewed_b[1, c(1,6)]
glue::glue('#####################################################\n\n')

## R code 3.15b MAP (from posterior sample) ###############################
glue::glue('MAP computed with tidybayes::mode_qi()\n')
samples_skewed_b |> tidybayes::mode_qi(p_skewed_b)
glue::glue('#####################################################\n\n')

glue::glue('MAP computed with tidybayes::mode_hdci()\n')
samples_skewed_b |> tidybayes::mode_hdci(p_skewed_b)
glue::glue('#####################################################\n\n')

glue::glue('MAP computed with tidybayes::Mode()\n')
tidybayes::Mode(samples_skewed_b$p_skewed_b)
glue::glue('#####################################################\n\n')

## R code 3.16b mean and median #############################
glue::glue('Mean & Median computed with mean() & median()\n')
samples_skewed_b |> 
  dplyr::summarize(mean   = mean(p_skewed_b),
            median = median(p_skewed_b))
```
::::
:::::

We can now plot a graph to reproduce the left panel of the books Figure 3.4 where we will see the three different measures of central tendency. I will compare the skewed (three 'W', three tosses) with the somewhat normal version (six 'W', nine tosses).

:::::{.my-r-code}
:::{.my-r-code-header}
:::::: {#cnj-fig-left-panel-3-4-b}
: Posterior density for skewed and symmetric distribution
::::::
:::
::::{.my-r-code-container}

::: {.panel-tabset}

###### 3W, n=3

```{r}
#| label: fig-left-panel-3-4-skewed-b
#| fig-cap: "Posterior distribution after observing 3 'water' in 3 tosses of the globe. Vertical lines show the locations of the mode, median, and mean. All three measures of central tendency differ because of the skewness of the distribution. Therefore each point implies a different loss function. "

## 1. bundle three types of estimates into a tibble. #######
point_estimates_b1 <-
  dplyr::bind_rows(samples_skewed_b |> tidybayes::mean_qi(p_skewed_b),
            samples_skewed_b |> tidybayes::median_qi(p_skewed_b),
            samples_skewed_b |> tidybayes::mode_qi(p_skewed_b)) |> 
  dplyr::select(p_skewed_b, .point) |> 

## 2. create two columns to annotate the plot #######
  dplyr::mutate(x = p_skewed_b + c(-.03, .03, -.03),
       y = c(.0005, .0012, .002))

## 3. plot #######
samples_skewed_b |> 
  ggplot2::ggplot(ggplot2::aes(x = p_skewed_b)) +
  ggplot2::geom_area(ggplot2::aes(y = posterior_skewed_b),
            fill = "deepskyblue") +
  ggplot2::geom_vline(xintercept = point_estimates_b1$p_skewed_b) +
  ggplot2::geom_text(data = point_estimates_b1,
            ggplot2::aes(x = x, y = y, label = .point),
            angle = 90) +
  ggplot2::labs(x = "proportion of water (p)",
       y = "density") +
  ggplot2::theme(panel.grid = ggplot2::element_blank()) +
  ggplot2::theme_bw()
```
###### 6W, n=9


```{r}
#| label: fig-left-panel-3-4-sym-b
#| fig-cap: "Point estimates in the almost symmetrical distribution of 6 'water' in 9 tosses. Vertical lines show the locations of the mode, median, and mean. All three points are in a similar locatioon and have approximately the same loss function."
#| eval: false
#| include: false

## 0. compute mode with different method
mode2_b <- df_samples_b |>
  dplyr::arrange(dplyr::desc(posterior_samples_b)) |> 
  dplyr::slice(1) |> 
  dplyr::rename(.point = prior_samples_b) |> 
  dplyr::select(samples_b, .point) |> 
  dplyr::mutate(.point = "mode2")

## 1. bundle three types of estimates into a tibble ######
point_estimates_b2 <-
  dplyr::bind_rows(df_samples_b |> tidybayes::mean_qi(samples_b),
            df_samples_b |> tidybayes::median_qi(samples_b),
            df_samples_b |> tidybayes::mode_qi(samples_b)) |> 
  dplyr::select(samples_b, .point) |> 
  dplyr::bind_rows(mode2_b) |>
  
## 2. create two columns to annotate the plot #######
  dplyr::mutate(x = c(.55, .55, .75, .75),
         y = c(.0006, .0011, .0016, .0021),
         x_start = c(.4, .4, .85, .85),
         y_line = c(.0005, .0010, .0015, .0020),
         x_end = point_estimates_b2$samples_b)

## 3. plot #########
df_samples_b |> 
  ggplot2::ggplot(ggplot2::aes(x = samples_b)) +
  ggplot2::geom_area(ggplot2::aes(y = posterior_samples_b),
           fill = "deepskyblue") +
  ggplot2::geom_vline(xintercept = point_estimates_b2$samples_b) +
  ggplot2::geom_text(data = point_estimates_b2,
            ggplot2::aes(x = x, y = y, label = .point)) +
  ggplot2::labs(x = "proportion of water (p)",
       y = "density") +
  ggplot2::theme(panel.grid = ggplot2::element_blank()) +
  ggplot2::theme_bw() + 
  ggplot2::geom_segment(
    ggplot2::aes(\(x) x = point_estimates_b2$x_start[[1]],
                 y = point_estimates_b2$y_line[[1]], 
                 xend = point_estimates_b2$samples_b[[1]], 
                 yend = point_estimates_b2$y_line[[1]]),
    arrow = grid::arrow(length = grid::unit(0.5, "cm")))
```


```{r}
#| label: fig-left-panel-3-4-sym-b2
#| fig-cap: "Point estimates in the almost symmetrical distribution of 6 'water' in 9 tosses. Vertical lines show the locations of the mode, median, and mean. All three points are in a similar locatioon and have approximately the same loss function."

## 0. compute mode with different method
mode2_b <- df_samples_b |>
  dplyr::arrange(dplyr::desc(posterior_samples_b)) |> 
  dplyr::slice(1) |> 
  dplyr::rename(.point = prior_samples_b) |> 
  dplyr::select(samples_b, .point) |> 
  dplyr::mutate(.point = "mode2")

## 1. bundle three types of estimates into a tibble ######
point_estimates_b2 <-
  dplyr::bind_rows(df_samples_b |> tidybayes::mean_qi(samples_b),
            df_samples_b |> tidybayes::median_qi(samples_b),
            df_samples_b |> tidybayes::mode_qi(samples_b)) |> 
  dplyr::select(samples_b, .point) |> 
  dplyr::bind_rows(mode2_b) |>
  
## 2. create two columns to annotate the plot #######
  dplyr::mutate(x = c(.55, .55, .75, .75),
         y = c(.0006, .0011, .0016, .0021))

## 3. plot ##########################################
df_samples_b |> 
  ggplot2::ggplot(ggplot2::aes(x = samples_b)) +
  ggplot2::geom_area(ggplot2::aes(y = posterior_samples_b),
           fill = "deepskyblue") +
  ggplot2::geom_vline(xintercept = point_estimates_b2$samples_b) +
  ggplot2::geom_text(data = point_estimates_b2,
            ggplot2::aes(x = x, y = y, label = .point)) +
  ggplot2::labs(x = "proportion of water (p)",
       y = "density") +
  ggplot2::theme(panel.grid = ggplot2::element_blank()) +
  ggplot2::theme_bw() + 

## 4. annotation (arrows & text) ####################
  ggplot2::geom_segment(
    ggplot2::aes(x = 0.4, y = .0005, xend = point_estimates_b2$samples_b[[1]], yend = .0005),
    arrow = grid::arrow(length = grid::unit(0.5, "cm"))) +
  ggplot2::geom_segment(
    ggplot2::aes(x = 0.4, y = .001, xend = point_estimates_b2$samples_b[[2]], yend = .001),
    arrow = grid::arrow(length = grid::unit(0.5, "cm"))) +  
  ggplot2::geom_segment(
    ggplot2::aes(x = 0.85, y = .0015, xend = point_estimates_b2$samples_b[[3]], yend = .0015),
    arrow = grid::arrow(length = grid::unit(0.5, "cm"))) +
  ggplot2::geom_segment(
    ggplot2::aes(x = 0.85, y = .002, xend = point_estimates_b2$samples_b[[4]], yend = .002),
    arrow = grid::arrow(length = grid::unit(0.5, "cm"))
)
```

:::::{.my-watch-out}
:::{.my-watch-out-header}
MAP (mode) is not the highest point in the more symmetric version (6 'W', n=9)
:::
::::{.my-watch-out-container}
I wounder if the calculation of the MAP of the somewhat symmetrical version is correct, because the MAP or mode is not the highest value in the distribution. In addition to calculate the mode with {**tidybayes**}, I have also used R code 3.14b from @cnj-point-estimates-b to compute MAP with `dplyr::arrange(dplyr::desc())`.

It turns out that there is difference: In contrast to  {**tidybayes**} arranging the data frame results in a MAP value (`mode2`) which is indeed the highest point of the distribution. I don't know how to interpret this disparity.
::::
:::::


:::
::::
:::::

##### Loss function to support particular decisions



:::::{.my-r-code}
:::{.my-r-code-header}
:::::: {#cnj-expected-loss-b}
b: Calculated expected loss for $p = 0.5$ with proportional and quadratic loss function
::::::
:::
::::{.my-r-code-container}

::: {.panel-tabset}


###### $d-p$

The absolute proportional loss $d-p$ for the decision $p = 0.5$ results into the median.

```{r}
#| label: expected-prop-loss-b
#| results: hold

## R code 3.17b weighted average loss ##################
loss_avg_b <- d_skewed_b |> 
    dplyr::summarise(`expected loss` = 
               base::sum(posterior_skewed_b * base::abs(0.5 - p_grid_b)))

## R code 3.18b for every possible value #############################

## write function
make_loss_b <- function(our_d) {
  d_skewed_b |> 
    dplyr::mutate(loss_b = posterior_skewed_b * base::abs(our_d - p_grid_b)) |> 
    dplyr::summarise(weighted_average_loss_b = base::sum(loss_b))
}

## calculate loss for all possible values 
glue::glue("Every possible loss values for decision 0.5 with proportional loss function\n")
(
  l_b <-
  d_skewed_b |> 
  dplyr::select(p_grid_b) |> 
  dplyr::rename(decision_b = p_grid_b) |> 
  dplyr::mutate(weighted_average_loss_b = purrr::map(decision_b, make_loss_b)) |> 
  tidyr::unnest(weighted_average_loss_b) 
)

## R code 3.19b minimized loss value #############################
# this will help us find the x and y coordinates for the minimum value
loss_min_b <-
    l_b |> 
    dplyr::filter(weighted_average_loss_b == base::min(weighted_average_loss_b)) |> 
    base::as.numeric()
```

**Results:**

- Weighted average loss value = `r loss_avg_b`.
- Parameter value that minimizes the loss = `r loss_min_b[[1]]`. This is the posterior median that we already have calculated in @cnj-point-estimates-b. Because of sampling variation it is not identical but pretty close (`r median(samples_skewed_b$p_skewed_b)` versus `r loss_min_b[[1]]`).

###### $(d−p)^{2}$

The quadratic loss $(d−p)^{2}$ for the decision $p = 0.5$ suggests we should use the mean.

```{r}
#| label: expected-quad-loss-b
#| results: hold

## R code 3.17b weighted average loss ##################
loss_avg_b2 <- d_skewed_b |> 
    dplyr::summarise(`expected loss` = 
               base::sum(posterior_skewed_b * base::sqrt(abs(0.5 - p_grid_b))))

## R code 3.18b for every possible value #############################
# amend our loss function

make_loss2_b <- function(our_d2) {
  d_skewed_b |> 
    dplyr::mutate(loss2_b = posterior_skewed_b * (our_d2 - p_grid_b)^2) |> 
    dplyr::summarise(weighted_average_loss2_b = base::sum(loss2_b))
}


# remake our `l` data
glue::glue("Every possible loss values for decision 0.5 with quadratic loss function\n")
(
  l2_b <-
    d_skewed_b |> 
    dplyr::select(p_grid_b) |> 
    dplyr::rename(decision2_b = p_grid_b) |> 
    dplyr::mutate(weighted_average_loss2_b = purrr::map(decision2_b, make_loss2_b)) |> 
    tidyr::unnest(weighted_average_loss2_b)
)

## R code 3.19b minimized loss value #############################
# update to the new minimum loss coordinates


loss_min_b2 <-
    l2_b |> 
    dplyr::filter(weighted_average_loss2_b == base::min(weighted_average_loss2_b)) |> 
    base::as.numeric()
```

**Results:**

- Weighted average loss value = `r loss_avg_b2`.
- Parameter value that minimizes the loss = `r loss_min_b2[[1]]`. This is the posterior mean that we already have calculated in @cnj-point-estimates-b. Because of sampling variation it is not identical but pretty close (`r mean(samples_skewed_b$p_skewed_b)` versus `r loss_min_b2[[1]]`).


:::
::::
:::::



Now we're ready to reproduce the right panel of Figure 3.4., e.g., displaying the the loss function and computing the minimum loss value. Remember: Different loss functions imply different point estimates.



:::::{.my-r-code}
:::{.my-r-code-header}
:::::: {#cnj-fig-prop-loss-b}
b: Plot expected loss for $p = 0.5$ with proportional and quadratic loss function
::::::
:::
::::{.my-r-code-container}

::: {.panel-tabset}

###### $d-p$

The absolute proportional loss $d-p$ for the decision $p = 0.5$ results into the median.

```{r}
#| label: fig-prop-loss-b
#| fig-cap: "Expected loss under the rule that loss is proportional to absolute distance of decision (horizontal axis) from the true value. The point marks the value of `p` that minimizes the expected loss, the posterior median."

## right panel figure 3.4 ########################

l_b |>   
  ggplot2::ggplot(ggplot2::aes(x = decision_b, y = weighted_average_loss_b)) +
  ggplot2::geom_area(fill = "deepskyblue") +
  ggplot2::geom_vline(xintercept = loss_min_b[1], color = "black", linetype = 3) +
  ggplot2::geom_hline(yintercept = loss_min_b[2], color = "black", linetype = 3) +
  ggplot2::ylab("expected proportional loss") +
  ggplot2::theme(panel.grid = ggplot2::element_blank()) +
  ggplot2::theme_bw()
```

We saved the exact minimum value as `loss_min_b[1]`, which is
`r loss_min_b[1]`. Within sampling error, this is the posterior median
as depicted by our samples (`r median(samples_skewed_b$p_skewed_b)` versus `r loss_min_b[[1]]`).



###### $(d−p)^{2}$

The quadratic loss $(d−p)^{2}$ for the decision $p = 0.5$ suggests we should use the mean.


```{r}
#| label: fig-quad-loss-b
#| fig-cap: "Expected loss under the rule that loss is quadratic to the distance of decision (horizontal axis) from the true value. The point marks the value of `p` that minimizes the expected loss, the posterior mean"
#| results: hold


# update the plot
l2_b |>   
  ggplot2::ggplot(ggplot2::aes(x = decision2_b, y = weighted_average_loss2_b)) +
  ggplot2::geom_area(fill = "deepskyblue") +
  ggplot2::geom_vline(xintercept = loss_min_b2[1], color = "black", linetype = 3) +
  ggplot2::geom_hline(yintercept = loss_min_b2[2], color = "black", linetype = 3) +
  ggplot2::ylab("expected proportional loss") +
  ggplot2::theme(panel.grid = ggplot2::element_blank()) +
  ggplot2::theme_bw()
```

Based on quadratic loss $(d−p)^{2}$, the exact minimum value is
`r loss_min_b2[1]`. Within sampling error, this is the posterior mean of
our samples (`r mean(samples_skewed_b$p_skewed_b)` versus `r loss_min_b2[[1]]`).

:::

::::
:::::

## I STOPPED HERE (2nd PASS, 2023-11-12)

## Sampling to simulate prediction

### Original

To generate implied observations from a model is useful for at least
five reasons:

1.  **Model design**: We can sample not only from the posterior, but
    also from the prior. Seeing what the model expects, before the data
    arrive, is the best way to understand the implications of the prior.
    We'll do a lot of this in later chapters, where there will be
    multiple parameters and so their joint implications are not always
    very clear.
2.  **Model checking**: After a model is updated using data, it is worth
    simulating implied observations, to check both whether the fit
    worked correctly and to investigate model behavior.
3.  **Software validation**: In order to be sure that our model fitting
    software is working, it helps to simulate observations under a known
    model and then attempt to recover the values of the parameters the
    data were simulated under.
4.  **Research design**: If you can simulate observations from your
    hypothesis, then you can evaluate whether the research design can be
    effective. In a narrow sense, this means doing power analysis, but
    the possibilities are much broader.
5.  **Forecasting**: Estimates can be used to simulate new predictions,
    for new cases and future observations. These forecasts can be useful
    as applied prediction, but also for model criticism and revision.

#### Dummy data

> Now note that these assumptions not only allow us to infer the
> plausibility of each possible value of *p*, after observation. That's
> what you did in the previous chapter. These assumptions also allow us
> to simulate the observations that the model implies. They allow this,
> because likelihood functions work in both directions. Given a realized
> observation, the likelihood function says how plausible the
> observation is. And given only the parameters, the likelihood defines
> a distribution of possible observations that we can sample from, to
> simulate observation. In this way, Bayesian models are always
> *generative*, capable of simulating predictions. Many non-Bayesian
> models are also generative, but many are not.
>
> We will call such simulated data **DUMMY DATA**, to indicate that it
> is a stand-in for actual data.

##### Probability of each globe toss

> Suppose $N = 2$, two tosses of the globe. Then there are only three
> possible observations: 0 water, 1 water, 2 water. You can quickly
> compute the probability of each, for any given value of *p*. Let's use
> $p = 0.7$, which is just about the true proportion of water on the
> Earth:

```{r}
#| label: dummy-data-a

## R code 3.20 #############################
dbinom(0:2, size = 2, prob = 0.7)
```

##### Simulation of globe tosses

> Now we're going to simulate observations, using these probabilities.
> This is done by sampling from the distribution just described above.
> You could use `sample()` to do this, but R provides convenient
> sampling functions for all the ordinary probability distributions,
> like the binomial.

```{r}
#| label: simulate-1-obs-a

set.seed(3) # for reproducibility

## R code 3.21 #############################
rbinom(1, size = 2, prob = 0.7)
```

(As the outcome results from a random process the above value differs
from the SR2 version. But with `set.seed(3)`\` you will get the same
value of $2$.)

> That $1$ means "2 water in 2 tosses." The "`r`" in `rbinom` stands for
> "random." It can also generate more than one simulation at a time. A
> set of 10 simulations can be made by:

```{r}
#| label: simulate-10-obs-a

set.seed(3)
## R code 3.22 #############################
rbinom(10, size = 2, prob = 0.7)
```

> Let's generate 100,000 dummy observations, just to verify that each
> value (0, 1, or 2) appears in proportion to its likelihood:

```{r}
#| label: simulate-1e5-obs-a

set.seed(3)
## R code 3.23 #############################
dummy_w_a <- rbinom(1e5, size = 2, prob = 0.7)
table(dummy_w_a) / 1e5
```

##### Plot simulation of globe tosses

We could use either the base R `graphics::hist()` or --- as in the SR2
book --- the `rethinking::simplehist()` function.

```{r}
#| label: fig-plot-hist-figure-3.5-a
#| fig-cap: "Distribution of simulated sample observations from 9 tosses of the globe. These samples assume the proportion of water is 0.7. The plot uses the base R `hist()` function"

set.seed(3)
dummy_w_a <- rbinom(1e5, size = 9, prob = 0.7)
hist(dummy_w_a, xlab = "dummy water count")
```

```{r}
#| label: fig-plot-simplehist-figure-3.5-a
#| fig-cap: "Distribution of simulated sample observations from 9 tosses of the globe. These samples assume the proportion of water is 0.7. the plot uses the rethinking::simplehist() function"

set.seed(3)
## R code 3.24 #############################
dummy_w_a <- rbinom(1e5, size = 9, prob = 0.7)
rethinking::simplehist(dummy_w_a, xlab = "dummy water count")
```

> Notice that most of the time the expected observation does not contain
> water in its true proportion, 0.7. That's the nature of observation:
> There is a one-to-many relationship between data and data-generating
> processes. You should experiment with sample size, the `size` input in
> the code above, as well as the prob, to see how the distribution of
> simulated samples changes shape and location.

> Many readers will already have seen simulated observations. **SAMPLING
> DISTRIBUTIONS** are the foundation of common non-Bayesian statistical
> traditions. In those approaches, inference about parameters is made
> through the sampling distribution. In this book, inference about
> parameters is never done directly through a sampling distribution. The
> posterior distribution is not sampled, but deduced logically. Then
> samples can be drawn from the posterior, as earlier in this chapter,
> to aid in inference. In neither case is "sampling" a physical act. In
> both cases, it's just a mathematical device and produces only *small
> world* (@sec-chap02) numbers.

#### Model checking

> MODEL CHECKING means (1) ensuring the model fitting worked correctly
> and (2) evaluating the adequacy of a model for some purpose. Since
> Bayesian models are always *generative*, able to simulate observations
> as well as estimate parameters from observations, once you condition a
> model on data, you can simulate to examine the model's empirical
> expectations.

> We'd like to *propagate* the parameter uncertainty---carry it
> forward---as we evaluate the implied predictions. All that is required
> is averaging over the posterior density for `p`, while computing the
> predictions. For each possible value of the parameter `p`, there is an
> implied distribution of outcomes. So if you were to compute the
> sampling distribution of outcomes at each value of `p`, then you could
> average all of these prediction distributions together, using the
> posterior probabilities of each value of `p`, to get a POSTERIOR
> PREDICTIVE DISTRIBUTION.

The reproduction of FIGURE 3.6 that illustrates this averaging is shown
in ref###.

> we need to learn how to combine sampling of simulated observations, as
> in the previous section, with sampling parameters from the posterior
> distribution. We expect to do better when we use the entire posterior
> distribution, not just some point estimate derived from it.

So how do you actually do the calculations?

```{r}
#| label: sim-pred-values-a

set.seed(3)
## R code 3.25 #############################
w_a <- rbinom(1e4, size = 9, prob = 0.6)
rethinking::simplehist(w_a)
```

> This generates 10,000 (1e4) simulated predictions of 9 globe tosses
> (size=9), assuming $p = 6$. The predictions are stored as counts of
> water, so the theoretical minimum is zero and the theoretical maximum
> is nine.

We used `rethinking::`simplehist(w_a)\` to get a clean histogram of the
simulated outcomes.

> All you need to propagate parameter uncertainty into these predictions
> is replace the value 0.6 with samples from the posterior:

```{r}
#| label: fig-sim-pred-samples-a
#| fig-cap: "Random binomial samples to simulate predicted observations for $p = 0.6$"
#| attr-source: '#lst-sim-pred-samples-a lst-cap="Generate 1e4 random binomial samples to simulate predicted observations for $p = 0.6$"'

set.seed(3)
## R code 3.26 #############################
w2_a <- rbinom(1e4, size = 9, prob = samples_a)
rethinking::simplehist(w2_a)
```

The symbol `samples_a` above is the same list of random samples from the
posterior distribution that we have calculated in @cnj-sample-globe-tossing
and used in previous sections.

> For each sampled value, a random binomial observation is generated.
> Since the sampled values appear in proportion to their posterior
> probabilities, the resulting simulated observations are averaged over
> the posterior. You can manipulate these simulated observations just
> like you manipulate samples from the posterior---you can compute
> intervals and point statistics using the same procedures.

> The simulated model predictions are quite consistent with the observed
> data in this case---the actual count of 6 lies right in the middle of
> the simulated distribution. ... So far, we've only viewed the data
> just as the model views it: Each toss of the globe is completely
> independent of the others. This assumption is questionable.

> So with the goal of seeking out aspects of prediction in which the
> model fails, let's look at the data in two different ways. Recall that
> the sequence of nine tosses was `W L W W W L W L W`. First, consider
> the length of the longest run of either water or land. This will
> provide a crude measure of correlation between tosses. So in the
> observed data, the longest run is 3 W's. Second, consider the number
> of times in the data that the sample switches from water to land or
> from land to water. This is another measure of correlation between
> samples. In the observed data, the number of switches is 6. There is
> nothing special about these two new ways of describing the data. They
> just serve to inspect the data in new ways. In your own modeling,
> you'll have to imagine aspects of the data that are relevant in your
> context, for your purposes.

FIGURE 3.7 showing the simulated predictions, viewed in these two new
ways, is reproduced in ref###. I have also postponed the interpretation
of Figure 3.7 to ref###, because it is more understandable viewing the
plots.

### Tidyverse

#### Dummy data

> Dummy data for the globe tossing model arise from the binomial
> likelihood.

##### Probability of each globe toss

Suppose $N = 2$, two tosses of the globe.

```{r}
#| label: dummy-data-b

tibble(n      = 2,
       `p(w)` = .7,
       w      = 0:n) |> 
  mutate(density = dbinom(w, size = n, prob = `p(w)`))
```

##### Simulation of globe tosses

Simulate one globe toss:

```{r}
#| label: simulate-1-obs-b

set.seed(3)
rbinom(1, size = 2, prob = .7)
```

Simulate 10 globe tosses.

```{r}
#| label: simulate-10-obs-b

set.seed(3)
rbinom(10, size = 2, prob = .7)
```

Now generate 100,000 (i.e., 1e5) reproducible dummy observations.

```{r}
#| label: simulate-1e5-obs-b

n_draws_b <- 1e5

set.seed(3)
dummy_w_b <- tibble(draws = rbinom(n_draws_b, size = 2, prob = .7)) 
    
    dummy_w_b |> 
        count(draws) |> 
        mutate(proportion = n / nrow(dummy_w_b))
```

##### Plot simulation of globe tosses

The simulation updated to $n=9$ and plotting the tidyverse version of
Figure 3.5.

```{r}
#| label: fig-plot-ggplot2-figure-3.5-b
#| fig-cap: "Distribution of simulated sample observations from 9 tosses of the globe. These samples assume the proportion of water is 0.7. The plot uses the {**ggplot2**} functions. The left panel is Kurz's original, the right one is my version slightly changed."

n_draws_b <- 1e5

set.seed(3)
dummy_w2_b <- tibble(draws = rbinom(n_draws_b, size = 9, prob = .7))

p1 <- dummy_w2_b |> 
    ggplot(aes(x = draws)) + 
    geom_histogram(binwidth = 1, center = 0,
                 fill = "deepskyblue", color = "black", 
                 linewidth = 1/10) +
    # breaks = 0:10 * 2 = equivalent in Kurz's versions:  breaks = 0:4 * 2
    scale_x_continuous("dummy water count", breaks = 0:10 * 2) +
    ylab("frequency") +
    coord_cartesian(xlim = c(0, 9)) +
    theme(panel.grid = ggplot2::element_blank())

p2 <- dummy_w2_b |> 
    ggplot(aes(x = draws)) + 
    geom_histogram(binwidth = 1, center = 0,
                 fill = "deepskyblue", color = "black", 
                 linewidth = 1/10) +
    ## breaks = 0:10 * 2 = equivalent in Kurz's versions:  breaks = 0:4 * 2
    ## I decided to set a break at each of the draws: breaks = 0:9 * 1
    scale_x_continuous("dummy water count", breaks = 0:9 * 1) +
    ylab("frequency") +
    ## I did not zoom into the graph because doesn't look so nice
    ## for instance the last line is not visible
    # coord_cartesian(xlim = c(0, 9)) +
    theme(panel.grid = ggplot2::element_blank())

library(patchwork)
p1 + p2
```

##### Simulating and plotting 9 conditions

McElreath suggested we play around with different values of `size` and
`prob`. The next block of code simulates nine conditions.

```{r}
#| label: fig-simulate-9-conditions
#| fig-cap: "Distribution of 9 simulated sample observations, using different size (number of tosses: 3, 6, 9) and different probabilities (prob: 0.3, 0.6, 0.9)."

n_draws <- 1e5

simulate_binom <- function(n, probability) {
  set.seed(3)
  rbinom(n_draws, size = n, prob = probability) 
}

d9_b <-
  crossing(n9_b           = c(3, 6, 9),
           probability9_b = c(.3, .6, .9)) |> 
  mutate(draws9_b = map2(n9_b, probability9_b, simulate_binom)) |> 
  ungroup() |> 
  mutate(n           = str_c("n = ", n9_b),
         probability = str_c("p = ", probability9_b)) |> 
  unnest(draws9_b)

d9_b |> 
    slice_sample(n = 10) |> 
    arrange(n9_b)

```

I am still not very experienced with `tidyr::crossing()` and
`tidyr::unnest()`:

-   **`crossing()`** is a wrapper around `expand_grid()` and therefore
    creates a tibble from all combination of inputs. In addition to
    `expand_grid()` it de-duplicates and sorts its input.
-   **`unnest()`** expands a list-column containing data frames into row
    and columns. In the above case `map2()` returns a list and stores
    the data in `draws9_b`.

Instead of `head()` I used `dplyr::slice_sample()` and ordered the
result by the first column. I think this will get a better glimpse on
the data as just the first 6 rows.

```{r}
#| label: fig-sim-plot-9-cond-b

d9_b |> 
  ggplot(aes(x = draws9_b)) +
  geom_histogram(binwidth = 1, center = 0,
                 color = "deepskyblue", linewidth = 1/10) +
  scale_x_continuous("dummy water count", breaks = 0:4 * 2) +
  ylab("frequency") +
  coord_cartesian(xlim = c(0, 9)) +
  theme(panel.grid = ggplot2::element_blank()) +
  facet_grid(n9_b ~ probability9_b)
```

#### Model checking

On software checking Kurz refers to some material, that is too special
for me. So I do not include it here. Maybe I will come later here again
when I have more experiences with Bayesian statistics and the necessary
tools.

##### Reproduction of Figure 3.6

At first I thought I do not need to refresh the original grid
approximation from @lst-grid-approx-b as I have it stored it with the
unique name `d_b`. But it turned out that the above code with
`n_grid_b = 1000L` does not work, because it draws no vertical lines by
the posterior density. Instead one has to sample 1001 times.

Actually I do not know why this (small) difference is necessary, but I
noticed that with most sample numbers the plot does not work correctly.
It worked with 1071. The sequence 1011, 1021, 1031, 1041, 1051, 1061
misses just one vertical line at .7 Ab exception is 1041, which misses
.6.

So I have to crate the data with 1001 samples again before I produce the
plot.

```{r}
#| label: fig-repr-figure-3.6-top-b
#| fig-cap: "Reproduction of the top part of figure 3.6"

n2_b <- 1001L
n_success <- 6L
n_trials  <- 9L

(
  d2_b <-
  tibble(p_grid2_b = seq(from = 0, to = 1, length.out = n2_b),
         # note we're still using a flat uniform prior
         prior2_b  = 1) |> 
  mutate(likelihood2_b = dbinom(n_success, size = n_trials, prob = p_grid2_b)) |> 
  mutate(posterior2_b = (likelihood2_b * prior2_b) / sum(likelihood2_b * prior2_b))
)

d2_b |> 
  ggplot(aes(x = p_grid2_b, y = posterior2_b)) +
  geom_area(color = "deepskyblue", fill = "deepskyblue") +
  geom_segment(data = d2_b |>   # must use data explictly instead of %>% and dot (.) 
                 filter(p_grid2_b %in% c(seq(from = .1, to = .9, by = .1), 3 / 10)),
               aes(xend = p_grid2_b, yend = 0, linewidth = posterior2_b),
               color = "black", show.legend = F) +
  geom_point(data = d2_b |>     # must use data explictly instead of %>%  and dot (.)
               filter(p_grid2_b %in% c(seq(from = .1, to = .9, by = .1), 3 / 10))) +
  annotate(geom = "text", 
           x = .08, y = .0025,
           label = "Posterior probability") +
  scale_linewidth_continuous(range = c(0, 1)) +
  scale_x_continuous("probability of water", breaks = 0:10 / 10) +
  scale_y_continuous(NULL, breaks = NULL) +
  theme(panel.grid = ggplot2::element_blank())
```

We'll need to do a bit of wrangling before we're ready to make the plot
in the middle panel of Figure 3.6.

GAP HERE! (2023-07-31) THERE IS A GAP BECAUSE THE FOLLOWING CODE CHUNKS
OF CHAP 3.3 (MOSTLY DRAWINGS) ARE FOR MY PURPOSE (LEARNING BAYESIAN
STATISTICS) NOT RELEVANT.

## Synopsis

The third chapter teaches the basic skills for working with samples from
the posterior distribution. The posterior distribution is a probability
distribution. And like all probability distributions, we can imagine
drawing samples from it.

### Sampling from a grid-approximate posterior

Before beginning to work with samples, we need to generate them with
@lst-grid-approx-base-demo respectively with
@lst-grid-approx-tidyverse-demo. Then we can draw - for instance -
10,000 samples from the posterior. To make the random draws reproducible
we will use `base::set.seed()` with a see of 3.

#### Base R

```{r}
#| label: draw-samples-base-demo
#| attr-source: '#lst-draw-samples-base-demo lst-cap="Drawing 10,000 sample from the posterior using `base::sample()`"'

## R code 3.2 ###########################
## compute the posterior for the globe tossing model, using grid approximation
p_grid_r <- seq(from = 0, to = 1, length.out = 1000)
prob_p <- rep(1, 1000)
prob_data <- dbinom(6, size = 9, prob = p_grid_r)
posterior <- prob_data * prob_p
posterior_r <- posterior / sum(posterior)

set.seed(3)

## R code 3.3 ###########################
## draw 10,000 samples from the posterior.
samples_r <- sample(p_grid_r, prob = posterior_r, size = 1e4, replace = TRUE)
```

#### Tidyverse

```{r}
#| label: draw-samples-tidyverse-demo
#| attr-source: '#lst-draw-samples-tidyverse-demo lst-cap="Drawing 10,000 sample from the posterior using `dplyr::slice_sample()`"'

# how many grid points would you like?
n <- 1000
n_success <- 6
n_trials  <- 9

  d_t <-
  tibble(p_grid_t = seq(from = 0, to = 1, length.out = n),
         # note we're still using a flat uniform prior
         prior_t  = 1) |> 
  mutate(likelihood_t = dbinom(n_success, size = n_trials, prob = p_grid_t)) |> 
  mutate(posterior_t = (likelihood_t * prior_t) / sum(likelihood_t * prior_t))

set.seed(3)
samples_t <-
  d_t |> 
    slice_sample(n = 1e4, weight_by = posterior_t, replace = T)
```

### Sampling to summarize

The next step after sampling is to summarize and interpret the posterior
distribution. The type of summary depends upon your purpose. But common
questions include:

-   How much posterior probability lies below some parameter value?
-   How much posterior probability lies between two parameter values?
-   Which parameter value marks the lower 5% of the posterior
    probability?
-   Which range of parameter values contains 90% of the posterior
    probability?
-   Which parameter value has highest posterior probability?

These questions can be divided into :

1.  Questions about intervals of *defined boundaries*
    (\@sec-intervals-of-defined-boundaries)
2.  Qustions about Intervals of *defined probability mass*
    (\@sec-intervals-of-defined-probability-mass) and
3.  Questions about *point estimates* (\@sec-point-estimates)

#### Intervals of defined boundaries {#sec-intervals-of-defined-boundaries}

For instance I will ask for the posterior probability that the
proportion of water is less than 0.5. We could use the grid-approximate
posterior to just add up all all of the probabilities, where the
corresponding parameter value is less than 0.5

But since grid approximation isn't practical in general, it won't always
be so easy. Once there is more than one parameter in the posterior
distribution, even this simple sum is no longer very simple. So wee need
to perform the same calculation, using samples from the posterior.

##### Base R: Define boundary

Using the grid-approximate posterior:

```{r}
#| label: define-boundary-from-grid-base-demo
#| attr-source: '#lst-define-boundary-from-grid-base-demo lst-cap="Define boundary by using the grid-approximate posterior with base R functions"'

## R code 3.6 #############################
# add up posterior probability where p < 0.5
sum(posterior_r[p_grid_r < 0.5])
```

Using the samples from the posterior:

```{r}
#| label: define-boundary-from-samples-base-demo
#| attr-source: '#lst-define-boundary-from-samples-base-demo lst-cap="Define boundary by summing up the samples from the posterior with base R functions"'

## R code 3.7 #############################
## sum samples of posterior probability where p < 0.5
sum(samples_r < 0.5) / 1e4


## R code 3.8 #############################
## find boundaries samples of posterior probability 
## where p lies between 0.5 and 0.75
sum(samples_r > 0.5 & samples_r < 0.75) / 1e4

```

##### Tidyverse: Define boundary

```{r}
#| label: define-boundary-from-grid-tidyverse-demo
#| attr-source: '#lst-define-boundary-from-grid-tidyverse-demo lst-cap="Define boundary by using the grid-approximate posterior with {tidyverse} functions"'

## add up posterior probability where p < 0.5
d_t |> 
  filter(p_grid_t < .5) |> 
  summarise(sum = sum(posterior_t))
```

Using the samples from the posterior:

```{r}
#| label: define-boundary-from-samples-tidyverse-demo
#| attr-source: '#lst-define-boundary-from-samples-tidyverse-demo lst-cap="Define boundary by summing up the samples from the posterior with {tidyverse} function `filter()` and `summarize()`"'

## filter and summarize samples of posterior probability where p < 0.5
samples_t |>
  filter(p_grid_t < .5) |> 
  summarise(sum = n() / 1e4)

## filter and summarize samples of posterior probability 
## where p lies between 0.5 and 0.75
samples_t |> 
  filter(p_grid_t > .5 & p_grid_t < .75) |> 
  summarise(sum = n() / 1e4)
```

A more explicit approach for the same computation is to follow up
`dplyr::count()` with `dplyr::mutate()`.

```{r}
#| label: define-boundary-from-samples-tidyverse2-demo
#| attr-source: '#lst-define-boundary-from-samples-tidyverse2-demo lst-cap="Define boundary by summing up the samples from the posterior with {tidyverse} functions `count()` and `mutate()`"'
#| eval: false

## count and sum samples of posterior probability where p < 0.5
samples_t |> 
  count(p_grid_t < .5) |> 
  mutate(probability = n / sum(n))

## count and sum samples of posterior probability 
## where p lies between .5 and .75
samples_t |> 
  count(p_grid_t > .5 & p_grid_t < .75) |> 
  mutate(probability = n / sum(n))
```

#### Intervals of defined probability mass {#sec-intervals-of-defined-probability-mass}

In scientific journals it is usual to report an interval of defined
mass, usually known as a confidence interval. What the interval
indicates is a range of parameter values compatible with the model and
data. The model and data themselves may not inspire confidence, in which
case the interval will not either. McElreath therefore call these areas
compatibility intervals.

These posterior intervals report two parameter values that contain
between them a specified amount of posterior probability, a probability
mass. For this type of interval, it is easier to find the answer by
using samples from the posterior than by using a grid approximation.

##### Base R: Define probability mass

```{r}
#| label: PI-base-demo
#| attr-source: '#lst-PI-base-demo lst-cap="Boundaries of the lower 80% and middle 80% posterior probability: Base R version"'

## R code 3.9 #######################
## find boundaries of the lower 80% posterior probability
quantile(samples_r, 0.8)

## R code 3.10 ######################
## find the interval of the middle 80% posterior probability
quantile(samples_r, c(0.1, 0.9))
```

Intervals of this sort, which assign equal probability mass to each
tail, are very common in the scientific literature. We'll call them
**percentile intervals (PI)**. These intervals do a good job of
communicating the shape of a distribution, as long as the distribution
isn't too asymmetrical.

But in highly skewed distribution they are --- in terms of supporting
inferences about which parameters are consistent with the data --- not
perfect. It could be the case that they do not include the most probable
parameter variable (the mode or MAP, Maximum A Posterior). In this case
you should use the **highest posterior density interval (HPDI)**.

```{r}
#| label: HPDI-base-demo
#| attr-source: '#lst-HPDI-base-demo lst-cap="Boundaries of the lower 80% and middle 80% posterior probability: Base R version"'

## R code 3.13 ##################################
## find the narrowest region with 50% of the posterior probability
rethinking::HPDI(samples_r, prob = 0.5)
```

##### Tidyverse: Define probability mass

As in the base R version the tidyverse variant is also using the
`quantile()`\` function. The only difference is the call of the correct
vector. Since `p_grid` samples are saved in the `samples` tibble, we'll
have to index with `$` within `quantile()`.

```{r}
#| label: PI-tidyverse-demo
#| attr-source: '#lst-PI-tidyverse-demo lst-cap="Boundaries of the lower 80% and middle 80% posterior probability: tidyverse version"'

## find boundaries of the lower 80% posterior probability
quantile(samples_t$p_grid_t, prob = .8)

## find the interval of the middle 80% posterior probability
quantile(samples_t$p_grid_t, prob = c(.1, .9))
```

For calculating the HPDI we will use the {**tidybayes**} package. which
offers an array of convenience functions for summarizing Bayesian
models.

```{r}
#| label: HPDI-tidyverse-demo
#| attr-source: '#lst-HPDI-tidyverse-demo lst-cap="Boundaries of the lower 80% and middle 80% posterior probability: Base R version"'

## find the narrowest region with 50% of the posterior probability
tidybayes::mode_hdci(samples_t$p_grid_t, .width = .5)
```

#### Point Estimates {#sec-point-estimates}

Point estimates are of limited value: The Bayesian parameter estimate is
precisely the entire posterior distribution, which is not a single
number, but instead a function that maps each unique parameter value
onto a plausibility value. So really the most important thing to note is
that you don't have to choose a point estimate. It's hardly ever
necessary and often harmful. It discards information.

##### Base R

###### Find the mode (MAP) from the grid approximation

```{r}
#| label: MAP-grid-base-demo
#| attr-source: '#lst-MAP-grid-base-demo lst-cap="Find value with the highest posterior probability, also called maximum a posteriori (MAP) estimate, from the grid approximation: Base R version"'

## R code 3.14 ######################
## find highest posterior probability (MAP) from grid approx
p_grid_r[which.max(posterior_r)]
```

###### Find the MAP (mode) from the samples from the posterior

```{r}
#| label: MAP-posterior-rethinking-demo
#| attr-source: '#lst-MAP-posterior-rethinking-demo lst-cap="Find value with the highest posterior probability, also called maximum a posteriori (MAP) estimate, from the posterior: rethinking version"'

## R code 3.15 ######################
## find highest posterior probability (MAP) from the posterior
rethinking::chainmode(samples_r, adj = 0.01)
```

###### Loss function

But why is this point, the mode, interesting? Why not report the
posterior mean or median? These are also point estimates, and they also
summarize the posterior. But all three---the mode (MAP), mean, and
median---are different in this case. How can we choose?

One principled way to go beyond the both extremes (choosing just a point
estimate or using the entire posterior as the estimate) is to choose a
**loss function**. A loss function is a rule that tells you the cost
associated with using any particular point estimate. 




*Different loss
functions imply different point estimates!*

So suppose we decide $p = 0.5$ will be our decision:

```{r}
#| label: loss-0.5-base-demo
#| attr-source: '#lst-loss-0.5-base-demo lst-cap="Find loss for the decision 0.5: base version"'

## R code 3.17
## loss with decision .05
sum(posterior_r * abs(0.5 - p_grid_r))
```

Calculating the loss function is repeating the calculation of
@lst-loss-0.5-base-demo for every possible decision. Then you can
determine the value for the decision with minimum loss.

```{r}
#| label: loss-minimum-base-demo
#| attr-source: '#lst-loss-minimum-base-demo lst-cap="Find decision for minimum loss: base version"'

## R code 3.18
loss_r <- sapply(p_grid_r, function(d) sum(posterior_r * abs(d - p_grid_r)))

## R code 3.19
p_grid_r[which.min(loss_r)]

```

And this is actually the posterior median, the parameter value that
splits the posterior density such that half of the mass is above it and
half below it.

##### Tidyverse

###### Find the mode (MAP) from the posterior samples

Three different ways to find the mode (MAP) with {**tidybayes**}:

```{r}
#| label: MAP-tidyverse-demo
#| attr-source: '#lst-MAP-tidyverse-demo lst-cap="Find value with the highest posterior probability, also called maximum a posteriori (MAP) estimate, with three different functions: tidybayes version"'
#| eval: false

samples_t |> 
    tidybayes::mode_qi(p_grid_t)

samples_t |> 
    tidybayes::mode_hdci(p_grid_t)

## just the mode
tidybayes::Mode(samples_t$p_grid_t)
```

###### Loss function

Find loss with the decision $p = 0.5$.

```{r}
#| label: loss-0.5-tidyverse-demo
#| attr-source: '#lst-loss-0.5-tidyverse-demo lst-cap="Find loss for the decision 0.5: tidyverse version"'

## find loss with the decision of .5
d_t |> 
  summarise(`expected loss` = sum(posterior_t * abs(0.5 - p_grid_t)))
```

Find minimum loss: The tidyverse version uses for the loop instead of
`base::sapply()` the `purrr::map()` function from the {**purrr}**
package, a member of the {**tidyverse}** packages.

```{r}
#| label: loss-minimum-tidyverse-demo
#| attr-source: '#lst-loss-minimum-tidyverse-demo lst-cap="Find decision for minimum loss: tidyverse version"'

make_loss_t <- function(our_d) {
  d_t |> 
    mutate(loss_t = posterior_t * abs(our_d - p_grid_t)) |> 
    summarise(weighted_average_loss_t = sum(loss_t))
}

loss_t <- 
    d_t |> 
        select(p_grid_t) |> 
        rename(decision_t = p_grid_t) |> 
            mutate(weighted_average_loss_t = purrr::map(decision_t, make_loss_t)) |>
        unnest(weighted_average_loss_t) 
  
min_loss_t <-
  loss_t |> 
    filter(weighted_average_loss_t == min(weighted_average_loss_t)) |>
    as.numeric()
```

### Sampling to simulate prediction

Another common job for samples is to ease simulation of the model's
implied observations. This is useful for 1. Model design 2. Model
checking 3. Software validation 4. Research design 5. Forecasting

#### Dummy data

Instead of using `dbinom()` to compute the probability of events, we
will use `rbinom()` to generate dummy data to simulate observations.

We will generate 100,000 dummy observations to verify that each value of
the globe tossing model (6 Waters with 9 tosses) appears in proportion
to its likelihood:

##### Base R

```{r}
#| label: fig-generate-dummy-obs-base-demo
#| fig-cap: "Dsitribution of 100,000 dummy observations of the globe tossing model resulting in 6 Water with 9 tosses: base R version" 
#| attr-source: '#lst-generate-dummy-obs-base-demo lst-cap="Generating dummy observation to simulate the probability of each value of the globe tossing model: base R version"'

set.seed(3)
## R code 3.24 ###############################
dummy_data_r <- rbinom(1e5, size = 9, prob = 0.7)
## replace `rethinking::simplehist()` with base R `graphics::hist()`
hist(dummy_data_r, xlab = "dummy water count") 

```

##### Tidyverse

```{r}
#| label: generate-dummy-obs-tidyverse-demo
#| fig-cap: "Dsitribution of 100,000 dummy observations of the globe tossing model resulting in 6 Water with 9 tosses: tidyverse version" 
#| attr-source: '#lst-generate-dummy-obs-tidyverse-demo lst-cap="Generating dummy observation to simulate the probability of each value of the globe tossing model: tidyverse version"'

set.seed(3)
d2_t <- tibble(draws_t = rbinom(1e5, size = 9, prob = .7))

# the histogram
d2_t |> 
  ggplot(aes(x = draws_t)) +
  geom_histogram(binwidth = 1, center = 0,
                 fill = "deepskyblue", color = "black", linewidth = 1/10) +
  scale_x_continuous("dummy water count", breaks = 0:4 * 2) +
  ylab("frequency") +
  theme(panel.grid = ggplot2::element_blank())
```

#### Model checking

Since Bayesian models are always generative, able to simulate
observations as well as estimate parameters from observations, once you
condition a model on data, you can simulate to examine the model's
empirical expectations.

All that is required is averaging over the posterior density for `p`,
while computing the predictions. For each possible value of the
parameter `p`, there is an implied distribution of outcomes. So if you
were to compute the sampling distribution of outcomes at each value of
`p`, then you could average all of these prediction distributions
together, using the posterior probabilities of each value of `p`, to get
a **posterior predictive distribution**.

```{r}
#| label: post-pred-dist-r
#| attr-source: '#lst-post-pred-dist-r lst-cap="Using the posterior probabilities of each value of p, to get a posterior predictive distribution: rethinking version"'

set.seed(3)
## R code 3.26 #############################
w_predicted_r <- rbinom(1e4, size = 9, prob = samples_r)
hist(w_predicted_r)
```

##### Tidyverse

```{r}
#| label: post-pred-dist-t
#| attr-source: '#lst-post-pred-dist-t lst-cap="Using the posterior probabilities of each value of p, to get a posterior predictive distribution: tidyverse version"'

set.seed(3)

samples2_t <-
  d_t |> 
  slice_sample(n = 1e4, weight_by = posterior_t, replace = T) |> 
  mutate(w_predicted_t = purrr::map_dbl(p_grid_t, rbinom, n = 1, size = 9))

## plot histogram
samples2_t |> 
  ggplot(aes(x = w_predicted_t)) +
  geom_histogram(binwidth = 1, center = 0, color = "black",
                 fill = "deepskyblue", linewidth = 1/10) +
  scale_x_continuous("number of water samples",
                     breaks = 0:3 * 3) +
  scale_y_continuous("frequency") +
  ggtitle("Posterior predictive distribution") +
  coord_cartesian(ylim = c(0, 2000)) +
  theme(panel.grid = ggplot2::element_blank())
```

## I STOPPED HERE! (2023-08-01) TO BE CONTINUED {.unnumbered}

## Practice

## Practice with brms

### Tidyverse (and {brms})

With {**brms**}, we'll fit the primary model of $w=6$ and $n=9$.

#### Fit model with the {brms} package

```{r}
#| label: brms-model-fit-b
 

b3.1 <-
  brms::brm(data = list(w = 6), 
      family = binomial(link = "identity"),
      w | trials(9) ~ 0 + Intercept,
      # this is a flat prior
      brms::prior(beta(1, 1), class = b, lb = 0, ub = 1),
      iter = 5000, warmup = 1000,
      seed = 3,
      file = "fits/b03.01")
```

We'll learn more about the beta distribution in Chapter 12. But for now,
here's the posterior summary for `b_Intercept`, the probability of a
"w".

```{r}
#| label: posterior-summary-b

brms::posterior_summary(b3.1)["b_Intercept", ] |> 
  round(digits = 2)
```

#### Simulate probability values

I had problems with the following code chunk. See [my postings at Kurz's
repo](https://github.com/ASKurz/Statistical_Rethinking_with_brms_ggplot2_and_the_tidyverse_2_ed/issues/49).

```{r}
#| label: sim-prob-values

f <-
  brms:::fitted.brmsfit(b3.1, 
         summary = F,
         scale = "linear") |> 
  data.frame() |> 
  rlang::set_names("p")

glimpse(f)
```

```{r}
#| label: fig-brms-model-density
#| fig-cap: "Density plot of the fittet {brms} model"

f |> 
  ggplot(aes(x = p)) +
  geom_density(fill = "deepskyblue", color = "deepskyblue") +
  annotate(geom = "text", x = .08, y = 2.5,
           label = "Posterior probability") +
  scale_x_continuous("probability of water",
                     breaks = c(0, .5, 1),
                     limits = 0:1) +
  scale_y_continuous(NULL, breaks = NULL) +
  theme(panel.grid = ggplot2::element_blank())
```

The graphic should look like the top part of Figure 3.6, reproduced as
@fig-repr-figure-3.6-top-b. (I am not sure if the differences are
important: I have a smaller apex and my curve is more irregular.)

> Much like we did with samples, we can use this distribution of
> probabilities to predict histograms of $w$ counts. With those in hand,
> we can make an analogue to the histogram in the bottom panel of Figure
> 3.6.

```{r}
#| label: fig-sim-pred-values-b
#| fig-cap: "Simulation to predict posterior distribution" 

set.seed(3)
f <-
  f |> 
  mutate(w2 = rbinom(n(), size = 9,  prob = p))

# the plot
f |> 
  ggplot(aes(x = w2)) +
  geom_histogram(binwidth = 1, center = 0, color = "black",
                 fill = "deepskyblue", linewidth = 1/10) +
  scale_x_continuous("number of water samples", breaks = 0:3 * 3) +
  scale_y_continuous(NULL, breaks = NULL, limits = c(0, 5000)) +
  ggtitle("Posterior predictive distribution") +
  coord_cartesian(xlim = c(0, 9)) +
  theme(panel.grid = ggplot2::element_blank())
```

## Session info

```{r}
#| label: session-info

sessionInfo()
```
